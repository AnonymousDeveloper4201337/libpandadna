/*
 * This file generated by:
 * interrogate -D__inline -DCPPPARSER -DP3_INTERROGATE=1 -D__cplusplus -fnames -string -refcount -assert -SC:\Panda3D-1.8.1\include\parser-inc -SC:\Panda3D-1.8.1\include -IC:\Panda3D-1.8.1\include -oc libpandadna_igate.cxx -od libpandadna.in -python-native BlockHandle.h CompCodes.h DNAAnimBuilding.h DNAAnimProp.h DNABattleCell.h DNACornice.h DNADoor.h DNAFlatBuilding.h DNAFlatDoor.h DNAGroup.h DNAInteractiveProp.h DNALandmarkBuilding.h DNALoader.h DNANode.h DNAProp.h DNASign.h DNASignBaseline.h DNASignGraphic.h DNASignText.h DNAStorage.h DNAStreet.h DNASuitEdge.h DNASuitPoint.h DNAVisGroup.h DNAWall.h DNAWindows.h dnabase.h -module libpandadna -library libpandadna -Dvolatile= 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpandadna
#include "py_panda.h"  

#include "BlockHandle.h"
#include "CompCodes.h"
#include "DNAAnimBuilding.h"
#include "DNAAnimProp.h"
#include "DNABattleCell.h"
#include "DNACornice.h"
#include "DNADoor.h"
#include "DNAFlatBuilding.h"
#include "DNAFlatDoor.h"
#include "DNAGroup.h"
#include "DNAInteractiveProp.h"
#include "DNALandmarkBuilding.h"
#include "DNALoader.h"
#include "DNANode.h"
#include "DNAProp.h"
#include "DNASign.h"
#include "DNASignBaseline.h"
#include "DNASignGraphic.h"
#include "DNASignText.h"
#include "DNAStorage.h"
#include "DNAStreet.h"
#include "DNASuitEdge.h"
#include "DNASuitPoint.h"
#include "DNAVisGroup.h"
#include "DNAWall.h"
#include "DNAWindows.h"
#include <datagram.h>
#include <datagramIterator.h>
#include "dnabase.h"
#include "dtool_config.h"
#include <filename.h>
#include <lvector3.h>
#include <map>
#include <nodePath.h>
#include "pandabase.h"
#include <textFont.h>
#include <texture.h>
#include <vector>

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. DNASuitPoint
//********************************************************************
typedef  DNASuitPoint  DNASuitPoint_localtype;
Define_Module_Class(libpandadna,DNASuitPoint,DNASuitPoint_localtype,DNASuitPoint);
//********************************************************************
//*** prototypes for .. DNASuitEdge
//********************************************************************
typedef  DNASuitEdge  DNASuitEdge_localtype;
Define_Module_Class(libpandadna,DNASuitEdge,DNASuitEdge_localtype,DNASuitEdge);
//********************************************************************
//*** prototypes for .. DNABattleCell
//********************************************************************
typedef  DNABattleCell  DNABattleCell_localtype;
Define_Module_Class(libpandadna,DNABattleCell,DNABattleCell_localtype,DNABattleCell);
//********************************************************************
//*** prototypes for .. DNAStorage
//********************************************************************
typedef  DNAStorage  DNAStorage_localtype;
Define_Module_Class(libpandadna,DNAStorage,DNAStorage_localtype,DNAStorage);
//********************************************************************
//*** prototypes for .. DNAGroup
//********************************************************************
typedef  DNAGroup  DNAGroup_localtype;
Define_Module_Class(libpandadna,DNAGroup,DNAGroup_localtype,DNAGroup);
//********************************************************************
//*** prototypes for .. DNANode
//********************************************************************
typedef  DNANode  DNANode_localtype;
Define_Module_Class(libpandadna,DNANode,DNANode_localtype,DNANode);
//********************************************************************
//*** prototypes for .. DNALandmarkBuilding
//********************************************************************
typedef  DNALandmarkBuilding  DNALandmarkBuilding_localtype;
Define_Module_Class(libpandadna,DNALandmarkBuilding,DNALandmarkBuilding_localtype,DNALandmarkBuilding);
//********************************************************************
//*** prototypes for .. DNAAnimBuilding
//********************************************************************
typedef  DNAAnimBuilding  DNAAnimBuilding_localtype;
Define_Module_Class(libpandadna,DNAAnimBuilding,DNAAnimBuilding_localtype,DNAAnimBuilding);
//********************************************************************
//*** prototypes for .. DNAProp
//********************************************************************
typedef  DNAProp  DNAProp_localtype;
Define_Module_Class(libpandadna,DNAProp,DNAProp_localtype,DNAProp);
//********************************************************************
//*** prototypes for .. DNAAnimProp
//********************************************************************
typedef  DNAAnimProp  DNAAnimProp_localtype;
Define_Module_Class(libpandadna,DNAAnimProp,DNAAnimProp_localtype,DNAAnimProp);
//********************************************************************
//*** prototypes for .. DNACornice
//********************************************************************
typedef  DNACornice  DNACornice_localtype;
Define_Module_Class(libpandadna,DNACornice,DNACornice_localtype,DNACornice);
//********************************************************************
//*** prototypes for .. DNADoor
//********************************************************************
typedef  DNADoor  DNADoor_localtype;
Define_Module_Class(libpandadna,DNADoor,DNADoor_localtype,DNADoor);
//********************************************************************
//*** prototypes for .. DNAFlatBuilding
//********************************************************************
typedef  DNAFlatBuilding  DNAFlatBuilding_localtype;
Define_Module_Class(libpandadna,DNAFlatBuilding,DNAFlatBuilding_localtype,DNAFlatBuilding);
//********************************************************************
//*** prototypes for .. DNAFlatDoor
//********************************************************************
typedef  DNAFlatDoor  DNAFlatDoor_localtype;
Define_Module_Class(libpandadna,DNAFlatDoor,DNAFlatDoor_localtype,DNAFlatDoor);
//********************************************************************
//*** prototypes for .. DNAInteractiveProp
//********************************************************************
typedef  DNAInteractiveProp  DNAInteractiveProp_localtype;
Define_Module_Class(libpandadna,DNAInteractiveProp,DNAInteractiveProp_localtype,DNAInteractiveProp);
//********************************************************************
//*** prototypes for .. DNAVisGroup
//********************************************************************
typedef  DNAVisGroup  DNAVisGroup_localtype;
Define_Module_Class(libpandadna,DNAVisGroup,DNAVisGroup_localtype,DNAVisGroup);
//********************************************************************
//*** prototypes for .. DNASign
//********************************************************************
typedef  DNASign  DNASign_localtype;
Define_Module_Class(libpandadna,DNASign,DNASign_localtype,DNASign);
//********************************************************************
//*** prototypes for .. DNASignBaseline
//********************************************************************
typedef  DNASignBaseline  DNASignBaseline_localtype;
Define_Module_Class(libpandadna,DNASignBaseline,DNASignBaseline_localtype,DNASignBaseline);
//********************************************************************
//*** prototypes for .. DNASignText
//********************************************************************
typedef  DNASignText  DNASignText_localtype;
Define_Module_Class(libpandadna,DNASignText,DNASignText_localtype,DNASignText);
//********************************************************************
//*** prototypes for .. DNASignGraphic
//********************************************************************
typedef  DNASignGraphic  DNASignGraphic_localtype;
Define_Module_Class(libpandadna,DNASignGraphic,DNASignGraphic_localtype,DNASignGraphic);
//********************************************************************
//*** prototypes for .. DNAWall
//********************************************************************
typedef  DNAWall  DNAWall_localtype;
Define_Module_Class(libpandadna,DNAWall,DNAWall_localtype,DNAWall);
//********************************************************************
//*** prototypes for .. DNAWindows
//********************************************************************
typedef  DNAWindows  DNAWindows_localtype;
Define_Module_Class(libpandadna,DNAWindows,DNAWindows_localtype,DNAWindows);
//********************************************************************
//*** prototypes for .. DNAStreet
//********************************************************************
typedef  DNAStreet  DNAStreet_localtype;
Define_Module_Class(libpandadna,DNAStreet,DNAStreet_localtype,DNAStreet);
//********************************************************************
//*** prototypes for .. DNALoader
//********************************************************************
typedef  DNALoader  DNALoader_localtype;
Define_Module_Class(libpandadna,DNALoader,DNALoader_localtype,DNALoader);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextFont;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Texture;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. DNASuitPoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNASuitPoint::set_index(unsigned char )
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_index_25(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASuitPoint::set_index(unsigned char )
        PyObject *param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:set_index", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:set_index", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_index(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.set_index() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_index(non-const DNASuitPoint this, unsigned int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_set_index_25_comment =
    "C++ Interface:\n"
    "set_index(non-const DNASuitPoint this, unsigned int)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_set_index_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitPoint::set_graph_id(char )
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_graph_id_26(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASuitPoint::set_graph_id(char )
        int param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:set_graph_id", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:set_graph_id", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_graph_id((char)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.set_graph_id() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_graph_id(non-const DNASuitPoint this, int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_set_graph_id_26_comment =
    "C++ Interface:\n"
    "set_graph_id(non-const DNASuitPoint this, int)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_set_graph_id_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitPoint::set_landmark_building_index(short int )
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_landmark_building_index_27(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASuitPoint::set_landmark_building_index(short int )
        int param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:set_landmark_building_index", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:set_landmark_building_index", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_landmark_building_index((short int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.set_landmark_building_index() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_landmark_building_index(non-const DNASuitPoint this, int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_set_landmark_building_index_27_comment =
    "C++ Interface:\n"
    "set_landmark_building_index(non-const DNASuitPoint this, int)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_set_landmark_building_index_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitPoint::set_pos(LVector3f *)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_pos_28(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNASuitPoint::set_pos(LVector3f *)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:set_pos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:set_pos", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "DNASuitPoint.set_pos", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_pos(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNASuitPoint.set_pos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_pos(non-const DNASuitPoint this, non-const LVector3f)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_set_pos_28_comment =
    "C++ Interface:\n"
    "set_pos(non-const DNASuitPoint this, non-const LVector3f)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_set_pos_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitPoint::set_point_type(char const *)
 * void DNASuitPoint::set_point_type(unsigned short int )
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_point_type_29(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void DNASuitPoint::set_point_type(char const *)
        char *param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:set_point_type", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:set_point_type", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_point_type((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void DNASuitPoint::set_point_type(unsigned short int )
        PyObject *param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:set_point_type", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:set_point_type", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_point_type(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_point_type(non-const DNASuitPoint this, string)\n"
          "set_point_type(non-const DNASuitPoint this, unsigned int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_set_point_type_29_comment =
    "C++ Interface:\n"
    "set_point_type(non-const DNASuitPoint this, string)\n"
    "set_point_type(non-const DNASuitPoint this, unsigned int)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_set_point_type_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned char DNASuitPoint::get_index(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_index_30(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned char DNASuitPoint::get_index(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_index", key_word_list));
        else
            (PyArg_Parse(args, ":get_index"));
        if(!PyErr_Occurred())
        {
            unsigned char return_value = (local_this)->get_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.get_index() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_index(non-const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_index_30_comment =
    "C++ Interface:\n"
    "get_index(non-const DNASuitPoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_index_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char DNASuitPoint::get_graph_id(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_graph_id_31(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-char DNASuitPoint::get_graph_id(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_graph_id", key_word_list));
        else
            (PyArg_Parse(args, ":get_graph_id"));
        if(!PyErr_Occurred())
        {
            char return_value = (local_this)->get_graph_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.get_graph_id() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_graph_id(non-const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_graph_id_31_comment =
    "C++ Interface:\n"
    "get_graph_id(non-const DNASuitPoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_graph_id_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * short int DNASuitPoint::get_landmark_building_index(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_landmark_building_index_32(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-short int DNASuitPoint::get_landmark_building_index(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_landmark_building_index", key_word_list));
        else
            (PyArg_Parse(args, ":get_landmark_building_index"));
        if(!PyErr_Occurred())
        {
            short int return_value = (local_this)->get_landmark_building_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.get_landmark_building_index() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_landmark_building_index(non-const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_landmark_building_index_32_comment =
    "C++ Interface:\n"
    "get_landmark_building_index(non-const DNASuitPoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_landmark_building_index_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVector3f *DNASuitPoint::get_pos(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_pos_33(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVector3f *DNASuitPoint::get_pos(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_pos", key_word_list));
        else
            (PyArg_Parse(args, ":get_pos"));
        if(!PyErr_Occurred())
        {
            LVector3f *return_value = (local_this)->get_pos();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.get_pos() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_pos(non-const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_pos_33_comment =
    "C++ Interface:\n"
    "get_pos(non-const DNASuitPoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_pos_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int DNASuitPoint::get_point_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_point_type_34(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned short int DNASuitPoint::get_point_type(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_point_type", key_word_list));
        else
            (PyArg_Parse(args, ":get_point_type"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = (local_this)->get_point_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.get_point_type() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_point_type(non-const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_point_type_34_comment =
    "C++ Interface:\n"
    "get_point_type(non-const DNASuitPoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_point_type_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPoint::DNASuitPoint(unsigned short int , unsigned char , LVector3f *, short int )
 *******************************************************************/
int  Dtool_Init_DNASuitPoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-DNASuitPoint::DNASuitPoint(unsigned short int , unsigned char , LVector3f *, short int )
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            int param3;
            static char * key_word_list[] = {(char *)"param0", (char *)"param1", (char *)"param2", (char *)"param3", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:DNASuitPoint", key_word_list, &param0, &param1, &param2, &param3))
            {
                 PyObject *param0_uint = PyNumber_Long(param0); PyObject *param1_uint = PyNumber_Long(param1);LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "DNASuitPoint.DNASuitPoint", 0, coerced_ptr, report_errors);

                if (!((param0_uint == NULL)|| (param1_uint == NULL)|| (param2_this == NULL)))
                {
                    DNASuitPoint *return_value = new DNASuitPoint(PyLong_AsUnsignedLong(param0_uint), PyLong_AsUnsignedLong(param1_uint), param2_this, (short int)param3);
                     Py_XDECREF(param0_uint); Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASuitPoint,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNASuitPoint(unsigned int, unsigned int, non-const LVector3f, int)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASuitPoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASuitPoint)
    {
        printf("DNASuitPoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASuitPoint * local_this = (DNASuitPoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASuitPoint)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASuitPoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASuitPoint)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASuitEdge 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNASuitEdge::set_start_point(unsigned short int start_point)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_set_start_point_38(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASuitEdge::set_start_point(unsigned short int start_point)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"start_point", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:set_start_point", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:set_start_point", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_start_point(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitEdge.set_start_point() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_start_point(non-const DNASuitEdge this, unsigned int start_point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_set_start_point_38_comment =
    "C++ Interface:\n"
    "set_start_point(non-const DNASuitEdge this, unsigned int start_point)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_set_start_point_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitEdge::set_end_point(unsigned short int end_point)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_set_end_point_39(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASuitEdge::set_end_point(unsigned short int end_point)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"end_point", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:set_end_point", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:set_end_point", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_end_point(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitEdge.set_end_point() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_end_point(non-const DNASuitEdge this, unsigned int end_point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_set_end_point_39_comment =
    "C++ Interface:\n"
    "set_end_point(non-const DNASuitEdge this, unsigned int end_point)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_set_end_point_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitEdge::set_zone_id(unsigned short int zone_id)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_set_zone_id_40(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASuitEdge::set_zone_id(unsigned short int zone_id)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"zone_id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:set_zone_id", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:set_zone_id", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_zone_id(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitEdge.set_zone_id() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_zone_id(non-const DNASuitEdge this, unsigned int zone_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_set_zone_id_40_comment =
    "C++ Interface:\n"
    "set_zone_id(non-const DNASuitEdge this, unsigned int zone_id)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_set_zone_id_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int DNASuitEdge::get_start_point(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_start_point_41(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned short int DNASuitEdge::get_start_point(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_start_point", key_word_list));
        else
            (PyArg_Parse(args, ":get_start_point"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = (local_this)->get_start_point();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitEdge.get_start_point() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_start_point(non-const DNASuitEdge this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_get_start_point_41_comment =
    "C++ Interface:\n"
    "get_start_point(non-const DNASuitEdge this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_get_start_point_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int DNASuitEdge::get_end_point(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_end_point_42(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned short int DNASuitEdge::get_end_point(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_end_point", key_word_list));
        else
            (PyArg_Parse(args, ":get_end_point"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = (local_this)->get_end_point();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitEdge.get_end_point() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_end_point(non-const DNASuitEdge this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_get_end_point_42_comment =
    "C++ Interface:\n"
    "get_end_point(non-const DNASuitEdge this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_get_end_point_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int DNASuitEdge::get_zone_id(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_zone_id_43(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned short int DNASuitEdge::get_zone_id(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_zone_id", key_word_list));
        else
            (PyArg_Parse(args, ":get_zone_id"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = (local_this)->get_zone_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitEdge.get_zone_id() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_zone_id(non-const DNASuitEdge this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_get_zone_id_43_comment =
    "C++ Interface:\n"
    "get_zone_id(non-const DNASuitEdge this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_get_zone_id_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitEdge::DNASuitEdge(void)
 *******************************************************************/
int  Dtool_Init_DNASuitEdge(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNASuitEdge::DNASuitEdge(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNASuitEdge", key_word_list))
        {
            DNASuitEdge *return_value = new DNASuitEdge();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASuitEdge,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNASuitEdge()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASuitEdge(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASuitEdge)
    {
        printf("DNASuitEdge ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASuitEdge * local_this = (DNASuitEdge *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASuitEdge)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASuitEdge(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASuitEdge)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNABattleCell 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNABattleCell::set_width(unsigned char width)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_set_width_47(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNABattleCell::set_width(unsigned char width)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"width", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:set_width", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:set_width", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_width(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNABattleCell.set_width() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_width(non-const DNABattleCell this, unsigned int width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_set_width_47_comment =
    "C++ Interface:\n"
    "set_width(non-const DNABattleCell this, unsigned int width)\n"
    "\n"
    "";
#else
static const char * Dtool_DNABattleCell_set_width_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNABattleCell::set_height(unsigned char height)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_set_height_48(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNABattleCell::set_height(unsigned char height)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"height", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:set_height", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:set_height", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_height(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNABattleCell.set_height() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_height(non-const DNABattleCell this, unsigned int height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_set_height_48_comment =
    "C++ Interface:\n"
    "set_height(non-const DNABattleCell this, unsigned int height)\n"
    "\n"
    "";
#else
static const char * Dtool_DNABattleCell_set_height_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNABattleCell::set_width_height(unsigned char width, unsigned char height)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_set_width_height_49(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNABattleCell::set_width_height(unsigned char width, unsigned char height)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"width", (char *)"height", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:set_width_height", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_width_height(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNABattleCell.set_width_height() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_width_height(non-const DNABattleCell this, unsigned int width, unsigned int height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_set_width_height_49_comment =
    "C++ Interface:\n"
    "set_width_height(non-const DNABattleCell this, unsigned int width, unsigned int height)\n"
    "\n"
    "";
#else
static const char * Dtool_DNABattleCell_set_width_height_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNABattleCell::set_pos(LVector3f *pos)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_set_pos_50(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNABattleCell::set_pos(LVector3f *pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:set_pos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:set_pos", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "DNABattleCell.set_pos", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_pos(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNABattleCell.set_pos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_pos(non-const DNABattleCell this, non-const LVector3f pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_set_pos_50_comment =
    "C++ Interface:\n"
    "set_pos(non-const DNABattleCell this, non-const LVector3f pos)\n"
    "\n"
    "";
#else
static const char * Dtool_DNABattleCell_set_pos_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned char DNABattleCell::get_width(void)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_width_51(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned char DNABattleCell::get_width(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_width", key_word_list));
        else
            (PyArg_Parse(args, ":get_width"));
        if(!PyErr_Occurred())
        {
            unsigned char return_value = (local_this)->get_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNABattleCell.get_width() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_width(non-const DNABattleCell this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_get_width_51_comment =
    "C++ Interface:\n"
    "get_width(non-const DNABattleCell this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNABattleCell_get_width_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned char DNABattleCell::get_height(void)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_height_52(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned char DNABattleCell::get_height(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_height", key_word_list));
        else
            (PyArg_Parse(args, ":get_height"));
        if(!PyErr_Occurred())
        {
            unsigned char return_value = (local_this)->get_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNABattleCell.get_height() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_height(non-const DNABattleCell this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_get_height_52_comment =
    "C++ Interface:\n"
    "get_height(non-const DNABattleCell this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNABattleCell_get_height_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVector3f *DNABattleCell::get_pos(void)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_pos_53(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVector3f *DNABattleCell::get_pos(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_pos", key_word_list));
        else
            (PyArg_Parse(args, ":get_pos"));
        if(!PyErr_Occurred())
        {
            LVector3f *return_value = (local_this)->get_pos();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNABattleCell.get_pos() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_pos(non-const DNABattleCell this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_get_pos_53_comment =
    "C++ Interface:\n"
    "get_pos(non-const DNABattleCell this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNABattleCell_get_pos_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNABattleCell::DNABattleCell(void)
 *******************************************************************/
int  Dtool_Init_DNABattleCell(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNABattleCell::DNABattleCell(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNABattleCell", key_word_list))
        {
            DNABattleCell *return_value = new DNABattleCell();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNABattleCell,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNABattleCell()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNABattleCell(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNABattleCell)
    {
        printf("DNABattleCell ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNABattleCell * local_this = (DNABattleCell *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNABattleCell)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNABattleCell(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNABattleCell)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAStorage 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_catalog_code(basic_string< char > const &root, basic_string< char > const &code)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_catalog_code_57(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::store_catalog_code(basic_string< char > const &root, basic_string< char > const &code)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"root", (char *)"code", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:store_catalog_code", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            (local_this)->store_catalog_code(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.store_catalog_code() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store_catalog_code(non-const DNAStorage this, string root, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_catalog_code_57_comment =
    "C++ Interface:\n"
    "store_catalog_code(non-const DNAStorage this, string root, string code)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_store_catalog_code_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_catalog_code(basic_string< char > const &category, unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_catalog_code_58(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DNAStorage::get_catalog_code(basic_string< char > const &category, unsigned int index)
        char *param1_str; int param1_len;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"category", (char *)"index", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:get_catalog_code", key_word_list, &param1_str, &param1_len, &param2))
        {
             PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param2_uint == NULL)))
            {
                basic_string< char > return_value = (local_this)->get_catalog_code(basic_string<char>(param1_str, param1_len), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.get_catalog_code() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_catalog_code(non-const DNAStorage this, string category, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_catalog_code_58_comment =
    "C++ Interface:\n"
    "get_catalog_code(non-const DNAStorage this, string category, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_catalog_code_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_num_catalog_codes(basic_string< char > const &category)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_catalog_codes_59(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DNAStorage::get_num_catalog_codes(basic_string< char > const &category)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"category", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:get_num_catalog_codes", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:get_num_catalog_codes", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_num_catalog_codes(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.get_num_catalog_codes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_num_catalog_codes(non-const DNAStorage this, string category)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_catalog_codes_59_comment =
    "C++ Interface:\n"
    "get_num_catalog_codes(non-const DNAStorage this, string category)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_catalog_codes_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_texture(basic_string< char > const &code, Texture *texture)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_texture_60(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_texture(basic_string< char > const &code, Texture *texture)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"code", (char *)"texture", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:store_texture", key_word_list, &param1_str, &param1_len, &param2))
            {
                Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Texture, 2, "DNAStorage.store_texture", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->store_texture(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.store_texture() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store_texture(non-const DNAStorage this, string code, non-const Texture texture)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_texture_60_comment =
    "C++ Interface:\n"
    "store_texture(non-const DNAStorage this, string code, non-const Texture texture)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_store_texture_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Texture *DNAStorage::find_texture(basic_string< char > const &code)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_texture_61(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Texture *DNAStorage::find_texture(basic_string< char > const &code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:find_texture", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:find_texture", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            Texture *return_value = (local_this)->find_texture(basic_string<char>(param1_str, param1_len));
            if (return_value != (Texture *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Texture,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.find_texture() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "find_texture(non-const DNAStorage this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_find_texture_61_comment =
    "C++ Interface:\n"
    "find_texture(non-const DNAStorage this, string code)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_find_texture_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_textures(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_textures_62(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::reset_textures(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset_textures", key_word_list));
        else
            (PyArg_Parse(args, ":reset_textures"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_textures();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.reset_textures() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset_textures(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_textures_62_comment =
    "C++ Interface:\n"
    "reset_textures(non-const DNAStorage this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_textures_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_font(basic_string< char > const &code, TextFont *font)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_font_63(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_font(basic_string< char > const &code, TextFont *font)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"code", (char *)"font", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:store_font", key_word_list, &param1_str, &param1_len, &param2))
            {
                TextFont *param2_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TextFont, 2, "DNAStorage.store_font", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->store_font(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.store_font() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store_font(non-const DNAStorage this, string code, non-const TextFont font)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_font_63_comment =
    "C++ Interface:\n"
    "store_font(non-const DNAStorage this, string code, non-const TextFont font)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_store_font_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextFont *DNAStorage::find_font(basic_string< char > const &code)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_font_64(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TextFont *DNAStorage::find_font(basic_string< char > const &code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:find_font", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:find_font", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            TextFont *return_value = (local_this)->find_font(basic_string<char>(param1_str, param1_len));
            if (return_value != (TextFont *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextFont,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.find_font() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "find_font(non-const DNAStorage this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_find_font_64_comment =
    "C++ Interface:\n"
    "find_font(non-const DNAStorage this, string code)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_find_font_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_fonts(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_fonts_65(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::reset_fonts(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset_fonts", key_word_list));
        else
            (PyArg_Parse(args, ":reset_fonts"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_fonts();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.reset_fonts() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset_fonts(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_fonts_65_comment =
    "C++ Interface:\n"
    "reset_fonts(non-const DNAStorage this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_fonts_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_node(basic_string< char > const &code, NodePath *node)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_node_66(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_node(basic_string< char > const &code, NodePath *node)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"code", (char *)"node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:store_node", key_word_list, &param1_str, &param1_len, &param2))
            {
                NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNAStorage.store_node", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->store_node(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.store_node() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store_node(non-const DNAStorage this, string code, non-const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_node_66_comment =
    "C++ Interface:\n"
    "store_node(non-const DNAStorage this, string code, non-const NodePath node)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_store_node_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_nodes(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_nodes_67(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::reset_nodes(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset_nodes", key_word_list));
        else
            (PyArg_Parse(args, ":reset_nodes"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_nodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.reset_nodes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset_nodes(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_nodes_67_comment =
    "C++ Interface:\n"
    "reset_nodes(non-const DNAStorage this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_nodes_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_hood_node(basic_string< char > const &code, NodePath *node)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_hood_node_68(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_hood_node(basic_string< char > const &code, NodePath *node)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"code", (char *)"node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:store_hood_node", key_word_list, &param1_str, &param1_len, &param2))
            {
                NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNAStorage.store_hood_node", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->store_hood_node(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.store_hood_node() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store_hood_node(non-const DNAStorage this, string code, non-const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_hood_node_68_comment =
    "C++ Interface:\n"
    "store_hood_node(non-const DNAStorage this, string code, non-const NodePath node)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_store_hood_node_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_hood_nodes(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_hood_nodes_69(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::reset_hood_nodes(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset_hood_nodes", key_word_list));
        else
            (PyArg_Parse(args, ":reset_hood_nodes"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_hood_nodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.reset_hood_nodes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset_hood_nodes(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_hood_nodes_69_comment =
    "C++ Interface:\n"
    "reset_hood_nodes(non-const DNAStorage this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_hood_nodes_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_place_node(basic_string< char > const &code, NodePath *node)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_place_node_70(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_place_node(basic_string< char > const &code, NodePath *node)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"code", (char *)"node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:store_place_node", key_word_list, &param1_str, &param1_len, &param2))
            {
                NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNAStorage.store_place_node", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->store_place_node(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.store_place_node() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store_place_node(non-const DNAStorage this, string code, non-const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_place_node_70_comment =
    "C++ Interface:\n"
    "store_place_node(non-const DNAStorage this, string code, non-const NodePath node)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_store_place_node_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_place_nodes(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_place_nodes_71(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::reset_place_nodes(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset_place_nodes", key_word_list));
        else
            (PyArg_Parse(args, ":reset_place_nodes"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_place_nodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.reset_place_nodes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset_place_nodes(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_place_nodes_71_comment =
    "C++ Interface:\n"
    "reset_place_nodes(non-const DNAStorage this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_place_nodes_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath *DNAStorage::find_node(basic_string< char > const &code)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_node_72(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NodePath *DNAStorage::find_node(basic_string< char > const &code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:find_node", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:find_node", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            NodePath *return_value = (local_this)->find_node(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.find_node() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "find_node(non-const DNAStorage this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_find_node_72_comment =
    "C++ Interface:\n"
    "find_node(non-const DNAStorage this, string code)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_find_node_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPoint DNAStorage::get_suit_point_at_index(unsigned short int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_point_at_index_73(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DNASuitPoint DNAStorage::get_suit_point_at_index(unsigned short int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:get_suit_point_at_index", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:get_suit_point_at_index", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                DNASuitPoint result = (local_this)->get_suit_point_at_index(PyLong_AsUnsignedLong(param1_uint));
                DNASuitPoint *return_value = new DNASuitPoint(result);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_DNASuitPoint,true, false);
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.get_suit_point_at_index() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_suit_point_at_index(non-const DNAStorage this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_suit_point_at_index_73_comment =
    "C++ Interface:\n"
    "get_suit_point_at_index(non-const DNAStorage this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_suit_point_at_index_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_suit_points(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_suit_points_74(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::reset_suit_points(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset_suit_points", key_word_list));
        else
            (PyArg_Parse(args, ":reset_suit_points"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_suit_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.reset_suit_points() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset_suit_points(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_suit_points_74_comment =
    "C++ Interface:\n"
    "reset_suit_points(non-const DNAStorage this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_suit_points_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_block_building_type(unsigned short int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_block_building_type_75(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DNAStorage::get_block_building_type(unsigned short int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:get_block_building_type", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:get_block_building_type", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                basic_string< char > return_value = (local_this)->get_block_building_type(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.get_block_building_type() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_block_building_type(non-const DNAStorage this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_block_building_type_75_comment =
    "C++ Interface:\n"
    "get_block_building_type(non-const DNAStorage this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_block_building_type_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_title_from_block_number(unsigned short int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_title_from_block_number_76(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DNAStorage::get_title_from_block_number(unsigned short int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:get_title_from_block_number", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:get_title_from_block_number", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                basic_string< char > return_value = (local_this)->get_title_from_block_number(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.get_title_from_block_number() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_title_from_block_number(non-const DNAStorage this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_title_from_block_number_76_comment =
    "C++ Interface:\n"
    "get_title_from_block_number(non-const DNAStorage this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_title_from_block_number_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int DNAStorage::get_zone_from_block_number(unsigned short int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_zone_from_block_number_77(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned short int DNAStorage::get_zone_from_block_number(unsigned short int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:get_zone_from_block_number", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:get_zone_from_block_number", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                unsigned short int return_value = (local_this)->get_zone_from_block_number(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLongOrInt_FromUnsignedLong(return_value);
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.get_zone_from_block_number() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_zone_from_block_number(non-const DNAStorage this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_zone_from_block_number_77_comment =
    "C++ Interface:\n"
    "get_zone_from_block_number(non-const DNAStorage this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_zone_from_block_number_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned char DNAStorage::get_num_block_numbers(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_block_numbers_78(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned char DNAStorage::get_num_block_numbers(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_num_block_numbers", key_word_list));
        else
            (PyArg_Parse(args, ":get_num_block_numbers"));
        if(!PyErr_Occurred())
        {
            unsigned char return_value = (local_this)->get_num_block_numbers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.get_num_block_numbers() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_num_block_numbers(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_block_numbers_78_comment =
    "C++ Interface:\n"
    "get_num_block_numbers(non-const DNAStorage this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_block_numbers_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitEdge DNAStorage::get_suit_edge(unsigned short int start_index, unsigned short int end_index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_edge_79(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DNASuitEdge DNAStorage::get_suit_edge(unsigned short int start_index, unsigned short int end_index)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"start_index", (char *)"end_index", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:get_suit_edge", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                DNASuitEdge result = (local_this)->get_suit_edge(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                DNASuitEdge *return_value = new DNASuitEdge(result);
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_DNASuitEdge,true, false);
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.get_suit_edge() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_suit_edge(non-const DNAStorage this, unsigned int start_index, unsigned int end_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_suit_edge_79_comment =
    "C++ Interface:\n"
    "get_suit_edge(non-const DNAStorage this, unsigned int start_index, unsigned int end_index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_suit_edge_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_battle_cells(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_battle_cells_80(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::reset_battle_cells(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset_battle_cells", key_word_list));
        else
            (PyArg_Parse(args, ":reset_battle_cells"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_battle_cells();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.reset_battle_cells() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset_battle_cells(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_battle_cells_80_comment =
    "C++ Interface:\n"
    "reset_battle_cells(non-const DNAStorage this)\n"
    "\n"
    "//void remove_battle_cell(DNABattleCell cell); // To do\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_battle_cells_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNABattleCell DNAStorage::get_battle_cell(unsigned short int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_battle_cell_81(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DNABattleCell DNAStorage::get_battle_cell(unsigned short int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:get_battle_cell", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:get_battle_cell", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                DNABattleCell result = (local_this)->get_battle_cell(PyLong_AsUnsignedLong(param1_uint));
                DNABattleCell *return_value = new DNABattleCell(result);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_DNABattleCell,true, false);
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.get_battle_cell() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_battle_cell(non-const DNAStorage this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_battle_cell_81_comment =
    "C++ Interface:\n"
    "get_battle_cell(non-const DNAStorage this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_battle_cell_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int DNAStorage::get_num_battle_cells(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_battle_cells_82(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned short int DNAStorage::get_num_battle_cells(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_num_battle_cells", key_word_list));
        else
            (PyArg_Parse(args, ":get_num_battle_cells"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = (local_this)->get_num_battle_cells();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.get_num_battle_cells() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_num_battle_cells(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_battle_cells_82_comment =
    "C++ Interface:\n"
    "get_num_battle_cells(non-const DNAStorage this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_battle_cells_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAStorage::DNAStorage(void)
 *******************************************************************/
int  Dtool_Init_DNAStorage(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAStorage::DNAStorage(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAStorage", key_word_list))
        {
            DNAStorage *return_value = new DNAStorage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAStorage,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAStorage()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAStorage(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAStorage)
    {
        printf("DNAStorage ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAStorage * local_this = (DNAStorage *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAStorage)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAStorage(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAStorage)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAGroup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNAVisGroup *DNAGroup::get_vis_group(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_vis_group_86(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DNAVisGroup *DNAGroup::get_vis_group(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_vis_group", key_word_list));
        else
            (PyArg_Parse(args, ":get_vis_group"));
        if(!PyErr_Occurred())
        {
            DNAVisGroup *return_value = (local_this)->get_vis_group();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DNAVisGroup,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.get_vis_group() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_vis_group(non-const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_get_vis_group_86_comment =
    "C++ Interface:\n"
    "get_vis_group(non-const DNAGroup this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAGroup_get_vis_group_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAGroup::add(DNAGroup *child)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_add_87(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAGroup::add(DNAGroup *child)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"child", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:add", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:add", &param1));
            if(!PyErr_Occurred())
            {
                DNAGroup *param1_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAGroup, 1, "DNAGroup.add", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAGroup.add() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "add(non-const DNAGroup this, non-const DNAGroup child)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_add_87_comment =
    "C++ Interface:\n"
    "add(non-const DNAGroup this, non-const DNAGroup child)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAGroup_add_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAGroup *DNAGroup::at(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_at_88(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DNAGroup *DNAGroup::at(unsigned int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:at", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:at", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                DNAGroup *return_value = (local_this)->at(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_DNAGroup,false, false);
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.at() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "at(non-const DNAGroup this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_at_88_comment =
    "C++ Interface:\n"
    "at(non-const DNAGroup this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAGroup_at_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAGroup::get_num_children(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_num_children_89(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned int DNAGroup::get_num_children(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_num_children", key_word_list));
        else
            (PyArg_Parse(args, ":get_num_children"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->get_num_children();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.get_num_children() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_num_children(non-const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_get_num_children_89_comment =
    "C++ Interface:\n"
    "get_num_children(non-const DNAGroup this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAGroup_get_num_children_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAGroup::set_parent(DNAGroup *parent)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_set_parent_90(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAGroup::set_parent(DNAGroup *parent)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"parent", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:set_parent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:set_parent", &param1));
            if(!PyErr_Occurred())
            {
                DNAGroup *param1_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAGroup, 1, "DNAGroup.set_parent", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_parent(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAGroup.set_parent() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set_parent(non-const DNAGroup this, non-const DNAGroup parent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_set_parent_90_comment =
    "C++ Interface:\n"
    "set_parent(non-const DNAGroup this, non-const DNAGroup parent)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAGroup_set_parent_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAGroup::clear_parent(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_clear_parent_91(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAGroup::clear_parent(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear_parent", key_word_list));
        else
            (PyArg_Parse(args, ":clear_parent"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_parent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.clear_parent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear_parent(non-const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_clear_parent_91_comment =
    "C++ Interface:\n"
    "clear_parent(non-const DNAGroup this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAGroup_clear_parent_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAGroup *DNAGroup::get_parent(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_parent_92(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DNAGroup *DNAGroup::get_parent(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_parent", key_word_list));
        else
            (PyArg_Parse(args, ":get_parent"));
        if(!PyErr_Occurred())
        {
            DNAGroup *return_value = (local_this)->get_parent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DNAGroup,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.get_parent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_parent(non-const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_get_parent_92_comment =
    "C++ Interface:\n"
    "get_parent(non-const DNAGroup this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAGroup_get_parent_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAGroup::get_name(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_name_93(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DNAGroup::get_name(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_name", key_word_list));
        else
            (PyArg_Parse(args, ":get_name"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.get_name() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_name(non-const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_get_name_93_comment =
    "C++ Interface:\n"
    "get_name(non-const DNAGroup this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAGroup_get_name_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAGroup::DNAGroup(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAGroup(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAGroup::DNAGroup(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAGroup", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAGroup", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAGroup *return_value = new DNAGroup(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAGroup,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAGroup(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAGroup)
    {
        printf("DNAGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAGroup * local_this = (DNAGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAGroup)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAGroup)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNANode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNANode::DNANode(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNANode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNANode::DNANode(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNANode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNANode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNANode *return_value = new DNANode(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNANode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNANode(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNANode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNANode)
    {
        printf("DNANode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNANode * local_this = (DNANode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNANode)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNANode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNANode)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNANode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNALandmarkBuilding 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNALandmarkBuilding::DNALandmarkBuilding(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNALandmarkBuilding(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNALandmarkBuilding::DNALandmarkBuilding(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNALandmarkBuilding", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNALandmarkBuilding", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNALandmarkBuilding *return_value = new DNALandmarkBuilding(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNALandmarkBuilding,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNALandmarkBuilding(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNALandmarkBuilding(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNALandmarkBuilding)
    {
        printf("DNALandmarkBuilding ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNALandmarkBuilding * local_this = (DNALandmarkBuilding *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNALandmarkBuilding)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNALandmarkBuilding(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNALandmarkBuilding)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNALandmarkBuilding*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNALandmarkBuilding*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAAnimBuilding 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNAAnimBuilding::DNAAnimBuilding(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAAnimBuilding(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAAnimBuilding::DNAAnimBuilding(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAAnimBuilding", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAAnimBuilding", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAAnimBuilding *return_value = new DNAAnimBuilding(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAAnimBuilding,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAAnimBuilding(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAAnimBuilding(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAAnimBuilding)
    {
        printf("DNAAnimBuilding ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAAnimBuilding * local_this = (DNAAnimBuilding *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAAnimBuilding)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *)( DNALandmarkBuilding *) local_this;
    if(requested_type == &Dtool_DNALandmarkBuilding)
        return ( DNALandmarkBuilding *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *)( DNALandmarkBuilding *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAAnimBuilding(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAAnimBuilding)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAAnimBuilding*)other_this;
    }
    if(from_type == &Dtool_DNALandmarkBuilding)
    {
          DNALandmarkBuilding* other_this = (DNALandmarkBuilding*)from_this;
          return (DNAAnimBuilding*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAAnimBuilding*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAProp 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNAProp::DNAProp(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAProp(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAProp::DNAProp(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAProp", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAProp", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAProp *return_value = new DNAProp(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAProp,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAProp(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAProp(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAProp)
    {
        printf("DNAProp ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAProp * local_this = (DNAProp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAProp)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAProp(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAProp)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAProp*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAProp*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAAnimProp 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNAAnimProp::DNAAnimProp(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAAnimProp(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAAnimProp::DNAAnimProp(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAAnimProp", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAAnimProp", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAAnimProp *return_value = new DNAAnimProp(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAAnimProp,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAAnimProp(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAAnimProp(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAAnimProp)
    {
        printf("DNAAnimProp ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAAnimProp * local_this = (DNAAnimProp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAAnimProp)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *)( DNAProp *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *)( DNAProp *) local_this;
    if(requested_type == &Dtool_DNAProp)
        return ( DNAProp *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAAnimProp(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAAnimProp)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAAnimProp*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAAnimProp*)other_this;
    }
    if(from_type == &Dtool_DNAProp)
    {
          DNAProp* other_this = (DNAProp*)from_this;
          return (DNAAnimProp*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNACornice 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNACornice::DNACornice(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNACornice(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNACornice::DNACornice(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNACornice", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNACornice", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNACornice *return_value = new DNACornice(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNACornice,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNACornice(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNACornice(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNACornice)
    {
        printf("DNACornice ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNACornice * local_this = (DNACornice *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNACornice)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNACornice(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNACornice)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNACornice*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNADoor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNADoor::DNADoor(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNADoor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNADoor::DNADoor(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNADoor", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNADoor", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNADoor *return_value = new DNADoor(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNADoor,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNADoor(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNADoor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNADoor)
    {
        printf("DNADoor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNADoor * local_this = (DNADoor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNADoor)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNADoor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNADoor)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNADoor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAFlatBuilding 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNAFlatBuilding::DNAFlatBuilding(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAFlatBuilding(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAFlatBuilding::DNAFlatBuilding(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAFlatBuilding", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAFlatBuilding", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAFlatBuilding *return_value = new DNAFlatBuilding(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAFlatBuilding,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAFlatBuilding(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAFlatBuilding(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAFlatBuilding)
    {
        printf("DNAFlatBuilding ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAFlatBuilding * local_this = (DNAFlatBuilding *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAFlatBuilding)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAFlatBuilding(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAFlatBuilding)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAFlatBuilding*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAFlatBuilding*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAFlatDoor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNAFlatDoor::DNAFlatDoor(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAFlatDoor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAFlatDoor::DNAFlatDoor(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAFlatDoor", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAFlatDoor", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAFlatDoor *return_value = new DNAFlatDoor(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAFlatDoor,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAFlatDoor(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAFlatDoor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAFlatDoor)
    {
        printf("DNAFlatDoor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAFlatDoor * local_this = (DNAFlatDoor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAFlatDoor)
        return local_this;
    if(requested_type == &Dtool_DNADoor)
        return ( DNADoor *) local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNADoor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAFlatDoor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAFlatDoor)
        return from_this;
    if(from_type == &Dtool_DNADoor)
    {
          DNADoor* other_this = (DNADoor*)from_this;
          return (DNAFlatDoor*)other_this;
    }
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAFlatDoor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAInteractiveProp 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNAInteractiveProp::DNAInteractiveProp(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAInteractiveProp(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAInteractiveProp::DNAInteractiveProp(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAInteractiveProp", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAInteractiveProp", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAInteractiveProp *return_value = new DNAInteractiveProp(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAInteractiveProp,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAInteractiveProp(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAInteractiveProp(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAInteractiveProp)
    {
        printf("DNAInteractiveProp ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAInteractiveProp * local_this = (DNAInteractiveProp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAInteractiveProp)
        return local_this;
    if(requested_type == &Dtool_DNAAnimProp)
        return ( DNAAnimProp *) local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *)( DNAProp *)( DNAAnimProp *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *)( DNAProp *)( DNAAnimProp *) local_this;
    if(requested_type == &Dtool_DNAProp)
        return ( DNAProp *)( DNAAnimProp *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAInteractiveProp(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAInteractiveProp)
        return from_this;
    if(from_type == &Dtool_DNAAnimProp)
    {
          DNAAnimProp* other_this = (DNAAnimProp*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    if(from_type == &Dtool_DNAProp)
    {
          DNAProp* other_this = (DNAProp*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAVisGroup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNAVisGroup::add_suit_edge(DNASuitEdge edge)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_add_suit_edge_127(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAVisGroup::add_suit_edge(DNASuitEdge edge)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"edge", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:add_suit_edge", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:add_suit_edge", &param1));
            if(!PyErr_Occurred())
            {
                DNASuitEdge *param1_this = (DNASuitEdge *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitEdge, 1, "DNAVisGroup.add_suit_edge", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_suit_edge(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAVisGroup.add_suit_edge() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "add_suit_edge(non-const DNAVisGroup this, const DNASuitEdge edge)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_add_suit_edge_127_comment =
    "C++ Interface:\n"
    "add_suit_edge(non-const DNAVisGroup this, const DNASuitEdge edge)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAVisGroup_add_suit_edge_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAVisGroup::add_battle_cell(DNABattleCell cell)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_add_battle_cell_128(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAVisGroup::add_battle_cell(DNABattleCell cell)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"cell", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:add_battle_cell", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:add_battle_cell", &param1));
            if(!PyErr_Occurred())
            {
                DNABattleCell *param1_this = (DNABattleCell *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNABattleCell, 1, "DNAVisGroup.add_battle_cell", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_battle_cell(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAVisGroup.add_battle_cell() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "add_battle_cell(non-const DNAVisGroup this, const DNABattleCell cell)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_add_battle_cell_128_comment =
    "C++ Interface:\n"
    "add_battle_cell(non-const DNAVisGroup this, const DNABattleCell cell)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAVisGroup_add_battle_cell_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAVisGroup::add_visible(basic_string< char > visible)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_add_visible_129(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAVisGroup::add_visible(basic_string< char > visible)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"visible", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:add_visible", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:add_visible", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_visible(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAVisGroup.add_visible() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "add_visible(non-const DNAVisGroup this, string visible)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_add_visible_129_comment =
    "C++ Interface:\n"
    "add_visible(non-const DNAVisGroup this, string visible)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAVisGroup_add_visible_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAVisGroup::get_num_battle_cells(void)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_num_battle_cells_130(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned int DNAVisGroup::get_num_battle_cells(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_num_battle_cells", key_word_list));
        else
            (PyArg_Parse(args, ":get_num_battle_cells"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->get_num_battle_cells();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAVisGroup.get_num_battle_cells() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_num_battle_cells(non-const DNAVisGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_num_battle_cells_130_comment =
    "C++ Interface:\n"
    "get_num_battle_cells(non-const DNAVisGroup this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_num_battle_cells_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAVisGroup::get_num_suit_edges(void)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_num_suit_edges_131(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned int DNAVisGroup::get_num_suit_edges(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_num_suit_edges", key_word_list));
        else
            (PyArg_Parse(args, ":get_num_suit_edges"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->get_num_suit_edges();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAVisGroup.get_num_suit_edges() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_num_suit_edges(non-const DNAVisGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_num_suit_edges_131_comment =
    "C++ Interface:\n"
    "get_num_suit_edges(non-const DNAVisGroup this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_num_suit_edges_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAVisGroup::get_num_visibles(void)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_num_visibles_132(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned int DNAVisGroup::get_num_visibles(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get_num_visibles", key_word_list));
        else
            (PyArg_Parse(args, ":get_num_visibles"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->get_num_visibles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAVisGroup.get_num_visibles() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_num_visibles(non-const DNAVisGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_num_visibles_132_comment =
    "C++ Interface:\n"
    "get_num_visibles(non-const DNAVisGroup this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_num_visibles_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNABattleCell DNAVisGroup::get_battle_cell(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_battle_cell_133(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DNABattleCell DNAVisGroup::get_battle_cell(unsigned int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:get_battle_cell", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:get_battle_cell", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                DNABattleCell result = (local_this)->get_battle_cell(PyLong_AsUnsignedLong(param1_uint));
                DNABattleCell *return_value = new DNABattleCell(result);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_DNABattleCell,true, false);
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAVisGroup.get_battle_cell() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_battle_cell(non-const DNAVisGroup this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_battle_cell_133_comment =
    "C++ Interface:\n"
    "get_battle_cell(non-const DNAVisGroup this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_battle_cell_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitEdge DNAVisGroup::get_suit_edge(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_suit_edge_134(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DNASuitEdge DNAVisGroup::get_suit_edge(unsigned int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:get_suit_edge", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:get_suit_edge", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                DNASuitEdge result = (local_this)->get_suit_edge(PyLong_AsUnsignedLong(param1_uint));
                DNASuitEdge *return_value = new DNASuitEdge(result);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_DNASuitEdge,true, false);
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAVisGroup.get_suit_edge() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_suit_edge(non-const DNAVisGroup this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_suit_edge_134_comment =
    "C++ Interface:\n"
    "get_suit_edge(non-const DNAVisGroup this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_suit_edge_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAVisGroup::get_visible_name(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_visible_name_135(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DNAVisGroup::get_visible_name(unsigned int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:get_visible_name", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:get_visible_name", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                basic_string< char > return_value = (local_this)->get_visible_name(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAVisGroup.get_visible_name() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get_visible_name(non-const DNAVisGroup this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_visible_name_135_comment =
    "C++ Interface:\n"
    "get_visible_name(non-const DNAVisGroup this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_visible_name_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAVisGroup::DNAVisGroup(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAVisGroup(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAVisGroup::DNAVisGroup(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAVisGroup", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAVisGroup", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAVisGroup *return_value = new DNAVisGroup(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAVisGroup,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAVisGroup(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAVisGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAVisGroup)
    {
        printf("DNAVisGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAVisGroup * local_this = (DNAVisGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAVisGroup)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAVisGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAVisGroup)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAVisGroup*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASign 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNASign::DNASign(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNASign(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNASign::DNASign(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNASign", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNASign", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNASign *return_value = new DNASign(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASign,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNASign(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASign(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASign)
    {
        printf("DNASign ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASign * local_this = (DNASign *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASign)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASign(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASign)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNASign*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNASign*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASignBaseline 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNASignBaseline::DNASignBaseline(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNASignBaseline(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNASignBaseline::DNASignBaseline(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNASignBaseline", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNASignBaseline", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNASignBaseline *return_value = new DNASignBaseline(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignBaseline,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNASignBaseline(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASignBaseline(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASignBaseline)
    {
        printf("DNASignBaseline ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASignBaseline * local_this = (DNASignBaseline *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASignBaseline)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASignBaseline(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASignBaseline)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNASignBaseline*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNASignBaseline*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASignText 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNASignText::DNASignText(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNASignText(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNASignText::DNASignText(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNASignText", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNASignText", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNASignText *return_value = new DNASignText(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignText,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNASignText(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASignText(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASignText)
    {
        printf("DNASignText ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASignText * local_this = (DNASignText *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASignText)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASignText(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASignText)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNASignText*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNASignText*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASignGraphic 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNASignGraphic::DNASignGraphic(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNASignGraphic(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNASignGraphic::DNASignGraphic(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNASignGraphic", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNASignGraphic", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNASignGraphic *return_value = new DNASignGraphic(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignGraphic,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNASignGraphic(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASignGraphic(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASignGraphic)
    {
        printf("DNASignGraphic ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASignGraphic * local_this = (DNASignGraphic *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASignGraphic)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASignGraphic(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASignGraphic)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNASignGraphic*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNASignGraphic*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAWall 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNAWall::DNAWall(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAWall(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAWall::DNAWall(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAWall", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAWall", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAWall *return_value = new DNAWall(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAWall,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAWall(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAWall(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAWall)
    {
        printf("DNAWall ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAWall * local_this = (DNAWall *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAWall)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAWall(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAWall)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAWall*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAWall*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAWindows 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNAWindows::DNAWindows(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAWindows(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAWindows::DNAWindows(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAWindows", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAWindows", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAWindows *return_value = new DNAWindows(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAWindows,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAWindows(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAWindows(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAWindows)
    {
        printf("DNAWindows ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAWindows * local_this = (DNAWindows *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAWindows)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAWindows(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAWindows)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAWindows*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAStreet 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DNAStreet::DNAStreet(basic_string< char > name)
 *******************************************************************/
int  Dtool_Init_DNAStreet(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAStreet::DNAStreet(basic_string< char > name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAStreet", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DNAStreet", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DNAStreet *return_value = new DNAStreet(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAStreet,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAStreet(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAStreet(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAStreet)
    {
        printf("DNAStreet ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAStreet * local_this = (DNAStreet *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAStreet)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAStreet(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAStreet)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAStreet*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAStreet*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNALoader 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNALoader::load_DNA_file(DNAStorage &store, Filename const &name)
 *******************************************************************/
static PyObject *Dtool_DNALoader_load_DNA_file_160(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALoader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALoader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-basic_string< char > DNALoader::load_DNA_file(DNAStorage &store, Filename const &name)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"store", (char *)"name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:load_DNA_file", key_word_list, &param1, &param2))
            {
                DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "DNALoader.load_DNA_file", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "DNALoader.load_DNA_file", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    basic_string< char > return_value = (local_this)->load_DNA_file(*param1_this, *param2_this);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNALoader.load_DNA_file() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "load_DNA_file(non-const DNALoader this, non-const DNAStorage store, const Filename name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALoader_load_DNA_file_160_comment =
    "C++ Interface:\n"
    "load_DNA_file(non-const DNALoader this, non-const DNAStorage store, const Filename name)\n"
    "\n"
    "";
#else
static const char * Dtool_DNALoader_load_DNA_file_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNALoader::DNALoader(void)
 *******************************************************************/
int  Dtool_Init_DNALoader(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNALoader::DNALoader(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNALoader", key_word_list))
        {
            DNALoader *return_value = new DNALoader();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNALoader,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNALoader()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNALoader(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNALoader)
    {
        printf("DNALoader ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNALoader * local_this = (DNALoader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNALoader)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNALoader(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNALoader)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. DNASuitPoint | DNASuitPoint
//********************************************************************
PyMethodDef Dtool_Methods_DNASuitPoint[]= {
  { "set_index",(PyCFunction ) &Dtool_DNASuitPoint_set_index_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_index_25_comment},
  { "setIndex",(PyCFunction ) &Dtool_DNASuitPoint_set_index_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_index_25_comment},
  { "set_graph_id",(PyCFunction ) &Dtool_DNASuitPoint_set_graph_id_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_graph_id_26_comment},
  { "setGraphId",(PyCFunction ) &Dtool_DNASuitPoint_set_graph_id_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_graph_id_26_comment},
  { "set_landmark_building_index",(PyCFunction ) &Dtool_DNASuitPoint_set_landmark_building_index_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_landmark_building_index_27_comment},
  { "setLandmarkBuildingIndex",(PyCFunction ) &Dtool_DNASuitPoint_set_landmark_building_index_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_landmark_building_index_27_comment},
  { "set_pos",(PyCFunction ) &Dtool_DNASuitPoint_set_pos_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_pos_28_comment},
  { "setPos",(PyCFunction ) &Dtool_DNASuitPoint_set_pos_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_pos_28_comment},
  { "set_point_type",(PyCFunction ) &Dtool_DNASuitPoint_set_point_type_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_point_type_29_comment},
  { "setPointType",(PyCFunction ) &Dtool_DNASuitPoint_set_point_type_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_point_type_29_comment},
  { "get_index",(PyCFunction ) &Dtool_DNASuitPoint_get_index_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_index_30_comment},
  { "getIndex",(PyCFunction ) &Dtool_DNASuitPoint_get_index_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_index_30_comment},
  { "get_graph_id",(PyCFunction ) &Dtool_DNASuitPoint_get_graph_id_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_graph_id_31_comment},
  { "getGraphId",(PyCFunction ) &Dtool_DNASuitPoint_get_graph_id_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_graph_id_31_comment},
  { "get_landmark_building_index",(PyCFunction ) &Dtool_DNASuitPoint_get_landmark_building_index_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_landmark_building_index_32_comment},
  { "getLandmarkBuildingIndex",(PyCFunction ) &Dtool_DNASuitPoint_get_landmark_building_index_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_landmark_building_index_32_comment},
  { "get_pos",(PyCFunction ) &Dtool_DNASuitPoint_get_pos_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_pos_33_comment},
  { "getPos",(PyCFunction ) &Dtool_DNASuitPoint_get_pos_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_pos_33_comment},
  { "get_point_type",(PyCFunction ) &Dtool_DNASuitPoint_get_point_type_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_point_type_34_comment},
  { "getPointType",(PyCFunction ) &Dtool_DNASuitPoint_get_point_type_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_point_type_34_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNASuitPoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DNASuitPoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DNASuitPoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASuitPoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNASuitPoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASuitPoint)");
             printf(" Error In PyType_ReadyDNASuitPoint");
             return;
        }
        Py_INCREF(&Dtool_DNASuitPoint.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNASuitPoint,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASuitPoint.As_PyTypeObject());
        PyModule_AddObject(module, "DNASuitPoint",(PyObject *)&Dtool_DNASuitPoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASuitEdge | DNASuitEdge
//********************************************************************
PyMethodDef Dtool_Methods_DNASuitEdge[]= {
  { "set_start_point",(PyCFunction ) &Dtool_DNASuitEdge_set_start_point_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_set_start_point_38_comment},
  { "setStartPoint",(PyCFunction ) &Dtool_DNASuitEdge_set_start_point_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_set_start_point_38_comment},
  { "set_end_point",(PyCFunction ) &Dtool_DNASuitEdge_set_end_point_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_set_end_point_39_comment},
  { "setEndPoint",(PyCFunction ) &Dtool_DNASuitEdge_set_end_point_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_set_end_point_39_comment},
  { "set_zone_id",(PyCFunction ) &Dtool_DNASuitEdge_set_zone_id_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_set_zone_id_40_comment},
  { "setZoneId",(PyCFunction ) &Dtool_DNASuitEdge_set_zone_id_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_set_zone_id_40_comment},
  { "get_start_point",(PyCFunction ) &Dtool_DNASuitEdge_get_start_point_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_get_start_point_41_comment},
  { "getStartPoint",(PyCFunction ) &Dtool_DNASuitEdge_get_start_point_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_get_start_point_41_comment},
  { "get_end_point",(PyCFunction ) &Dtool_DNASuitEdge_get_end_point_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_get_end_point_42_comment},
  { "getEndPoint",(PyCFunction ) &Dtool_DNASuitEdge_get_end_point_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_get_end_point_42_comment},
  { "get_zone_id",(PyCFunction ) &Dtool_DNASuitEdge_get_zone_id_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_get_zone_id_43_comment},
  { "getZoneId",(PyCFunction ) &Dtool_DNASuitEdge_get_zone_id_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_get_zone_id_43_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNASuitEdge(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DNASuitEdge.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DNASuitEdge.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASuitEdge.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASuitEdge.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNASuitEdge.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASuitEdge)");
             printf(" Error In PyType_ReadyDNASuitEdge");
             return;
        }
        Py_INCREF(&Dtool_DNASuitEdge.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNASuitEdge,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASuitEdge.As_PyTypeObject());
        PyModule_AddObject(module, "DNASuitEdge",(PyObject *)&Dtool_DNASuitEdge.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNABattleCell | DNABattleCell
//********************************************************************
PyMethodDef Dtool_Methods_DNABattleCell[]= {
  { "set_width",(PyCFunction ) &Dtool_DNABattleCell_set_width_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_set_width_47_comment},
  { "setWidth",(PyCFunction ) &Dtool_DNABattleCell_set_width_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_set_width_47_comment},
  { "set_height",(PyCFunction ) &Dtool_DNABattleCell_set_height_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_set_height_48_comment},
  { "setHeight",(PyCFunction ) &Dtool_DNABattleCell_set_height_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_set_height_48_comment},
  { "set_width_height",(PyCFunction ) &Dtool_DNABattleCell_set_width_height_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_set_width_height_49_comment},
  { "setWidthHeight",(PyCFunction ) &Dtool_DNABattleCell_set_width_height_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_set_width_height_49_comment},
  { "set_pos",(PyCFunction ) &Dtool_DNABattleCell_set_pos_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_set_pos_50_comment},
  { "setPos",(PyCFunction ) &Dtool_DNABattleCell_set_pos_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_set_pos_50_comment},
  { "get_width",(PyCFunction ) &Dtool_DNABattleCell_get_width_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_get_width_51_comment},
  { "getWidth",(PyCFunction ) &Dtool_DNABattleCell_get_width_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_get_width_51_comment},
  { "get_height",(PyCFunction ) &Dtool_DNABattleCell_get_height_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_get_height_52_comment},
  { "getHeight",(PyCFunction ) &Dtool_DNABattleCell_get_height_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_get_height_52_comment},
  { "get_pos",(PyCFunction ) &Dtool_DNABattleCell_get_pos_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_get_pos_53_comment},
  { "getPos",(PyCFunction ) &Dtool_DNABattleCell_get_pos_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_get_pos_53_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNABattleCell(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DNABattleCell.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DNABattleCell.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNABattleCell.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNABattleCell.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNABattleCell.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNABattleCell)");
             printf(" Error In PyType_ReadyDNABattleCell");
             return;
        }
        Py_INCREF(&Dtool_DNABattleCell.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNABattleCell,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNABattleCell.As_PyTypeObject());
        PyModule_AddObject(module, "DNABattleCell",(PyObject *)&Dtool_DNABattleCell.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAStorage | DNAStorage
//********************************************************************
PyMethodDef Dtool_Methods_DNAStorage[]= {
  { "store_catalog_code",(PyCFunction ) &Dtool_DNAStorage_store_catalog_code_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_catalog_code_57_comment},
  { "storeCatalogCode",(PyCFunction ) &Dtool_DNAStorage_store_catalog_code_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_catalog_code_57_comment},
  { "get_catalog_code",(PyCFunction ) &Dtool_DNAStorage_get_catalog_code_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_catalog_code_58_comment},
  { "getCatalogCode",(PyCFunction ) &Dtool_DNAStorage_get_catalog_code_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_catalog_code_58_comment},
  { "get_num_catalog_codes",(PyCFunction ) &Dtool_DNAStorage_get_num_catalog_codes_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_catalog_codes_59_comment},
  { "getNumCatalogCodes",(PyCFunction ) &Dtool_DNAStorage_get_num_catalog_codes_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_catalog_codes_59_comment},
  { "store_texture",(PyCFunction ) &Dtool_DNAStorage_store_texture_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_texture_60_comment},
  { "storeTexture",(PyCFunction ) &Dtool_DNAStorage_store_texture_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_texture_60_comment},
  { "find_texture",(PyCFunction ) &Dtool_DNAStorage_find_texture_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_texture_61_comment},
  { "findTexture",(PyCFunction ) &Dtool_DNAStorage_find_texture_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_texture_61_comment},
  { "reset_textures",(PyCFunction ) &Dtool_DNAStorage_reset_textures_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_textures_62_comment},
  { "resetTextures",(PyCFunction ) &Dtool_DNAStorage_reset_textures_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_textures_62_comment},
  { "store_font",(PyCFunction ) &Dtool_DNAStorage_store_font_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_font_63_comment},
  { "storeFont",(PyCFunction ) &Dtool_DNAStorage_store_font_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_font_63_comment},
  { "find_font",(PyCFunction ) &Dtool_DNAStorage_find_font_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_font_64_comment},
  { "findFont",(PyCFunction ) &Dtool_DNAStorage_find_font_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_font_64_comment},
  { "reset_fonts",(PyCFunction ) &Dtool_DNAStorage_reset_fonts_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_fonts_65_comment},
  { "resetFonts",(PyCFunction ) &Dtool_DNAStorage_reset_fonts_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_fonts_65_comment},
  { "store_node",(PyCFunction ) &Dtool_DNAStorage_store_node_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_node_66_comment},
  { "storeNode",(PyCFunction ) &Dtool_DNAStorage_store_node_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_node_66_comment},
  { "reset_nodes",(PyCFunction ) &Dtool_DNAStorage_reset_nodes_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_nodes_67_comment},
  { "resetNodes",(PyCFunction ) &Dtool_DNAStorage_reset_nodes_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_nodes_67_comment},
  { "store_hood_node",(PyCFunction ) &Dtool_DNAStorage_store_hood_node_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_hood_node_68_comment},
  { "storeHoodNode",(PyCFunction ) &Dtool_DNAStorage_store_hood_node_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_hood_node_68_comment},
  { "reset_hood_nodes",(PyCFunction ) &Dtool_DNAStorage_reset_hood_nodes_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_hood_nodes_69_comment},
  { "resetHoodNodes",(PyCFunction ) &Dtool_DNAStorage_reset_hood_nodes_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_hood_nodes_69_comment},
  { "store_place_node",(PyCFunction ) &Dtool_DNAStorage_store_place_node_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_place_node_70_comment},
  { "storePlaceNode",(PyCFunction ) &Dtool_DNAStorage_store_place_node_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_place_node_70_comment},
  { "reset_place_nodes",(PyCFunction ) &Dtool_DNAStorage_reset_place_nodes_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_place_nodes_71_comment},
  { "resetPlaceNodes",(PyCFunction ) &Dtool_DNAStorage_reset_place_nodes_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_place_nodes_71_comment},
  { "find_node",(PyCFunction ) &Dtool_DNAStorage_find_node_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_node_72_comment},
  { "findNode",(PyCFunction ) &Dtool_DNAStorage_find_node_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_node_72_comment},
  { "get_suit_point_at_index",(PyCFunction ) &Dtool_DNAStorage_get_suit_point_at_index_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_suit_point_at_index_73_comment},
  { "getSuitPointAtIndex",(PyCFunction ) &Dtool_DNAStorage_get_suit_point_at_index_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_suit_point_at_index_73_comment},
  { "reset_suit_points",(PyCFunction ) &Dtool_DNAStorage_reset_suit_points_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_suit_points_74_comment},
  { "resetSuitPoints",(PyCFunction ) &Dtool_DNAStorage_reset_suit_points_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_suit_points_74_comment},
  { "get_block_building_type",(PyCFunction ) &Dtool_DNAStorage_get_block_building_type_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_block_building_type_75_comment},
  { "getBlockBuildingType",(PyCFunction ) &Dtool_DNAStorage_get_block_building_type_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_block_building_type_75_comment},
  { "get_title_from_block_number",(PyCFunction ) &Dtool_DNAStorage_get_title_from_block_number_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_title_from_block_number_76_comment},
  { "getTitleFromBlockNumber",(PyCFunction ) &Dtool_DNAStorage_get_title_from_block_number_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_title_from_block_number_76_comment},
  { "get_zone_from_block_number",(PyCFunction ) &Dtool_DNAStorage_get_zone_from_block_number_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_zone_from_block_number_77_comment},
  { "getZoneFromBlockNumber",(PyCFunction ) &Dtool_DNAStorage_get_zone_from_block_number_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_zone_from_block_number_77_comment},
  { "get_num_block_numbers",(PyCFunction ) &Dtool_DNAStorage_get_num_block_numbers_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_block_numbers_78_comment},
  { "getNumBlockNumbers",(PyCFunction ) &Dtool_DNAStorage_get_num_block_numbers_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_block_numbers_78_comment},
  { "get_suit_edge",(PyCFunction ) &Dtool_DNAStorage_get_suit_edge_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_suit_edge_79_comment},
  { "getSuitEdge",(PyCFunction ) &Dtool_DNAStorage_get_suit_edge_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_suit_edge_79_comment},
  { "reset_battle_cells",(PyCFunction ) &Dtool_DNAStorage_reset_battle_cells_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_battle_cells_80_comment},
  { "resetBattleCells",(PyCFunction ) &Dtool_DNAStorage_reset_battle_cells_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_battle_cells_80_comment},
  { "get_battle_cell",(PyCFunction ) &Dtool_DNAStorage_get_battle_cell_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_battle_cell_81_comment},
  { "getBattleCell",(PyCFunction ) &Dtool_DNAStorage_get_battle_cell_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_battle_cell_81_comment},
  { "get_num_battle_cells",(PyCFunction ) &Dtool_DNAStorage_get_num_battle_cells_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_battle_cells_82_comment},
  { "getNumBattleCells",(PyCFunction ) &Dtool_DNAStorage_get_num_battle_cells_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_battle_cells_82_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAStorage(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DNAStorage.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DNAStorage.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAStorage.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAStorage.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAStorage.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAStorage)");
             printf(" Error In PyType_ReadyDNAStorage");
             return;
        }
        Py_INCREF(&Dtool_DNAStorage.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAStorage,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAStorage.As_PyTypeObject());
        PyModule_AddObject(module, "DNAStorage",(PyObject *)&Dtool_DNAStorage.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAGroup | DNAGroup
//********************************************************************
PyMethodDef Dtool_Methods_DNAGroup[]= {
  { "get_vis_group",(PyCFunction ) &Dtool_DNAGroup_get_vis_group_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_vis_group_86_comment},
  { "getVisGroup",(PyCFunction ) &Dtool_DNAGroup_get_vis_group_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_vis_group_86_comment},
  { "add",(PyCFunction ) &Dtool_DNAGroup_add_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_add_87_comment},
  { "at",(PyCFunction ) &Dtool_DNAGroup_at_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_at_88_comment},
  { "get_num_children",(PyCFunction ) &Dtool_DNAGroup_get_num_children_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_num_children_89_comment},
  { "getNumChildren",(PyCFunction ) &Dtool_DNAGroup_get_num_children_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_num_children_89_comment},
  { "set_parent",(PyCFunction ) &Dtool_DNAGroup_set_parent_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_set_parent_90_comment},
  { "setParent",(PyCFunction ) &Dtool_DNAGroup_set_parent_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_set_parent_90_comment},
  { "clear_parent",(PyCFunction ) &Dtool_DNAGroup_clear_parent_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_clear_parent_91_comment},
  { "clearParent",(PyCFunction ) &Dtool_DNAGroup_clear_parent_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_clear_parent_91_comment},
  { "get_parent",(PyCFunction ) &Dtool_DNAGroup_get_parent_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_parent_92_comment},
  { "getParent",(PyCFunction ) &Dtool_DNAGroup_get_parent_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_parent_92_comment},
  { "get_name",(PyCFunction ) &Dtool_DNAGroup_get_name_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_name_93_comment},
  { "getName",(PyCFunction ) &Dtool_DNAGroup_get_name_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_name_93_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DNAGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DNAGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAGroup.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAGroup)");
             printf(" Error In PyType_ReadyDNAGroup");
             return;
        }
        Py_INCREF(&Dtool_DNAGroup.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAGroup,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAGroup.As_PyTypeObject());
        PyModule_AddObject(module, "DNAGroup",(PyObject *)&Dtool_DNAGroup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNANode | DNANode
//********************************************************************
PyMethodDef Dtool_Methods_DNANode[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNANode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNANode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNANode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNANode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNANode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNANode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNANode)");
             printf(" Error In PyType_ReadyDNANode");
             return;
        }
        Py_INCREF(&Dtool_DNANode.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNANode,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNANode.As_PyTypeObject());
        PyModule_AddObject(module, "DNANode",(PyObject *)&Dtool_DNANode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNALandmarkBuilding | DNALandmarkBuilding
//********************************************************************
PyMethodDef Dtool_Methods_DNALandmarkBuilding[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNALandmarkBuilding(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNALandmarkBuilding.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNALandmarkBuilding)");
             printf(" Error In PyType_ReadyDNALandmarkBuilding");
             return;
        }
        Py_INCREF(&Dtool_DNALandmarkBuilding.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNALandmarkBuilding,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNALandmarkBuilding.As_PyTypeObject());
        PyModule_AddObject(module, "DNALandmarkBuilding",(PyObject *)&Dtool_DNALandmarkBuilding.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAAnimBuilding | DNAAnimBuilding
//********************************************************************
PyMethodDef Dtool_Methods_DNAAnimBuilding[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAAnimBuilding(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNALandmarkBuilding._Dtool_ClassInit(NULL);
        Dtool_DNAAnimBuilding.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNALandmarkBuilding.As_PyTypeObject());
        Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAAnimBuilding.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAAnimBuilding)");
             printf(" Error In PyType_ReadyDNAAnimBuilding");
             return;
        }
        Py_INCREF(&Dtool_DNAAnimBuilding.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAAnimBuilding,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAAnimBuilding.As_PyTypeObject());
        PyModule_AddObject(module, "DNAAnimBuilding",(PyObject *)&Dtool_DNAAnimBuilding.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAProp | DNAProp
//********************************************************************
PyMethodDef Dtool_Methods_DNAProp[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAProp(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNAProp.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNAProp.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAProp.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAProp.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAProp.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAProp)");
             printf(" Error In PyType_ReadyDNAProp");
             return;
        }
        Py_INCREF(&Dtool_DNAProp.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAProp,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAProp.As_PyTypeObject());
        PyModule_AddObject(module, "DNAProp",(PyObject *)&Dtool_DNAProp.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAAnimProp | DNAAnimProp
//********************************************************************
PyMethodDef Dtool_Methods_DNAAnimProp[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAAnimProp(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNAProp._Dtool_ClassInit(NULL);
        Dtool_DNAAnimProp.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAProp.As_PyTypeObject());
        Dtool_DNAAnimProp.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAAnimProp.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAAnimProp.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAAnimProp.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAAnimProp)");
             printf(" Error In PyType_ReadyDNAAnimProp");
             return;
        }
        Py_INCREF(&Dtool_DNAAnimProp.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAAnimProp,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAAnimProp.As_PyTypeObject());
        PyModule_AddObject(module, "DNAAnimProp",(PyObject *)&Dtool_DNAAnimProp.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNACornice | DNACornice
//********************************************************************
PyMethodDef Dtool_Methods_DNACornice[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNACornice(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNACornice.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNACornice.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNACornice.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNACornice.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNACornice.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNACornice)");
             printf(" Error In PyType_ReadyDNACornice");
             return;
        }
        Py_INCREF(&Dtool_DNACornice.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNACornice,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNACornice.As_PyTypeObject());
        PyModule_AddObject(module, "DNACornice",(PyObject *)&Dtool_DNACornice.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNADoor | DNADoor
//********************************************************************
PyMethodDef Dtool_Methods_DNADoor[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNADoor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNADoor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNADoor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNADoor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNADoor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNADoor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNADoor)");
             printf(" Error In PyType_ReadyDNADoor");
             return;
        }
        Py_INCREF(&Dtool_DNADoor.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNADoor,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNADoor.As_PyTypeObject());
        PyModule_AddObject(module, "DNADoor",(PyObject *)&Dtool_DNADoor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAFlatBuilding | DNAFlatBuilding
//********************************************************************
PyMethodDef Dtool_Methods_DNAFlatBuilding[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAFlatBuilding(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNAFlatBuilding.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAFlatBuilding.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAFlatBuilding)");
             printf(" Error In PyType_ReadyDNAFlatBuilding");
             return;
        }
        Py_INCREF(&Dtool_DNAFlatBuilding.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAFlatBuilding,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAFlatBuilding.As_PyTypeObject());
        PyModule_AddObject(module, "DNAFlatBuilding",(PyObject *)&Dtool_DNAFlatBuilding.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAFlatDoor | DNAFlatDoor
//********************************************************************
PyMethodDef Dtool_Methods_DNAFlatDoor[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAFlatDoor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNADoor._Dtool_ClassInit(NULL);
        Dtool_DNAFlatDoor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNADoor.As_PyTypeObject());
        Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAFlatDoor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAFlatDoor)");
             printf(" Error In PyType_ReadyDNAFlatDoor");
             return;
        }
        Py_INCREF(&Dtool_DNAFlatDoor.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAFlatDoor,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAFlatDoor.As_PyTypeObject());
        PyModule_AddObject(module, "DNAFlatDoor",(PyObject *)&Dtool_DNAFlatDoor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAInteractiveProp | DNAInteractiveProp
//********************************************************************
PyMethodDef Dtool_Methods_DNAInteractiveProp[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAInteractiveProp(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNAAnimProp._Dtool_ClassInit(NULL);
        Dtool_DNAInteractiveProp.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAAnimProp.As_PyTypeObject());
        Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAInteractiveProp.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAInteractiveProp)");
             printf(" Error In PyType_ReadyDNAInteractiveProp");
             return;
        }
        Py_INCREF(&Dtool_DNAInteractiveProp.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAInteractiveProp,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAInteractiveProp.As_PyTypeObject());
        PyModule_AddObject(module, "DNAInteractiveProp",(PyObject *)&Dtool_DNAInteractiveProp.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAVisGroup | DNAVisGroup
//********************************************************************
PyMethodDef Dtool_Methods_DNAVisGroup[]= {
  { "add_suit_edge",(PyCFunction ) &Dtool_DNAVisGroup_add_suit_edge_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_add_suit_edge_127_comment},
  { "addSuitEdge",(PyCFunction ) &Dtool_DNAVisGroup_add_suit_edge_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_add_suit_edge_127_comment},
  { "add_battle_cell",(PyCFunction ) &Dtool_DNAVisGroup_add_battle_cell_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_add_battle_cell_128_comment},
  { "addBattleCell",(PyCFunction ) &Dtool_DNAVisGroup_add_battle_cell_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_add_battle_cell_128_comment},
  { "add_visible",(PyCFunction ) &Dtool_DNAVisGroup_add_visible_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_add_visible_129_comment},
  { "addVisible",(PyCFunction ) &Dtool_DNAVisGroup_add_visible_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_add_visible_129_comment},
  { "get_num_battle_cells",(PyCFunction ) &Dtool_DNAVisGroup_get_num_battle_cells_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_num_battle_cells_130_comment},
  { "getNumBattleCells",(PyCFunction ) &Dtool_DNAVisGroup_get_num_battle_cells_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_num_battle_cells_130_comment},
  { "get_num_suit_edges",(PyCFunction ) &Dtool_DNAVisGroup_get_num_suit_edges_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_num_suit_edges_131_comment},
  { "getNumSuitEdges",(PyCFunction ) &Dtool_DNAVisGroup_get_num_suit_edges_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_num_suit_edges_131_comment},
  { "get_num_visibles",(PyCFunction ) &Dtool_DNAVisGroup_get_num_visibles_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_num_visibles_132_comment},
  { "getNumVisibles",(PyCFunction ) &Dtool_DNAVisGroup_get_num_visibles_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_num_visibles_132_comment},
  { "get_battle_cell",(PyCFunction ) &Dtool_DNAVisGroup_get_battle_cell_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_battle_cell_133_comment},
  { "getBattleCell",(PyCFunction ) &Dtool_DNAVisGroup_get_battle_cell_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_battle_cell_133_comment},
  { "get_suit_edge",(PyCFunction ) &Dtool_DNAVisGroup_get_suit_edge_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_suit_edge_134_comment},
  { "getSuitEdge",(PyCFunction ) &Dtool_DNAVisGroup_get_suit_edge_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_suit_edge_134_comment},
  { "get_visible_name",(PyCFunction ) &Dtool_DNAVisGroup_get_visible_name_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_visible_name_135_comment},
  { "getVisibleName",(PyCFunction ) &Dtool_DNAVisGroup_get_visible_name_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_visible_name_135_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAVisGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNAVisGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNAVisGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAVisGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAVisGroup.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAVisGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAVisGroup)");
             printf(" Error In PyType_ReadyDNAVisGroup");
             return;
        }
        Py_INCREF(&Dtool_DNAVisGroup.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAVisGroup,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAVisGroup.As_PyTypeObject());
        PyModule_AddObject(module, "DNAVisGroup",(PyObject *)&Dtool_DNAVisGroup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASign | DNASign
//********************************************************************
PyMethodDef Dtool_Methods_DNASign[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNASign(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNASign.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNASign.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASign.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASign.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNASign.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASign)");
             printf(" Error In PyType_ReadyDNASign");
             return;
        }
        Py_INCREF(&Dtool_DNASign.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNASign,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASign.As_PyTypeObject());
        PyModule_AddObject(module, "DNASign",(PyObject *)&Dtool_DNASign.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASignBaseline | DNASignBaseline
//********************************************************************
PyMethodDef Dtool_Methods_DNASignBaseline[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNASignBaseline(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNASignBaseline.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNASignBaseline.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASignBaseline.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASignBaseline.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNASignBaseline.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASignBaseline)");
             printf(" Error In PyType_ReadyDNASignBaseline");
             return;
        }
        Py_INCREF(&Dtool_DNASignBaseline.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNASignBaseline,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASignBaseline.As_PyTypeObject());
        PyModule_AddObject(module, "DNASignBaseline",(PyObject *)&Dtool_DNASignBaseline.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASignText | DNASignText
//********************************************************************
PyMethodDef Dtool_Methods_DNASignText[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNASignText(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNASignText.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNASignText.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASignText.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASignText.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNASignText.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASignText)");
             printf(" Error In PyType_ReadyDNASignText");
             return;
        }
        Py_INCREF(&Dtool_DNASignText.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNASignText,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASignText.As_PyTypeObject());
        PyModule_AddObject(module, "DNASignText",(PyObject *)&Dtool_DNASignText.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASignGraphic | DNASignGraphic
//********************************************************************
PyMethodDef Dtool_Methods_DNASignGraphic[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNASignGraphic(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNASignGraphic.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNASignGraphic.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASignGraphic.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASignGraphic.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNASignGraphic.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASignGraphic)");
             printf(" Error In PyType_ReadyDNASignGraphic");
             return;
        }
        Py_INCREF(&Dtool_DNASignGraphic.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNASignGraphic,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASignGraphic.As_PyTypeObject());
        PyModule_AddObject(module, "DNASignGraphic",(PyObject *)&Dtool_DNASignGraphic.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAWall | DNAWall
//********************************************************************
PyMethodDef Dtool_Methods_DNAWall[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAWall(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNAWall.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNAWall.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAWall.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAWall.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAWall.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAWall)");
             printf(" Error In PyType_ReadyDNAWall");
             return;
        }
        Py_INCREF(&Dtool_DNAWall.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAWall,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAWall.As_PyTypeObject());
        PyModule_AddObject(module, "DNAWall",(PyObject *)&Dtool_DNAWall.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAWindows | DNAWindows
//********************************************************************
PyMethodDef Dtool_Methods_DNAWindows[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAWindows(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNAWindows.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNAWindows.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAWindows.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAWindows.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAWindows.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAWindows)");
             printf(" Error In PyType_ReadyDNAWindows");
             return;
        }
        Py_INCREF(&Dtool_DNAWindows.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAWindows,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAWindows.As_PyTypeObject());
        PyModule_AddObject(module, "DNAWindows",(PyObject *)&Dtool_DNAWindows.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAStreet | DNAStreet
//********************************************************************
PyMethodDef Dtool_Methods_DNAStreet[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAStreet(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNAStreet.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNAStreet.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAStreet.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAStreet.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAStreet.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAStreet)");
             printf(" Error In PyType_ReadyDNAStreet");
             return;
        }
        Py_INCREF(&Dtool_DNAStreet.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNAStreet,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAStreet.As_PyTypeObject());
        PyModule_AddObject(module, "DNAStreet",(PyObject *)&Dtool_DNAStreet.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNALoader | DNALoader
//********************************************************************
PyMethodDef Dtool_Methods_DNALoader[]= {
  { "load_DNA_file",(PyCFunction ) &Dtool_DNALoader_load_DNA_file_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALoader_load_DNA_file_160_comment},
  { "loadDNAFile",(PyCFunction ) &Dtool_DNALoader_load_DNA_file_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALoader_load_DNA_file_160_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNALoader(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DNALoader.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DNALoader.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNALoader.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNALoader.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNALoader.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNALoader)");
             printf(" Error In PyType_ReadyDNALoader");
             return;
        }
        Py_INCREF(&Dtool_DNALoader.As_PyTypeObject());
        RegisterRuntimeClass(&Dtool_DNALoader,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNALoader.As_PyTypeObject());
        PyModule_AddObject(module, "DNALoader",(PyObject *)&Dtool_DNALoader.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..DNASuitPoint
//********************************************************************
   Dtool_PyModuleClassInit_DNASuitPoint(module);
//********************************************************************
//*** Module Init Updcall ..DNASuitEdge
//********************************************************************
   Dtool_PyModuleClassInit_DNASuitEdge(module);
//********************************************************************
//*** Module Init Updcall ..DNABattleCell
//********************************************************************
   Dtool_PyModuleClassInit_DNABattleCell(module);
//********************************************************************
//*** Module Init Updcall ..DNAStorage
//********************************************************************
   Dtool_PyModuleClassInit_DNAStorage(module);
//********************************************************************
//*** Module Init Updcall ..DNAGroup
//********************************************************************
   Dtool_PyModuleClassInit_DNAGroup(module);
//********************************************************************
//*** Module Init Updcall ..DNANode
//********************************************************************
   Dtool_PyModuleClassInit_DNANode(module);
//********************************************************************
//*** Module Init Updcall ..DNALandmarkBuilding
//********************************************************************
   Dtool_PyModuleClassInit_DNALandmarkBuilding(module);
//********************************************************************
//*** Module Init Updcall ..DNAAnimBuilding
//********************************************************************
   Dtool_PyModuleClassInit_DNAAnimBuilding(module);
//********************************************************************
//*** Module Init Updcall ..DNAProp
//********************************************************************
   Dtool_PyModuleClassInit_DNAProp(module);
//********************************************************************
//*** Module Init Updcall ..DNAAnimProp
//********************************************************************
   Dtool_PyModuleClassInit_DNAAnimProp(module);
//********************************************************************
//*** Module Init Updcall ..DNACornice
//********************************************************************
   Dtool_PyModuleClassInit_DNACornice(module);
//********************************************************************
//*** Module Init Updcall ..DNADoor
//********************************************************************
   Dtool_PyModuleClassInit_DNADoor(module);
//********************************************************************
//*** Module Init Updcall ..DNAFlatBuilding
//********************************************************************
   Dtool_PyModuleClassInit_DNAFlatBuilding(module);
//********************************************************************
//*** Module Init Updcall ..DNAFlatDoor
//********************************************************************
   Dtool_PyModuleClassInit_DNAFlatDoor(module);
//********************************************************************
//*** Module Init Updcall ..DNAInteractiveProp
//********************************************************************
   Dtool_PyModuleClassInit_DNAInteractiveProp(module);
//********************************************************************
//*** Module Init Updcall ..DNAVisGroup
//********************************************************************
   Dtool_PyModuleClassInit_DNAVisGroup(module);
//********************************************************************
//*** Module Init Updcall ..DNASign
//********************************************************************
   Dtool_PyModuleClassInit_DNASign(module);
//********************************************************************
//*** Module Init Updcall ..DNASignBaseline
//********************************************************************
   Dtool_PyModuleClassInit_DNASignBaseline(module);
//********************************************************************
//*** Module Init Updcall ..DNASignText
//********************************************************************
   Dtool_PyModuleClassInit_DNASignText(module);
//********************************************************************
//*** Module Init Updcall ..DNASignGraphic
//********************************************************************
   Dtool_PyModuleClassInit_DNASignGraphic(module);
//********************************************************************
//*** Module Init Updcall ..DNAWall
//********************************************************************
   Dtool_PyModuleClassInit_DNAWall(module);
//********************************************************************
//*** Module Init Updcall ..DNAWindows
//********************************************************************
   Dtool_PyModuleClassInit_DNAWindows(module);
//********************************************************************
//*** Module Init Updcall ..DNAStreet
//********************************************************************
   Dtool_PyModuleClassInit_DNAStreet(module);
//********************************************************************
//*** Module Init Updcall ..DNALoader
//********************************************************************
   Dtool_PyModuleClassInit_DNALoader(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' pointer ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to add items into a tp_dict"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libpandadna_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1401987466,  /* file_identifier */
  "libpandadna",  /* library_name */
  "gPHL",  /* library_hash_name */
  "libpandadna",  /* module_name */
  "libpandadna.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  304  /* next_index */
};

Configure(_in_configure_libpandadna);
ConfigureFn(_in_configure_libpandadna) {
  interrogate_request_module(&_in_module_def);
}

