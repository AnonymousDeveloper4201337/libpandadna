/*
 * This file generated by:
 * C:\Panda3D-ttn\bin\interrogate.exe -D__inline -DCPPPARSER -DP3_INTERROGATE=1 -D__cplusplus -fnames -string -refcount -assert -S C:\Panda3D-ttn\include\parser-inc -S C:\Panda3D-ttn\include -I C:\Panda3D-ttn\include -IC:/Users/Usuario/workspace/libpandadna/src\suit -IC:/Users/Usuario/workspace/libpandadna/src\base -IC:/Users/Usuario/workspace/libpandadna/src\components -srcdir C:/Users/Usuario/workspace/libpandadna/src\components -oc C:/Users/Usuario/workspace/libpandadna/src\components_igate.cxx -od C:/Users/Usuario/workspace/libpandadna/src\components.in -python-native -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -module libpandadna -library components -Dvolatile= DNAGroup.h DNAVisGroup.h DNANode.h DNAProp.h DNASign.h DNASignBaseline.h DNASignGraphic.h DNAFlatBuilding.h DNAWall.h DNAWindows.h DNACornice.h DNALandmarkBuilding.h DNAAnimProp.h DNAInteractiveProp.h DNAAnimBuilding.h DNADoor.h DNAFlatDoor.h DNAStreet.h DNABattleCell.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_components
#include "py_panda.h"
#include "extension.h"

#include "DNAAnimBuilding.h"
#include "DNAAnimProp.h"
#include "DNABattleCell.h"
#include "DNACornice.h"
#include "DNADoor.h"
#include "DNAFlatBuilding.h"
#include "DNAFlatDoor.h"
#include "DNAGroup.h"
#include "DNAInteractiveProp.h"
#include "DNALandmarkBuilding.h"
#include "DNANode.h"
#include "DNAProp.h"
#include "DNASign.h"
#include "DNASignBaseline.h"
#include "DNASignGraphic.h"
#include "DNAStorage.h"
#include "DNAStreet.h"
#include "DNASuitEdge.h"
#include "DNAVisGroup.h"
#include "DNAWall.h"
#include "DNAWindows.h"
#include <datagramIterator.h>
#include "dnabase.h"
#include <luse.h>
#include <nodePath.h>
#include <typedObject.h>

#undef _POSIX_C_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif

//********************************************************************
//*** prototypes for .. Global
//********************************************************************
//********************************************************************
//*** prototypes for .. DNAGroup
//********************************************************************
typedef DNAGroup DNAGroup_localtype;
Define_Module_Class(libpandadna, DNAGroup, DNAGroup_localtype, DNAGroup);

//********************************************************************
//*** prototypes for .. DNABattleCell
//********************************************************************
typedef DNABattleCell DNABattleCell_localtype;
Define_Module_Class(libpandadna, DNABattleCell, DNABattleCell_localtype, DNABattleCell);

//********************************************************************
//*** prototypes for .. DNAVisGroup
//********************************************************************
typedef DNAVisGroup DNAVisGroup_localtype;
Define_Module_Class(libpandadna, DNAVisGroup, DNAVisGroup_localtype, DNAVisGroup);

//********************************************************************
//*** prototypes for .. DNANode
//********************************************************************
typedef DNANode DNANode_localtype;
Define_Module_Class(libpandadna, DNANode, DNANode_localtype, DNANode);

//********************************************************************
//*** prototypes for .. DNAProp
//********************************************************************
typedef DNAProp DNAProp_localtype;
Define_Module_Class(libpandadna, DNAProp, DNAProp_localtype, DNAProp);

//********************************************************************
//*** prototypes for .. DNASign
//********************************************************************
typedef DNASign DNASign_localtype;
Define_Module_Class(libpandadna, DNASign, DNASign_localtype, DNASign);

//********************************************************************
//*** prototypes for .. DNASignBaseline
//********************************************************************
typedef DNASignBaseline DNASignBaseline_localtype;
Define_Module_Class(libpandadna, DNASignBaseline, DNASignBaseline_localtype, DNASignBaseline);

//********************************************************************
//*** prototypes for .. DNASignGraphic
//********************************************************************
typedef DNASignGraphic DNASignGraphic_localtype;
Define_Module_Class(libpandadna, DNASignGraphic, DNASignGraphic_localtype, DNASignGraphic);

//********************************************************************
//*** prototypes for .. DNAFlatBuilding
//********************************************************************
typedef DNAFlatBuilding DNAFlatBuilding_localtype;
Define_Module_Class(libpandadna, DNAFlatBuilding, DNAFlatBuilding_localtype, DNAFlatBuilding);

//********************************************************************
//*** prototypes for .. DNAWall
//********************************************************************
typedef DNAWall DNAWall_localtype;
Define_Module_Class(libpandadna, DNAWall, DNAWall_localtype, DNAWall);

//********************************************************************
//*** prototypes for .. DNAWindows
//********************************************************************
typedef DNAWindows DNAWindows_localtype;
Define_Module_Class(libpandadna, DNAWindows, DNAWindows_localtype, DNAWindows);

//********************************************************************
//*** prototypes for .. DNACornice
//********************************************************************
typedef DNACornice DNACornice_localtype;
Define_Module_Class(libpandadna, DNACornice, DNACornice_localtype, DNACornice);

//********************************************************************
//*** prototypes for .. DNALandmarkBuilding
//********************************************************************
typedef DNALandmarkBuilding DNALandmarkBuilding_localtype;
Define_Module_Class(libpandadna, DNALandmarkBuilding, DNALandmarkBuilding_localtype, DNALandmarkBuilding);

//********************************************************************
//*** prototypes for .. DNAAnimProp
//********************************************************************
typedef DNAAnimProp DNAAnimProp_localtype;
Define_Module_Class(libpandadna, DNAAnimProp, DNAAnimProp_localtype, DNAAnimProp);

//********************************************************************
//*** prototypes for .. DNAInteractiveProp
//********************************************************************
typedef DNAInteractiveProp DNAInteractiveProp_localtype;
Define_Module_Class(libpandadna, DNAInteractiveProp, DNAInteractiveProp_localtype, DNAInteractiveProp);

//********************************************************************
//*** prototypes for .. DNAAnimBuilding
//********************************************************************
typedef DNAAnimBuilding DNAAnimBuilding_localtype;
Define_Module_Class(libpandadna, DNAAnimBuilding, DNAAnimBuilding_localtype, DNAAnimBuilding);

//********************************************************************
//*** prototypes for .. DNADoor
//********************************************************************
typedef DNADoor DNADoor_localtype;
Define_Module_Class(libpandadna, DNADoor, DNADoor_localtype, DNADoor);

//********************************************************************
//*** prototypes for .. DNAFlatDoor
//********************************************************************
typedef DNAFlatDoor DNAFlatDoor_localtype;
Define_Module_Class(libpandadna, DNAFlatDoor, DNAFlatDoor_localtype, DNAFlatDoor);

//********************************************************************
//*** prototypes for .. DNAStreet
//********************************************************************
typedef DNAStreet DNAStreet_localtype;
Define_Module_Class(libpandadna, DNAStreet, DNAStreet_localtype, DNAStreet);

//********************************************************************
//*** prototypes for .. External Objects
//********************************************************************
IMPORT_THIS struct Dtool_PyTypedObject Dtool_DNAStorage;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_DNASuitEdge;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_TypedObject;

//********************************************************************
//*** Functions for .. Global
//********************************************************************
//********************************************************************
//*** Functions for .. DNAGroup
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNAGroup::add(DNAGroup *group)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_add_4(PyObject *self, PyObject *arg) {
  DNAGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void DNAGroup::add(DNAGroup *group)
        DNAGroup *arg_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNAGroup, 1, "DNAGroup.add", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->add(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAGroup.add() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "add(DNAGroup this, DNAGroup group)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_add_4_comment =
  "C++ Interface:\n"
  "add(DNAGroup this, DNAGroup group)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_add_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAGroup *DNAGroup::at(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_at_5(PyObject *self, PyObject *arg) {
  DNAGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-DNAGroup *DNAGroup::at(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      DNAGroup *return_value = (local_this)->at(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNAGroup, false, false, (return_value)->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAGroup.at() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "at(DNAGroup this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_at_5_comment =
  "C++ Interface:\n"
  "at(DNAGroup this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_at_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAGroup::get_num_children(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_num_children_6(PyObject *self) {
  DNAGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAGroup::get_num_children(void)
    unsigned int return_value = (local_this)->get_num_children();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAGroup.get_num_children() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_children(DNAGroup this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_get_num_children_6_comment =
  "C++ Interface:\n"
  "get_num_children(DNAGroup this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_get_num_children_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAGroup::clear_parent(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_clear_parent_7(PyObject *self) {
  DNAGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAGroup::clear_parent(void)
    (local_this)->clear_parent();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAGroup.clear_parent() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "clear_parent(DNAGroup this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_clear_parent_7_comment =
  "C++ Interface:\n"
  "clear_parent(DNAGroup this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_clear_parent_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAGroup::set_name(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_set_name_8(PyObject *self, PyObject *arg) {
  DNAGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAGroup::set_name(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_name(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAGroup.set_name() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_name(DNAGroup this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_set_name_8_comment =
  "C++ Interface:\n"
  "set_name(DNAGroup this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_set_name_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAGroup::get_name(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_name_9(PyObject *self) {
  DNAGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNAGroup::get_name(void)
    basic_string< char > return_value = (local_this)->get_name();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAGroup.get_name() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_name(DNAGroup this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_get_name_9_comment =
  "C++ Interface:\n"
  "get_name(DNAGroup this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_get_name_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAGroup::set_parent(DNAGroup *value)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_set_parent_10(PyObject *self, PyObject *arg) {
  DNAGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNAGroup::set_parent(DNAGroup *value)
        DNAGroup *arg_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNAGroup, 1, "DNAGroup.set_parent", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_parent(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAGroup.set_parent() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_parent(DNAGroup this, DNAGroup value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_set_parent_10_comment =
  "C++ Interface:\n"
  "set_parent(DNAGroup this, DNAGroup value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_set_parent_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DNAGroup *DNAGroup::get_parent(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_parent_11(PyObject *self) {
  DNAGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline DNAGroup *DNAGroup::get_parent(void)
    DNAGroup *return_value = (local_this)->get_parent();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNAGroup, false, false, (return_value)->as_typed_object()->get_type_index());
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAGroup.get_parent() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_parent(DNAGroup this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_get_parent_11_comment =
  "C++ Interface:\n"
  "get_parent(DNAGroup this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_get_parent_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAGroup::set_vis_group(DNAGroup *value)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_set_vis_group_12(PyObject *self, PyObject *arg) {
  DNAGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNAGroup::set_vis_group(DNAGroup *value)
        DNAGroup *arg_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNAGroup, 1, "DNAGroup.set_vis_group", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_vis_group(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAGroup.set_vis_group() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_vis_group(DNAGroup this, DNAGroup value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_set_vis_group_12_comment =
  "C++ Interface:\n"
  "set_vis_group(DNAGroup this, DNAGroup value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_set_vis_group_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DNAGroup *DNAGroup::get_vis_group(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_vis_group_13(PyObject *self) {
  DNAGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline DNAGroup *DNAGroup::get_vis_group(void)
    DNAGroup *return_value = (local_this)->get_vis_group();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNAGroup, false, false, (return_value)->as_typed_object()->get_type_index());
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAGroup.get_vis_group() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_vis_group(DNAGroup this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_get_vis_group_13_comment =
  "C++ Interface:\n"
  "get_vis_group(DNAGroup this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_get_vis_group_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAGroup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_class_type_14(PyObject *) {

  // 1-static TypeHandle DNAGroup::get_class_type(void)
  TypeHandle result = DNAGroup::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAGroup_get_class_type_14_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAGroup_get_class_type_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAGroup::DNAGroup(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAGroup(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAGroup::DNAGroup(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAGroup", keyword_list, &param0_str, &param0_len)) {
    DNAGroup *return_value = new DNAGroup(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAGroup, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAGroup(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAGroup(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAGroup(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAGroup) {
    printf("DNAGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAGroup *local_this = (DNAGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAGroup) {
    return local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAGroup) {
    return from_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAGroup*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNABattleCell
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNABattleCell::set_width_height(float width, float height)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_set_width_height_17(PyObject *self, PyObject *args, PyObject *kwds) {
  DNABattleCell *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNABattleCell, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNABattleCell::set_width_height(float width, float height)
    float param1;
    float param2;
    static char *keyword_list[] = {(char *)"width", (char *)"height", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_width_height", keyword_list, &param1, &param2)) {
      (local_this)->set_width_height((float)param1, (float)param2);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNABattleCell.set_width_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_width_height(DNABattleCell this, float width, float height)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNABattleCell_set_width_height_17_comment =
  "C++ Interface:\n"
  "set_width_height(DNABattleCell this, float width, float height)\n"
  "\n"
  "";
#else
static const char *Dtool_DNABattleCell_set_width_height_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNABattleCell::set_width(float value)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_set_width_18(PyObject *self, PyObject *arg) {
  DNABattleCell *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNABattleCell, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNABattleCell::set_width(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_width((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNABattleCell.set_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_width(DNABattleCell this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNABattleCell_set_width_18_comment =
  "C++ Interface:\n"
  "set_width(DNABattleCell this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNABattleCell_set_width_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNABattleCell::get_width(void)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_width_19(PyObject *self) {
  DNABattleCell *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNABattleCell, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNABattleCell::get_width(void)
    float return_value = (local_this)->get_width();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNABattleCell.get_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_width(DNABattleCell this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNABattleCell_get_width_19_comment =
  "C++ Interface:\n"
  "get_width(DNABattleCell this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNABattleCell_get_width_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNABattleCell::set_height(float value)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_set_height_20(PyObject *self, PyObject *arg) {
  DNABattleCell *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNABattleCell, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNABattleCell::set_height(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_height((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNABattleCell.set_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_height(DNABattleCell this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNABattleCell_set_height_20_comment =
  "C++ Interface:\n"
  "set_height(DNABattleCell this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNABattleCell_set_height_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNABattleCell::get_height(void)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_height_21(PyObject *self) {
  DNABattleCell *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNABattleCell, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNABattleCell::get_height(void)
    float return_value = (local_this)->get_height();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNABattleCell.get_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_height(DNABattleCell this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNABattleCell_get_height_21_comment =
  "C++ Interface:\n"
  "get_height(DNABattleCell this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNABattleCell_get_height_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNABattleCell::set_pos(LPoint3f value)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_set_pos_22(PyObject *self, PyObject *arg) {
  DNABattleCell *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNABattleCell, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNABattleCell::set_pos(LPoint3f value)
        LPoint3f *arg_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LPoint3f, 1, "DNABattleCell.set_pos", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_pos(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNABattleCell.set_pos() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_pos(DNABattleCell this, const LPoint3f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNABattleCell_set_pos_22_comment =
  "C++ Interface:\n"
  "set_pos(DNABattleCell this, const LPoint3f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNABattleCell_set_pos_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f DNABattleCell::get_pos(void)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_pos_23(PyObject *self) {
  DNABattleCell *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNABattleCell, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LPoint3f DNABattleCell::get_pos(void)
    LPoint3f result = (local_this)->get_pos();
    LPoint3f *return_value = new LPoint3f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LPoint3f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNABattleCell.get_pos() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_pos(DNABattleCell this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNABattleCell_get_pos_23_comment =
  "C++ Interface:\n"
  "get_pos(DNABattleCell this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNABattleCell_get_pos_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNABattleCell::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_class_type_24(PyObject *) {

  // 1-static TypeHandle DNABattleCell::get_class_type(void)
  TypeHandle result = DNABattleCell::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNABattleCell_get_class_type_24_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNABattleCell_get_class_type_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNABattleCell::DNABattleCell(float width, float height, LPoint3f pos)
 *******************************************************************/
int Dtool_Init_DNABattleCell(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      // 1-DNABattleCell::DNABattleCell(float width, float height, LPoint3f pos)
      float param0;
      float param1;
      PyObject *param2;
      static char *keyword_list[] = {(char *)"width", (char *)"height", (char *)"pos", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:DNABattleCell", keyword_list, &param0, &param1, &param2)) {
        LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNABattleCell.DNABattleCell", 1, coerced_ptr, report_errors);

        if (param2_this != NULL) {
          DNABattleCell *return_value = new DNABattleCell((float)param0, (float)param1, *param2_this);
          Py_XDECREF(coerced);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (PyErr_Occurred()) {
            delete return_value;
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return -1;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              delete return_value;
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, return_value, &Dtool_DNABattleCell, true, false);
          }
        }
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNABattleCell(float width, float height, const LPoint3f pos)\n"
      "");
  }
  return -1;
}


/******************************************************************
 * Python type method wrapper for
 * DNABattleCell::DNABattleCell(float width, float height, LPoint3f pos)
 *******************************************************************/
int Dtool_InitNoCoerce_DNABattleCell(PyObject *self, PyObject *args) {

  // 1-DNABattleCell::DNABattleCell(float width, float height, LPoint3f pos)
  float param0;
  float param1;
  PyObject *param2;
  if (PyArg_ParseTuple(args, "ffO:DNABattleCell", &param0, &param1, &param2)) {
    LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNABattleCell.DNABattleCell", 1, NULL, true);

    if (param2_this != NULL) {
      DNABattleCell *return_value = new DNABattleCell((float)param0, (float)param1, *param2_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (PyErr_Occurred()) {
        delete return_value;
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return -1;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          delete return_value;
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, return_value, &Dtool_DNABattleCell, true, false);
      }
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNABattleCell(float width, float height, const LPoint3f pos)\n"
      "");
  }
  return -1;
}


inline void *Dtool_UpcastInterface_DNABattleCell(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNABattleCell) {
    printf("DNABattleCell ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNABattleCell *local_this = (DNABattleCell *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNABattleCell) {
    return local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNABattleCell(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNABattleCell) {
    return from_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNABattleCell*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNAVisGroup
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNAVisGroup::add_visible(basic_string< char > const &visible)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_add_visible_27(PyObject *self, PyObject *arg) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAVisGroup::add_visible(basic_string< char > const &visible)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->add_visible(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAVisGroup.add_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "add_visible(DNAVisGroup this, str visible)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_add_visible_27_comment =
  "C++ Interface:\n"
  "add_visible(DNAVisGroup this, str visible)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_add_visible_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DNAVisGroup::remove_visible(basic_string< char > const &visible)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_remove_visible_28(PyObject *self, PyObject *arg) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-bool DNAVisGroup::remove_visible(basic_string< char > const &visible)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      bool return_value = (local_this)->remove_visible(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        return PyBool_FromLong(return_value);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAVisGroup.remove_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "remove_visible(DNAVisGroup this, str visible)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_remove_visible_28_comment =
  "C++ Interface:\n"
  "remove_visible(DNAVisGroup this, str visible)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_remove_visible_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAVisGroup::get_num_visibles(void)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_num_visibles_29(PyObject *self) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAVisGroup::get_num_visibles(void)
    unsigned int return_value = (local_this)->get_num_visibles();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAVisGroup.get_num_visibles() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_visibles(DNAVisGroup this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_get_num_visibles_29_comment =
  "C++ Interface:\n"
  "get_num_visibles(DNAVisGroup this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_get_num_visibles_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &DNAVisGroup::get_visible(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_visible_30(PyObject *self, PyObject *arg) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-basic_string< char > const &DNAVisGroup::get_visible(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      basic_string< char > const &return_value = (local_this)->get_visible(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
        return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAVisGroup.get_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_visible(DNAVisGroup this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_get_visible_30_comment =
  "C++ Interface:\n"
  "get_visible(DNAVisGroup this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_get_visible_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAVisGroup::add_suit_edge(DNASuitEdge *edge)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_add_suit_edge_31(PyObject *self, PyObject *arg) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void DNAVisGroup::add_suit_edge(DNASuitEdge *edge)
        DNASuitEdge *arg_this = (DNASuitEdge *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNASuitEdge, 1, "DNAVisGroup.add_suit_edge", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->add_suit_edge(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAVisGroup.add_suit_edge() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "add_suit_edge(DNAVisGroup this, DNASuitEdge edge)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_add_suit_edge_31_comment =
  "C++ Interface:\n"
  "add_suit_edge(DNAVisGroup this, DNASuitEdge edge)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_add_suit_edge_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DNAVisGroup::remove_suit_edge(DNASuitEdge *edge)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_remove_suit_edge_32(PyObject *self, PyObject *arg) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-bool DNAVisGroup::remove_suit_edge(DNASuitEdge *edge)
        DNASuitEdge *arg_this = (DNASuitEdge *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNASuitEdge, 1, "DNAVisGroup.remove_suit_edge", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          bool return_value = (local_this)->remove_suit_edge(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            return PyBool_FromLong(return_value);
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAVisGroup.remove_suit_edge() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "remove_suit_edge(DNAVisGroup this, DNASuitEdge edge)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_remove_suit_edge_32_comment =
  "C++ Interface:\n"
  "remove_suit_edge(DNAVisGroup this, DNASuitEdge edge)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_remove_suit_edge_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAVisGroup::get_num_suit_edges(void)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_num_suit_edges_33(PyObject *self) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAVisGroup::get_num_suit_edges(void)
    unsigned int return_value = (local_this)->get_num_suit_edges();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAVisGroup.get_num_suit_edges() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_suit_edges(DNAVisGroup this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_get_num_suit_edges_33_comment =
  "C++ Interface:\n"
  "get_num_suit_edges(DNAVisGroup this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_get_num_suit_edges_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitEdge *DNAVisGroup::get_suit_edge(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_suit_edge_34(PyObject *self, PyObject *arg) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-DNASuitEdge *DNAVisGroup::get_suit_edge(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      DNASuitEdge *return_value = (local_this)->get_suit_edge(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitEdge, false, false, (return_value)->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAVisGroup.get_suit_edge() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_suit_edge(DNAVisGroup this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_get_suit_edge_34_comment =
  "C++ Interface:\n"
  "get_suit_edge(DNAVisGroup this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_get_suit_edge_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAVisGroup::add_battle_cell(DNABattleCell *cell)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_add_battle_cell_35(PyObject *self, PyObject *arg) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void DNAVisGroup::add_battle_cell(DNABattleCell *cell)
        DNABattleCell *arg_this = (DNABattleCell *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNABattleCell, 1, "DNAVisGroup.add_battle_cell", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->add_battle_cell(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAVisGroup.add_battle_cell() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "add_battle_cell(DNAVisGroup this, DNABattleCell cell)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_add_battle_cell_35_comment =
  "C++ Interface:\n"
  "add_battle_cell(DNAVisGroup this, DNABattleCell cell)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_add_battle_cell_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DNAVisGroup::remove_battle_cell(DNABattleCell *cell)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_remove_battle_cell_36(PyObject *self, PyObject *arg) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-bool DNAVisGroup::remove_battle_cell(DNABattleCell *cell)
        DNABattleCell *arg_this = (DNABattleCell *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNABattleCell, 1, "DNAVisGroup.remove_battle_cell", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          bool return_value = (local_this)->remove_battle_cell(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            return PyBool_FromLong(return_value);
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAVisGroup.remove_battle_cell() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "remove_battle_cell(DNAVisGroup this, DNABattleCell cell)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_remove_battle_cell_36_comment =
  "C++ Interface:\n"
  "remove_battle_cell(DNAVisGroup this, DNABattleCell cell)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_remove_battle_cell_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAVisGroup::get_num_battle_cells(void)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_num_battle_cells_37(PyObject *self) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAVisGroup::get_num_battle_cells(void)
    unsigned int return_value = (local_this)->get_num_battle_cells();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAVisGroup.get_num_battle_cells() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_battle_cells(DNAVisGroup this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_get_num_battle_cells_37_comment =
  "C++ Interface:\n"
  "get_num_battle_cells(DNAVisGroup this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_get_num_battle_cells_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNABattleCell *DNAVisGroup::get_battle_cell(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_battle_cell_38(PyObject *self, PyObject *arg) {
  DNAVisGroup *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAVisGroup, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-DNABattleCell *DNAVisGroup::get_battle_cell(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      DNABattleCell *return_value = (local_this)->get_battle_cell(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNABattleCell, false, false, (return_value)->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAVisGroup.get_battle_cell() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_battle_cell(DNAVisGroup this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_get_battle_cell_38_comment =
  "C++ Interface:\n"
  "get_battle_cell(DNAVisGroup this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_get_battle_cell_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAVisGroup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_class_type_39(PyObject *) {

  // 1-static TypeHandle DNAVisGroup::get_class_type(void)
  TypeHandle result = DNAVisGroup::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAVisGroup_get_class_type_39_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAVisGroup_get_class_type_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAVisGroup::DNAVisGroup(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAVisGroup(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAVisGroup::DNAVisGroup(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAVisGroup", keyword_list, &param0_str, &param0_len)) {
    DNAVisGroup *return_value = new DNAVisGroup(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAVisGroup, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAVisGroup(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAVisGroup(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAVisGroup(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAVisGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAVisGroup) {
    printf("DNAVisGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAVisGroup *local_this = (DNAVisGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAVisGroup) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAVisGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAVisGroup) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNAVisGroup*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAVisGroup*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNANode
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNANode::set_pos(LVecBase3f value)
 *******************************************************************/
static PyObject *Dtool_DNANode_set_pos_42(PyObject *self, PyObject *arg) {
  DNANode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNANode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNANode::set_pos(LVecBase3f value)
        LVecBase3f *arg_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase3f, 1, "DNANode.set_pos", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_pos(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNANode.set_pos() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_pos(DNANode this, const LVecBase3f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNANode_set_pos_42_comment =
  "C++ Interface:\n"
  "set_pos(DNANode this, const LVecBase3f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNANode_set_pos_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f DNANode::get_pos(void)
 *******************************************************************/
static PyObject *Dtool_DNANode_get_pos_43(PyObject *self) {
  DNANode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNANode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase3f DNANode::get_pos(void)
    LVecBase3f result = (local_this)->get_pos();
    LVecBase3f *return_value = new LVecBase3f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase3f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNANode.get_pos() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_pos(DNANode this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNANode_get_pos_43_comment =
  "C++ Interface:\n"
  "get_pos(DNANode this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNANode_get_pos_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNANode::set_hpr(LVecBase3f value)
 *******************************************************************/
static PyObject *Dtool_DNANode_set_hpr_44(PyObject *self, PyObject *arg) {
  DNANode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNANode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNANode::set_hpr(LVecBase3f value)
        LVecBase3f *arg_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase3f, 1, "DNANode.set_hpr", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_hpr(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNANode.set_hpr() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_hpr(DNANode this, const LVecBase3f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNANode_set_hpr_44_comment =
  "C++ Interface:\n"
  "set_hpr(DNANode this, const LVecBase3f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNANode_set_hpr_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f DNANode::get_hpr(void)
 *******************************************************************/
static PyObject *Dtool_DNANode_get_hpr_45(PyObject *self) {
  DNANode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNANode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase3f DNANode::get_hpr(void)
    LVecBase3f result = (local_this)->get_hpr();
    LVecBase3f *return_value = new LVecBase3f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase3f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNANode.get_hpr() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_hpr(DNANode this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNANode_get_hpr_45_comment =
  "C++ Interface:\n"
  "get_hpr(DNANode this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNANode_get_hpr_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNANode::set_scale(LVecBase3f value)
 *******************************************************************/
static PyObject *Dtool_DNANode_set_scale_46(PyObject *self, PyObject *arg) {
  DNANode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNANode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNANode::set_scale(LVecBase3f value)
        LVecBase3f *arg_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase3f, 1, "DNANode.set_scale", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_scale(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNANode.set_scale() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_scale(DNANode this, const LVecBase3f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNANode_set_scale_46_comment =
  "C++ Interface:\n"
  "set_scale(DNANode this, const LVecBase3f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNANode_set_scale_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f DNANode::get_scale(void)
 *******************************************************************/
static PyObject *Dtool_DNANode_get_scale_47(PyObject *self) {
  DNANode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNANode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase3f DNANode::get_scale(void)
    LVecBase3f result = (local_this)->get_scale();
    LVecBase3f *return_value = new LVecBase3f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase3f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNANode.get_scale() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_scale(DNANode this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNANode_get_scale_47_comment =
  "C++ Interface:\n"
  "get_scale(DNANode this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNANode_get_scale_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNANode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNANode_get_class_type_48(PyObject *) {

  // 1-static TypeHandle DNANode::get_class_type(void)
  TypeHandle result = DNANode::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNANode_get_class_type_48_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNANode_get_class_type_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNANode::DNANode(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNANode(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNANode::DNANode(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNANode", keyword_list, &param0_str, &param0_len)) {
    DNANode *return_value = new DNANode(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNANode, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNANode(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNANode(PyObject *self, PyObject *args) {
  return Dtool_Init_DNANode(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNANode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNANode) {
    printf("DNANode ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNANode *local_this = (DNANode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNANode) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNANode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNANode) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNANode*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNANode*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNAProp
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAProp::set_color(LVecBase4f value)
 *******************************************************************/
static PyObject *Dtool_DNAProp_set_color_51(PyObject *self, PyObject *arg) {
  DNAProp *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAProp, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNAProp::set_color(LVecBase4f value)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "DNAProp.set_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_color(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAProp.set_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_color(DNAProp this, const LVecBase4f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAProp_set_color_51_comment =
  "C++ Interface:\n"
  "set_color(DNAProp this, const LVecBase4f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAProp_set_color_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAProp::get_color(void)
 *******************************************************************/
static PyObject *Dtool_DNAProp_get_color_52(PyObject *self) {
  DNAProp *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAProp, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f DNAProp::get_color(void)
    LVecBase4f result = (local_this)->get_color();
    LVecBase4f *return_value = new LVecBase4f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAProp.get_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_color(DNAProp this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAProp_get_color_52_comment =
  "C++ Interface:\n"
  "get_color(DNAProp this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAProp_get_color_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAProp::set_code(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNAProp_set_code_53(PyObject *self, PyObject *arg) {
  DNAProp *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAProp, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAProp::set_code(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_code(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAProp.set_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_code(DNAProp this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAProp_set_code_53_comment =
  "C++ Interface:\n"
  "set_code(DNAProp this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAProp_set_code_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAProp::get_code(void)
 *******************************************************************/
static PyObject *Dtool_DNAProp_get_code_54(PyObject *self) {
  DNAProp *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAProp, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNAProp::get_code(void)
    basic_string< char > return_value = (local_this)->get_code();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAProp.get_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_code(DNAProp this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAProp_get_code_54_comment =
  "C++ Interface:\n"
  "get_code(DNAProp this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAProp_get_code_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAProp::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAProp_get_class_type_55(PyObject *) {

  // 1-static TypeHandle DNAProp::get_class_type(void)
  TypeHandle result = DNAProp::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAProp_get_class_type_55_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAProp_get_class_type_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAProp::DNAProp(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAProp(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAProp::DNAProp(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAProp", keyword_list, &param0_str, &param0_len)) {
    DNAProp *return_value = new DNAProp(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAProp, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAProp(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAProp(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAProp(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAProp(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAProp) {
    printf("DNAProp ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAProp *local_this = (DNAProp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAProp) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAProp(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAProp) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNAProp*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNAProp*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAProp*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNASign
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASign::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASign_get_class_type_58(PyObject *) {

  // 1-static TypeHandle DNASign::get_class_type(void)
  TypeHandle result = DNASign::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASign_get_class_type_58_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNASign_get_class_type_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASign::DNASign(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNASign(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNASign::DNASign(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNASign", keyword_list, &param0_str, &param0_len)) {
    DNASign *return_value = new DNASign(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNASign, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNASign(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNASign(PyObject *self, PyObject *args) {
  return Dtool_Init_DNASign(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNASign(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNASign) {
    printf("DNASign ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNASign *local_this = (DNASign *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNASign) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *)(DNAProp *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *)(DNAProp *) local_this;
  }
  if (requested_type == &Dtool_DNAProp) {
    return (DNAProp *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *)(DNAProp *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNASign(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNASign) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNASign*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNASign*)other_this;
  }
  if (from_type == &Dtool_DNAProp) {
    DNAProp* other_this = (DNAProp*)from_this;
    return (DNASign*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNASign*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNASignBaseline
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_text(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_text_61(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignBaseline::set_text(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_text(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.set_text() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_text(DNASignBaseline this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_text_61_comment =
  "C++ Interface:\n"
  "set_text(DNASignBaseline this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_text_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNASignBaseline::get_text(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_text_62(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNASignBaseline::get_text(void)
    basic_string< char > return_value = (local_this)->get_text();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_text() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_text(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_text_62_comment =
  "C++ Interface:\n"
  "get_text(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_text_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_code(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_code_63(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignBaseline::set_code(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_code(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.set_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_code(DNASignBaseline this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_code_63_comment =
  "C++ Interface:\n"
  "set_code(DNASignBaseline this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_code_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNASignBaseline::get_code(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_code_64(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNASignBaseline::get_code(void)
    basic_string< char > return_value = (local_this)->get_code();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_code(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_code_64_comment =
  "C++ Interface:\n"
  "get_code(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_code_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_flags(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_flags_65(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignBaseline::set_flags(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_flags(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.set_flags() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_flags(DNASignBaseline this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_flags_65_comment =
  "C++ Interface:\n"
  "set_flags(DNASignBaseline this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_flags_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNASignBaseline::get_flags(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_flags_66(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNASignBaseline::get_flags(void)
    basic_string< char > return_value = (local_this)->get_flags();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_flags() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_flags(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_flags_66_comment =
  "C++ Interface:\n"
  "get_flags(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_flags_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_color(LVecBase4f value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_color_67(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNASignBaseline::set_color(LVecBase4f value)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "DNASignBaseline.set_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_color(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNASignBaseline.set_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_color(DNASignBaseline this, const LVecBase4f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_color_67_comment =
  "C++ Interface:\n"
  "set_color(DNASignBaseline this, const LVecBase4f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_color_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNASignBaseline::get_color(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_color_68(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f DNASignBaseline::get_color(void)
    LVecBase4f result = (local_this)->get_color();
    LVecBase4f *return_value = new LVecBase4f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_color(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_color_68_comment =
  "C++ Interface:\n"
  "get_color(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_color_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_indent(float value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_indent_69(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignBaseline::set_indent(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_indent((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.set_indent() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_indent(DNASignBaseline this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_indent_69_comment =
  "C++ Interface:\n"
  "set_indent(DNASignBaseline this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_indent_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_indent(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_indent_70(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNASignBaseline::get_indent(void)
    float return_value = (local_this)->get_indent();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_indent() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_indent(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_indent_70_comment =
  "C++ Interface:\n"
  "get_indent(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_indent_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_kern(float value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_kern_71(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignBaseline::set_kern(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_kern((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.set_kern() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_kern(DNASignBaseline this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_kern_71_comment =
  "C++ Interface:\n"
  "set_kern(DNASignBaseline this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_kern_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_kern(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_kern_72(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNASignBaseline::get_kern(void)
    float return_value = (local_this)->get_kern();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_kern() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_kern(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_kern_72_comment =
  "C++ Interface:\n"
  "get_kern(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_kern_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_wiggle(float value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_wiggle_73(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignBaseline::set_wiggle(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_wiggle((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.set_wiggle() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_wiggle(DNASignBaseline this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_wiggle_73_comment =
  "C++ Interface:\n"
  "set_wiggle(DNASignBaseline this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_wiggle_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_wiggle(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_wiggle_74(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNASignBaseline::get_wiggle(void)
    float return_value = (local_this)->get_wiggle();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_wiggle() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_wiggle(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_wiggle_74_comment =
  "C++ Interface:\n"
  "get_wiggle(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_wiggle_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_stumble(float value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_stumble_75(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignBaseline::set_stumble(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_stumble((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.set_stumble() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_stumble(DNASignBaseline this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_stumble_75_comment =
  "C++ Interface:\n"
  "set_stumble(DNASignBaseline this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_stumble_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_stumble(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_stumble_76(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNASignBaseline::get_stumble(void)
    float return_value = (local_this)->get_stumble();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_stumble() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_stumble(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_stumble_76_comment =
  "C++ Interface:\n"
  "get_stumble(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_stumble_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_stomp(float value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_stomp_77(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignBaseline::set_stomp(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_stomp((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.set_stomp() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_stomp(DNASignBaseline this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_stomp_77_comment =
  "C++ Interface:\n"
  "set_stomp(DNASignBaseline this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_stomp_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_stomp(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_stomp_78(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNASignBaseline::get_stomp(void)
    float return_value = (local_this)->get_stomp();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_stomp() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_stomp(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_stomp_78_comment =
  "C++ Interface:\n"
  "get_stomp(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_stomp_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_width(float value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_width_79(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignBaseline::set_width(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_width((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.set_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_width(DNASignBaseline this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_width_79_comment =
  "C++ Interface:\n"
  "set_width(DNASignBaseline this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_width_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_width(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_width_80(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNASignBaseline::get_width(void)
    float return_value = (local_this)->get_width();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_width(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_width_80_comment =
  "C++ Interface:\n"
  "get_width(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_width_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_height(float value)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_height_81(PyObject *self, PyObject *arg) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignBaseline::set_height(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_height((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.set_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_height(DNASignBaseline this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_set_height_81_comment =
  "C++ Interface:\n"
  "set_height(DNASignBaseline this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_set_height_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_height(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_height_82(PyObject *self) {
  DNASignBaseline *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignBaseline, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNASignBaseline::get_height(void)
    float return_value = (local_this)->get_height();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignBaseline.get_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_height(DNASignBaseline this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_height_82_comment =
  "C++ Interface:\n"
  "get_height(DNASignBaseline this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_height_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASignBaseline::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_class_type_83(PyObject *) {

  // 1-static TypeHandle DNASignBaseline::get_class_type(void)
  TypeHandle result = DNASignBaseline::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignBaseline_get_class_type_83_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignBaseline_get_class_type_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASignBaseline::DNASignBaseline(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNASignBaseline(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNASignBaseline::DNASignBaseline(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNASignBaseline", keyword_list, &param0_str, &param0_len)) {
    DNASignBaseline *return_value = new DNASignBaseline(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNASignBaseline, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNASignBaseline(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNASignBaseline(PyObject *self, PyObject *args) {
  return Dtool_Init_DNASignBaseline(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNASignBaseline(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNASignBaseline) {
    printf("DNASignBaseline ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNASignBaseline *local_this = (DNASignBaseline *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNASignBaseline) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNASignBaseline(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNASignBaseline) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNASignBaseline*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNASignBaseline*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNASignBaseline*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNASignGraphic
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNASignGraphic::set_width(float value)
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_set_width_86(PyObject *self, PyObject *arg) {
  DNASignGraphic *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignGraphic, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignGraphic::set_width(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_width((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignGraphic.set_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_width(DNASignGraphic this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignGraphic_set_width_86_comment =
  "C++ Interface:\n"
  "set_width(DNASignGraphic this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignGraphic_set_width_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignGraphic::get_width(void)
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_get_width_87(PyObject *self) {
  DNASignGraphic *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignGraphic, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNASignGraphic::get_width(void)
    float return_value = (local_this)->get_width();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignGraphic.get_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_width(DNASignGraphic this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignGraphic_get_width_87_comment =
  "C++ Interface:\n"
  "get_width(DNASignGraphic this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignGraphic_get_width_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignGraphic::set_height(float value)
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_set_height_88(PyObject *self, PyObject *arg) {
  DNASignGraphic *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignGraphic, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASignGraphic::set_height(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_height((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignGraphic.set_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_height(DNASignGraphic this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignGraphic_set_height_88_comment =
  "C++ Interface:\n"
  "set_height(DNASignGraphic this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignGraphic_set_height_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignGraphic::get_height(void)
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_get_height_89(PyObject *self) {
  DNASignGraphic *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASignGraphic, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNASignGraphic::get_height(void)
    float return_value = (local_this)->get_height();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASignGraphic.get_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_height(DNASignGraphic this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignGraphic_get_height_89_comment =
  "C++ Interface:\n"
  "get_height(DNASignGraphic this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignGraphic_get_height_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASignGraphic::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_get_class_type_90(PyObject *) {

  // 1-static TypeHandle DNASignGraphic::get_class_type(void)
  TypeHandle result = DNASignGraphic::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASignGraphic_get_class_type_90_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNASignGraphic_get_class_type_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASignGraphic::DNASignGraphic(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNASignGraphic(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNASignGraphic::DNASignGraphic(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNASignGraphic", keyword_list, &param0_str, &param0_len)) {
    DNASignGraphic *return_value = new DNASignGraphic(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNASignGraphic, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNASignGraphic(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNASignGraphic(PyObject *self, PyObject *args) {
  return Dtool_Init_DNASignGraphic(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNASignGraphic(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNASignGraphic) {
    printf("DNASignGraphic ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNASignGraphic *local_this = (DNASignGraphic *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNASignGraphic) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *)(DNAProp *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *)(DNAProp *) local_this;
  }
  if (requested_type == &Dtool_DNAProp) {
    return (DNAProp *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *)(DNAProp *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNASignGraphic(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNASignGraphic) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNASignGraphic*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNASignGraphic*)other_this;
  }
  if (from_type == &Dtool_DNAProp) {
    DNAProp* other_this = (DNAProp*)from_this;
    return (DNASignGraphic*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNASignGraphic*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNAFlatBuilding
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAFlatBuilding::set_width(float value)
 *******************************************************************/
static PyObject *Dtool_DNAFlatBuilding_set_width_93(PyObject *self, PyObject *arg) {
  DNAFlatBuilding *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAFlatBuilding, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAFlatBuilding::set_width(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_width((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAFlatBuilding.set_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_width(DNAFlatBuilding this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAFlatBuilding_set_width_93_comment =
  "C++ Interface:\n"
  "set_width(DNAFlatBuilding this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAFlatBuilding_set_width_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNAFlatBuilding::get_width(void)
 *******************************************************************/
static PyObject *Dtool_DNAFlatBuilding_get_width_94(PyObject *self) {
  DNAFlatBuilding *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAFlatBuilding, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNAFlatBuilding::get_width(void)
    float return_value = (local_this)->get_width();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAFlatBuilding.get_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_width(DNAFlatBuilding this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAFlatBuilding_get_width_94_comment =
  "C++ Interface:\n"
  "get_width(DNAFlatBuilding this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAFlatBuilding_get_width_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAFlatBuilding::set_has_door(bool value)
 *******************************************************************/
static PyObject *Dtool_DNAFlatBuilding_set_has_door_95(PyObject *self, PyObject *arg) {
  DNAFlatBuilding *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAFlatBuilding, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAFlatBuilding::set_has_door(bool value)
    (local_this)->set_has_door((PyObject_IsTrue(arg) != 0));
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAFlatBuilding.set_has_door() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_has_door(DNAFlatBuilding this, bool value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAFlatBuilding_set_has_door_95_comment =
  "C++ Interface:\n"
  "set_has_door(DNAFlatBuilding this, bool value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAFlatBuilding_set_has_door_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DNAFlatBuilding::get_has_door(void)
 *******************************************************************/
static PyObject *Dtool_DNAFlatBuilding_get_has_door_96(PyObject *self) {
  DNAFlatBuilding *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAFlatBuilding, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline bool DNAFlatBuilding::get_has_door(void)
    bool return_value = (local_this)->get_has_door();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyBool_FromLong(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAFlatBuilding.get_has_door() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_has_door(DNAFlatBuilding this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAFlatBuilding_get_has_door_96_comment =
  "C++ Interface:\n"
  "get_has_door(DNAFlatBuilding this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAFlatBuilding_get_has_door_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAFlatBuilding::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAFlatBuilding_get_class_type_97(PyObject *) {

  // 1-static TypeHandle DNAFlatBuilding::get_class_type(void)
  TypeHandle result = DNAFlatBuilding::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAFlatBuilding_get_class_type_97_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAFlatBuilding_get_class_type_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAFlatBuilding::DNAFlatBuilding(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAFlatBuilding(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAFlatBuilding::DNAFlatBuilding(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAFlatBuilding", keyword_list, &param0_str, &param0_len)) {
    DNAFlatBuilding *return_value = new DNAFlatBuilding(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAFlatBuilding, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAFlatBuilding(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAFlatBuilding(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAFlatBuilding(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAFlatBuilding(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAFlatBuilding) {
    printf("DNAFlatBuilding ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAFlatBuilding *local_this = (DNAFlatBuilding *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAFlatBuilding) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAFlatBuilding(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAFlatBuilding) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNAFlatBuilding*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNAFlatBuilding*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAFlatBuilding*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNAWall
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAWall::set_color(LVecBase4f value)
 *******************************************************************/
static PyObject *Dtool_DNAWall_set_color_100(PyObject *self, PyObject *arg) {
  DNAWall *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWall, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNAWall::set_color(LVecBase4f value)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "DNAWall.set_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_color(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAWall.set_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_color(DNAWall this, const LVecBase4f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWall_set_color_100_comment =
  "C++ Interface:\n"
  "set_color(DNAWall this, const LVecBase4f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWall_set_color_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAWall::get_color(void)
 *******************************************************************/
static PyObject *Dtool_DNAWall_get_color_101(PyObject *self) {
  DNAWall *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWall, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f DNAWall::get_color(void)
    LVecBase4f result = (local_this)->get_color();
    LVecBase4f *return_value = new LVecBase4f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAWall.get_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_color(DNAWall this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWall_get_color_101_comment =
  "C++ Interface:\n"
  "get_color(DNAWall this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWall_get_color_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAWall::set_height(float value)
 *******************************************************************/
static PyObject *Dtool_DNAWall_set_height_102(PyObject *self, PyObject *arg) {
  DNAWall *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWall, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAWall::set_height(float value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_height((float) PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAWall.set_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_height(DNAWall this, float value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWall_set_height_102_comment =
  "C++ Interface:\n"
  "set_height(DNAWall this, float value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWall_set_height_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNAWall::get_height(void)
 *******************************************************************/
static PyObject *Dtool_DNAWall_get_height_103(PyObject *self) {
  DNAWall *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWall, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float DNAWall::get_height(void)
    float return_value = (local_this)->get_height();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAWall.get_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_height(DNAWall this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWall_get_height_103_comment =
  "C++ Interface:\n"
  "get_height(DNAWall this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWall_get_height_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAWall::set_code(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNAWall_set_code_104(PyObject *self, PyObject *arg) {
  DNAWall *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWall, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAWall::set_code(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_code(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAWall.set_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_code(DNAWall this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWall_set_code_104_comment =
  "C++ Interface:\n"
  "set_code(DNAWall this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWall_set_code_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAWall::get_code(void)
 *******************************************************************/
static PyObject *Dtool_DNAWall_get_code_105(PyObject *self) {
  DNAWall *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWall, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNAWall::get_code(void)
    basic_string< char > return_value = (local_this)->get_code();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAWall.get_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_code(DNAWall this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWall_get_code_105_comment =
  "C++ Interface:\n"
  "get_code(DNAWall this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWall_get_code_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAWall::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAWall_get_class_type_106(PyObject *) {

  // 1-static TypeHandle DNAWall::get_class_type(void)
  TypeHandle result = DNAWall::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWall_get_class_type_106_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWall_get_class_type_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAWall::DNAWall(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAWall(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAWall::DNAWall(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAWall", keyword_list, &param0_str, &param0_len)) {
    DNAWall *return_value = new DNAWall(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAWall, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAWall(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAWall(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAWall(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAWall(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAWall) {
    printf("DNAWall ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAWall *local_this = (DNAWall *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAWall) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAWall(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAWall) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNAWall*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNAWall*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAWall*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNAWindows
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNAWindows::make_windows(float x, float y, NodePath &parent_node, basic_string< char > const &code, float scale, LVecBase4f &color, DNAStorage *store, bool flip)
 * void DNAWindows::make_windows(float x, float y, NodePath &parent_node, basic_string< char > const &code, float scale, LVecBase4f &color, DNAStorage *store, bool flip = (0))
 *******************************************************************/
static PyObject *Dtool_DNAWindows_make_windows_109(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAWindows *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWindows, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 7: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAWindows::make_windows(float x, float y, NodePath &parent_node, basic_string< char > const &code, float scale, LVecBase4f &color, DNAStorage *store, bool flip = (0))
          float param1;
          float param2;
          PyObject *param3;
          char *param4_str;
          Py_ssize_t param4_len;
          float param5;
          PyObject *param6;
          PyObject *param7;
          static char *keyword_list[] = {(char *)"x", (char *)"y", (char *)"parent_node", (char *)"code", (char *)"scale", (char *)"color", (char *)"store", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "ffOs#fOO:make_windows", keyword_list, &param1, &param2, &param3, &param4_str, &param4_len, &param5, &param6, &param7)) {
            NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "DNAWindows.make_windows", 0, coerced_ptr, report_errors);
LVecBase4f *param6_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LVecBase4f, 6, "DNAWindows.make_windows", 0, coerced_ptr, report_errors);
DNAStorage *param7_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_DNAStorage, 7, "DNAWindows.make_windows", 0, coerced_ptr, report_errors);

            if (param3_this != NULL && param6_this != NULL && param7_this != NULL) {
              (local_this)->make_windows((float)param1, (float)param2, *param3_this, basic_string<char>(param4_str, param4_len), (float)param5, *param6_this, param7_this);
              Py_XDECREF(coerced);
              if (PyErr_Occurred()) {
                if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
                  return (PyObject *)NULL;
                }
              } else {
#ifndef NDEBUG
                Notify *notify = Notify::ptr();
                if (notify->has_assert_failed()) {
                  PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                  notify->clear_assert_failed();
                  return (PyObject *)NULL;
                }
#endif
                Py_INCREF(Py_None);
                return Py_None;
              }
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAWindows.make_windows() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 8: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAWindows::make_windows(float x, float y, NodePath &parent_node, basic_string< char > const &code, float scale, LVecBase4f &color, DNAStorage *store, bool flip)
          float param1;
          float param2;
          PyObject *param3;
          char *param4_str;
          Py_ssize_t param4_len;
          float param5;
          PyObject *param6;
          PyObject *param7;
          PyObject *param8;
          static char *keyword_list[] = {(char *)"x", (char *)"y", (char *)"parent_node", (char *)"code", (char *)"scale", (char *)"color", (char *)"store", (char *)"flip", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "ffOs#fOOO:make_windows", keyword_list, &param1, &param2, &param3, &param4_str, &param4_len, &param5, &param6, &param7, &param8)) {
            NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "DNAWindows.make_windows", 0, coerced_ptr, report_errors);
LVecBase4f *param6_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LVecBase4f, 6, "DNAWindows.make_windows", 0, coerced_ptr, report_errors);
DNAStorage *param7_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_DNAStorage, 7, "DNAWindows.make_windows", 0, coerced_ptr, report_errors);

            if (param3_this != NULL && param6_this != NULL && param7_this != NULL) {
              (local_this)->make_windows((float)param1, (float)param2, *param3_this, basic_string<char>(param4_str, param4_len), (float)param5, *param6_this, param7_this, (PyObject_IsTrue(param8) != 0));
              Py_XDECREF(coerced);
              if (PyErr_Occurred()) {
                if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
                  return (PyObject *)NULL;
                }
              } else {
#ifndef NDEBUG
                Notify *notify = Notify::ptr();
                if (notify->has_assert_failed()) {
                  PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                  notify->clear_assert_failed();
                  return (PyObject *)NULL;
                }
#endif
                Py_INCREF(Py_None);
                return Py_None;
              }
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAWindows.make_windows() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "make_windows() takes 8 or 9 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "make_windows(DNAWindows this, float x, float y, NodePath parent_node, str code, float scale, LVecBase4f color, DNAStorage store)\n"
      "make_windows(DNAWindows this, float x, float y, NodePath parent_node, str code, float scale, LVecBase4f color, DNAStorage store, bool flip)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWindows_make_windows_109_comment =
  "C++ Interface:\n"
  "make_windows(DNAWindows this, float x, float y, NodePath parent_node, str code, float scale, LVecBase4f color, DNAStorage store)\n"
  "make_windows(DNAWindows this, float x, float y, NodePath parent_node, str code, float scale, LVecBase4f color, DNAStorage store, bool flip)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWindows_make_windows_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAWindows::set_color(LVecBase4f value)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_set_color_110(PyObject *self, PyObject *arg) {
  DNAWindows *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWindows, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNAWindows::set_color(LVecBase4f value)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "DNAWindows.set_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_color(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAWindows.set_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_color(DNAWindows this, const LVecBase4f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWindows_set_color_110_comment =
  "C++ Interface:\n"
  "set_color(DNAWindows this, const LVecBase4f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWindows_set_color_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAWindows::get_color(void)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_get_color_111(PyObject *self) {
  DNAWindows *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWindows, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f DNAWindows::get_color(void)
    LVecBase4f result = (local_this)->get_color();
    LVecBase4f *return_value = new LVecBase4f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAWindows.get_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_color(DNAWindows this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWindows_get_color_111_comment =
  "C++ Interface:\n"
  "get_color(DNAWindows this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWindows_get_color_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAWindows::set_window_count(unsigned char value)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_set_window_count_112(PyObject *self, PyObject *arg) {
  DNAWindows *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWindows, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAWindows::set_window_count(unsigned char value)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      (local_this)->set_window_count(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAWindows.set_window_count() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_window_count(DNAWindows this, unsigned int value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWindows_set_window_count_112_comment =
  "C++ Interface:\n"
  "set_window_count(DNAWindows this, unsigned int value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWindows_set_window_count_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned char DNAWindows::get_window_count(void)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_get_window_count_113(PyObject *self) {
  DNAWindows *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWindows, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline unsigned char DNAWindows::get_window_count(void)
    unsigned char return_value = (local_this)->get_window_count();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAWindows.get_window_count() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_window_count(DNAWindows this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWindows_get_window_count_113_comment =
  "C++ Interface:\n"
  "get_window_count(DNAWindows this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWindows_get_window_count_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAWindows::set_code(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_set_code_114(PyObject *self, PyObject *arg) {
  DNAWindows *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWindows, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAWindows::set_code(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_code(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAWindows.set_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_code(DNAWindows this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWindows_set_code_114_comment =
  "C++ Interface:\n"
  "set_code(DNAWindows this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWindows_set_code_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAWindows::get_code(void)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_get_code_115(PyObject *self) {
  DNAWindows *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAWindows, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNAWindows::get_code(void)
    basic_string< char > return_value = (local_this)->get_code();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAWindows.get_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_code(DNAWindows this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWindows_get_code_115_comment =
  "C++ Interface:\n"
  "get_code(DNAWindows this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWindows_get_code_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAWindows::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_get_class_type_116(PyObject *) {

  // 1-static TypeHandle DNAWindows::get_class_type(void)
  TypeHandle result = DNAWindows::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAWindows_get_class_type_116_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAWindows_get_class_type_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAWindows::DNAWindows(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAWindows(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAWindows::DNAWindows(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAWindows", keyword_list, &param0_str, &param0_len)) {
    DNAWindows *return_value = new DNAWindows(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAWindows, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAWindows(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAWindows(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAWindows(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAWindows(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAWindows) {
    printf("DNAWindows ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAWindows *local_this = (DNAWindows *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAWindows) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAWindows(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAWindows) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNAWindows*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAWindows*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNACornice
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNACornice::set_color(LVecBase4f value)
 *******************************************************************/
static PyObject *Dtool_DNACornice_set_color_119(PyObject *self, PyObject *arg) {
  DNACornice *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNACornice, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNACornice::set_color(LVecBase4f value)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "DNACornice.set_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_color(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNACornice.set_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_color(DNACornice this, const LVecBase4f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNACornice_set_color_119_comment =
  "C++ Interface:\n"
  "set_color(DNACornice this, const LVecBase4f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNACornice_set_color_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNACornice::get_color(void)
 *******************************************************************/
static PyObject *Dtool_DNACornice_get_color_120(PyObject *self) {
  DNACornice *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNACornice, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f DNACornice::get_color(void)
    LVecBase4f result = (local_this)->get_color();
    LVecBase4f *return_value = new LVecBase4f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNACornice.get_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_color(DNACornice this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNACornice_get_color_120_comment =
  "C++ Interface:\n"
  "get_color(DNACornice this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNACornice_get_color_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNACornice::set_code(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNACornice_set_code_121(PyObject *self, PyObject *arg) {
  DNACornice *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNACornice, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNACornice::set_code(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_code(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNACornice.set_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_code(DNACornice this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNACornice_set_code_121_comment =
  "C++ Interface:\n"
  "set_code(DNACornice this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNACornice_set_code_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNACornice::get_code(void)
 *******************************************************************/
static PyObject *Dtool_DNACornice_get_code_122(PyObject *self) {
  DNACornice *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNACornice, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNACornice::get_code(void)
    basic_string< char > return_value = (local_this)->get_code();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNACornice.get_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_code(DNACornice this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNACornice_get_code_122_comment =
  "C++ Interface:\n"
  "get_code(DNACornice this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNACornice_get_code_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNACornice::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNACornice_get_class_type_123(PyObject *) {

  // 1-static TypeHandle DNACornice::get_class_type(void)
  TypeHandle result = DNACornice::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNACornice_get_class_type_123_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNACornice_get_class_type_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNACornice::DNACornice(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNACornice(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNACornice::DNACornice(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNACornice", keyword_list, &param0_str, &param0_len)) {
    DNACornice *return_value = new DNACornice(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNACornice, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNACornice(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNACornice(PyObject *self, PyObject *args) {
  return Dtool_Init_DNACornice(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNACornice(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNACornice) {
    printf("DNACornice ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNACornice *local_this = (DNACornice *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNACornice) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNACornice(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNACornice) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNACornice*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNACornice*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNALandmarkBuilding
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNALandmarkBuilding::set_wall_color(LVecBase4f value)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_set_wall_color_126(PyObject *self, PyObject *arg) {
  DNALandmarkBuilding *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNALandmarkBuilding, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNALandmarkBuilding::set_wall_color(LVecBase4f value)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "DNALandmarkBuilding.set_wall_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_wall_color(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNALandmarkBuilding.set_wall_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_wall_color(DNALandmarkBuilding this, const LVecBase4f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNALandmarkBuilding_set_wall_color_126_comment =
  "C++ Interface:\n"
  "set_wall_color(DNALandmarkBuilding this, const LVecBase4f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNALandmarkBuilding_set_wall_color_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNALandmarkBuilding::get_wall_color(void)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_get_wall_color_127(PyObject *self) {
  DNALandmarkBuilding *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNALandmarkBuilding, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f DNALandmarkBuilding::get_wall_color(void)
    LVecBase4f result = (local_this)->get_wall_color();
    LVecBase4f *return_value = new LVecBase4f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNALandmarkBuilding.get_wall_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_wall_color(DNALandmarkBuilding this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNALandmarkBuilding_get_wall_color_127_comment =
  "C++ Interface:\n"
  "get_wall_color(DNALandmarkBuilding this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNALandmarkBuilding_get_wall_color_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNALandmarkBuilding::set_code(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_set_code_128(PyObject *self, PyObject *arg) {
  DNALandmarkBuilding *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNALandmarkBuilding, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNALandmarkBuilding::set_code(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_code(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNALandmarkBuilding.set_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_code(DNALandmarkBuilding this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNALandmarkBuilding_set_code_128_comment =
  "C++ Interface:\n"
  "set_code(DNALandmarkBuilding this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNALandmarkBuilding_set_code_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNALandmarkBuilding::get_code(void)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_get_code_129(PyObject *self) {
  DNALandmarkBuilding *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNALandmarkBuilding, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNALandmarkBuilding::get_code(void)
    basic_string< char > return_value = (local_this)->get_code();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNALandmarkBuilding.get_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_code(DNALandmarkBuilding this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNALandmarkBuilding_get_code_129_comment =
  "C++ Interface:\n"
  "get_code(DNALandmarkBuilding this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNALandmarkBuilding_get_code_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNALandmarkBuilding::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_get_class_type_130(PyObject *) {

  // 1-static TypeHandle DNALandmarkBuilding::get_class_type(void)
  TypeHandle result = DNALandmarkBuilding::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNALandmarkBuilding_get_class_type_130_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNALandmarkBuilding_get_class_type_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNALandmarkBuilding::DNALandmarkBuilding(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNALandmarkBuilding(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNALandmarkBuilding::DNALandmarkBuilding(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNALandmarkBuilding", keyword_list, &param0_str, &param0_len)) {
    DNALandmarkBuilding *return_value = new DNALandmarkBuilding(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNALandmarkBuilding, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNALandmarkBuilding(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNALandmarkBuilding(PyObject *self, PyObject *args) {
  return Dtool_Init_DNALandmarkBuilding(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNALandmarkBuilding(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNALandmarkBuilding) {
    printf("DNALandmarkBuilding ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNALandmarkBuilding *local_this = (DNALandmarkBuilding *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNALandmarkBuilding) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNALandmarkBuilding(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNALandmarkBuilding) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNALandmarkBuilding*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNALandmarkBuilding*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNALandmarkBuilding*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNAAnimProp
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAAnimProp::set_anim_name(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNAAnimProp_set_anim_name_133(PyObject *self, PyObject *arg) {
  DNAAnimProp *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAAnimProp, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAAnimProp::set_anim_name(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_anim_name(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAAnimProp.set_anim_name() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_anim_name(DNAAnimProp this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAAnimProp_set_anim_name_133_comment =
  "C++ Interface:\n"
  "set_anim_name(DNAAnimProp this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAAnimProp_set_anim_name_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAAnimProp::get_anim_name(void)
 *******************************************************************/
static PyObject *Dtool_DNAAnimProp_get_anim_name_134(PyObject *self) {
  DNAAnimProp *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAAnimProp, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNAAnimProp::get_anim_name(void)
    basic_string< char > return_value = (local_this)->get_anim_name();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAAnimProp.get_anim_name() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_anim_name(DNAAnimProp this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAAnimProp_get_anim_name_134_comment =
  "C++ Interface:\n"
  "get_anim_name(DNAAnimProp this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAAnimProp_get_anim_name_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAAnimProp::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAAnimProp_get_class_type_135(PyObject *) {

  // 1-static TypeHandle DNAAnimProp::get_class_type(void)
  TypeHandle result = DNAAnimProp::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAAnimProp_get_class_type_135_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAAnimProp_get_class_type_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAAnimProp::DNAAnimProp(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAAnimProp(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAAnimProp::DNAAnimProp(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAAnimProp", keyword_list, &param0_str, &param0_len)) {
    DNAAnimProp *return_value = new DNAAnimProp(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAAnimProp, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAAnimProp(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAAnimProp(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAAnimProp(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAAnimProp(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAAnimProp) {
    printf("DNAAnimProp ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAAnimProp *local_this = (DNAAnimProp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAAnimProp) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *)(DNAProp *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *)(DNAProp *) local_this;
  }
  if (requested_type == &Dtool_DNAProp) {
    return (DNAProp *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *)(DNAProp *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAAnimProp(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAAnimProp) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNAAnimProp*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNAAnimProp*)other_this;
  }
  if (from_type == &Dtool_DNAProp) {
    DNAProp* other_this = (DNAProp*)from_this;
    return (DNAAnimProp*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAAnimProp*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNAInteractiveProp
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAInteractiveProp::set_cell_id(short int value)
 *******************************************************************/
static PyObject *Dtool_DNAInteractiveProp_set_cell_id_138(PyObject *self, PyObject *arg) {
  DNAInteractiveProp *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAInteractiveProp, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAInteractiveProp::set_cell_id(short int value)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      (local_this)->set_cell_id((short int)param1);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAInteractiveProp.set_cell_id() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_cell_id(DNAInteractiveProp this, int value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAInteractiveProp_set_cell_id_138_comment =
  "C++ Interface:\n"
  "set_cell_id(DNAInteractiveProp this, int value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAInteractiveProp_set_cell_id_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline short int DNAInteractiveProp::get_cell_id(void)
 *******************************************************************/
static PyObject *Dtool_DNAInteractiveProp_get_cell_id_139(PyObject *self) {
  DNAInteractiveProp *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAInteractiveProp, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline short int DNAInteractiveProp::get_cell_id(void)
    short int return_value = (local_this)->get_cell_id();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromLong(return_value);
#else
      return PyInt_FromLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAInteractiveProp.get_cell_id() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_cell_id(DNAInteractiveProp this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAInteractiveProp_get_cell_id_139_comment =
  "C++ Interface:\n"
  "get_cell_id(DNAInteractiveProp this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAInteractiveProp_get_cell_id_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAInteractiveProp::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAInteractiveProp_get_class_type_140(PyObject *) {

  // 1-static TypeHandle DNAInteractiveProp::get_class_type(void)
  TypeHandle result = DNAInteractiveProp::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAInteractiveProp_get_class_type_140_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAInteractiveProp_get_class_type_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAInteractiveProp::DNAInteractiveProp(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAInteractiveProp(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAInteractiveProp::DNAInteractiveProp(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAInteractiveProp", keyword_list, &param0_str, &param0_len)) {
    DNAInteractiveProp *return_value = new DNAInteractiveProp(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAInteractiveProp, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAInteractiveProp(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAInteractiveProp(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAInteractiveProp(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAInteractiveProp(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAInteractiveProp) {
    printf("DNAInteractiveProp ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAInteractiveProp *local_this = (DNAInteractiveProp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAInteractiveProp) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAAnimProp) {
    return (DNAAnimProp *) local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *)(DNAProp *)(DNAAnimProp *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *)(DNAProp *)(DNAAnimProp *) local_this;
  }
  if (requested_type == &Dtool_DNAProp) {
    return (DNAProp *)(DNAAnimProp *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *)(DNAProp *)(DNAAnimProp *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAInteractiveProp(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAInteractiveProp) {
    return from_this;
  }
  if (from_type == &Dtool_DNAAnimProp) {
    DNAAnimProp* other_this = (DNAAnimProp*)from_this;
    return (DNAInteractiveProp*)other_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNAInteractiveProp*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNAInteractiveProp*)other_this;
  }
  if (from_type == &Dtool_DNAProp) {
    DNAProp* other_this = (DNAProp*)from_this;
    return (DNAInteractiveProp*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAInteractiveProp*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNAAnimBuilding
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAAnimBuilding::set_anim_name(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNAAnimBuilding_set_anim_name_143(PyObject *self, PyObject *arg) {
  DNAAnimBuilding *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAAnimBuilding, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAAnimBuilding::set_anim_name(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_anim_name(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAAnimBuilding.set_anim_name() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_anim_name(DNAAnimBuilding this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAAnimBuilding_set_anim_name_143_comment =
  "C++ Interface:\n"
  "set_anim_name(DNAAnimBuilding this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAAnimBuilding_set_anim_name_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAAnimBuilding::get_anim_name(void)
 *******************************************************************/
static PyObject *Dtool_DNAAnimBuilding_get_anim_name_144(PyObject *self) {
  DNAAnimBuilding *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAAnimBuilding, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNAAnimBuilding::get_anim_name(void)
    basic_string< char > return_value = (local_this)->get_anim_name();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAAnimBuilding.get_anim_name() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_anim_name(DNAAnimBuilding this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAAnimBuilding_get_anim_name_144_comment =
  "C++ Interface:\n"
  "get_anim_name(DNAAnimBuilding this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAAnimBuilding_get_anim_name_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAAnimBuilding::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAAnimBuilding_get_class_type_145(PyObject *) {

  // 1-static TypeHandle DNAAnimBuilding::get_class_type(void)
  TypeHandle result = DNAAnimBuilding::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAAnimBuilding_get_class_type_145_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAAnimBuilding_get_class_type_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAAnimBuilding::DNAAnimBuilding(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAAnimBuilding(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAAnimBuilding::DNAAnimBuilding(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAAnimBuilding", keyword_list, &param0_str, &param0_len)) {
    DNAAnimBuilding *return_value = new DNAAnimBuilding(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAAnimBuilding, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAAnimBuilding(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAAnimBuilding(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAAnimBuilding(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAAnimBuilding(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAAnimBuilding) {
    printf("DNAAnimBuilding ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAAnimBuilding *local_this = (DNAAnimBuilding *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAAnimBuilding) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *)(DNALandmarkBuilding *) local_this;
  }
  if (requested_type == &Dtool_DNALandmarkBuilding) {
    return (DNALandmarkBuilding *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *)(DNALandmarkBuilding *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *)(DNALandmarkBuilding *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAAnimBuilding(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAAnimBuilding) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNAAnimBuilding*)other_this;
  }
  if (from_type == &Dtool_DNALandmarkBuilding) {
    DNALandmarkBuilding* other_this = (DNALandmarkBuilding*)from_this;
    return (DNAAnimBuilding*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNAAnimBuilding*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAAnimBuilding*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNADoor
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static void DNADoor::setup_door(NodePath &door_np, NodePath &parent_np, NodePath &door_origin, DNAStorage *store, short int block, LVecBase4f &color)
 *******************************************************************/
static PyObject *Dtool_DNADoor_setup_door_148(PyObject *, PyObject *args, PyObject *kwds) {
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      // 1-static void DNADoor::setup_door(NodePath &door_np, NodePath &parent_np, NodePath &door_origin, DNAStorage *store, short int block, LVecBase4f &color)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      int param4;
      PyObject *param5;
      static char *keyword_list[] = {(char *)"door_np", (char *)"parent_np", (char *)"door_origin", (char *)"store", (char *)"block", (char *)"color", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOiO:setup_door", keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "DNADoor.setup_door", 0, coerced_ptr, report_errors);
NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "DNADoor.setup_door", 0, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNADoor.setup_door", 0, coerced_ptr, report_errors);
DNAStorage *param3_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DNAStorage, 3, "DNADoor.setup_door", 0, coerced_ptr, report_errors);
LVecBase4f *param5_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase4f, 5, "DNADoor.setup_door", 0, coerced_ptr, report_errors);

        if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL && param5_this != NULL) {
          DNADoor::setup_door(*param0_this, *param1_this, *param2_this, param3_this, (short int)param4, *param5_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "setup_door(NodePath door_np, NodePath parent_np, NodePath door_origin, DNAStorage store, int block, LVecBase4f color)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNADoor_setup_door_148_comment =
  "C++ Interface:\n"
  "setup_door(NodePath door_np, NodePath parent_np, NodePath door_origin, DNAStorage store, int block, LVecBase4f color)\n"
  "\n"
  "";
#else
static const char *Dtool_DNADoor_setup_door_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNADoor::set_color(LVecBase4f value)
 *******************************************************************/
static PyObject *Dtool_DNADoor_set_color_149(PyObject *self, PyObject *arg) {
  DNADoor *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNADoor, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNADoor::set_color(LVecBase4f value)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "DNADoor.set_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_color(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNADoor.set_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_color(DNADoor this, const LVecBase4f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNADoor_set_color_149_comment =
  "C++ Interface:\n"
  "set_color(DNADoor this, const LVecBase4f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNADoor_set_color_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNADoor::get_color(void)
 *******************************************************************/
static PyObject *Dtool_DNADoor_get_color_150(PyObject *self) {
  DNADoor *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNADoor, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f DNADoor::get_color(void)
    LVecBase4f result = (local_this)->get_color();
    LVecBase4f *return_value = new LVecBase4f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNADoor.get_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_color(DNADoor this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNADoor_get_color_150_comment =
  "C++ Interface:\n"
  "get_color(DNADoor this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNADoor_get_color_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNADoor::set_code(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNADoor_set_code_151(PyObject *self, PyObject *arg) {
  DNADoor *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNADoor, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNADoor::set_code(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_code(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNADoor.set_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_code(DNADoor this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNADoor_set_code_151_comment =
  "C++ Interface:\n"
  "set_code(DNADoor this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNADoor_set_code_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNADoor::get_code(void)
 *******************************************************************/
static PyObject *Dtool_DNADoor_get_code_152(PyObject *self) {
  DNADoor *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNADoor, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNADoor::get_code(void)
    basic_string< char > return_value = (local_this)->get_code();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNADoor.get_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_code(DNADoor this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNADoor_get_code_152_comment =
  "C++ Interface:\n"
  "get_code(DNADoor this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNADoor_get_code_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNADoor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNADoor_get_class_type_153(PyObject *) {

  // 1-static TypeHandle DNADoor::get_class_type(void)
  TypeHandle result = DNADoor::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNADoor_get_class_type_153_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNADoor_get_class_type_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNADoor::DNADoor(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNADoor(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNADoor::DNADoor(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNADoor", keyword_list, &param0_str, &param0_len)) {
    DNADoor *return_value = new DNADoor(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNADoor, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNADoor(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNADoor(PyObject *self, PyObject *args) {
  return Dtool_Init_DNADoor(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNADoor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNADoor) {
    printf("DNADoor ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNADoor *local_this = (DNADoor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNADoor) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNADoor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNADoor) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNADoor*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNADoor*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNAFlatDoor
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAFlatDoor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAFlatDoor_get_class_type_156(PyObject *) {

  // 1-static TypeHandle DNAFlatDoor::get_class_type(void)
  TypeHandle result = DNAFlatDoor::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAFlatDoor_get_class_type_156_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAFlatDoor_get_class_type_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAFlatDoor::DNAFlatDoor(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAFlatDoor(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAFlatDoor::DNAFlatDoor(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAFlatDoor", keyword_list, &param0_str, &param0_len)) {
    DNAFlatDoor *return_value = new DNAFlatDoor(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAFlatDoor, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAFlatDoor(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAFlatDoor(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAFlatDoor(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAFlatDoor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAFlatDoor) {
    printf("DNAFlatDoor ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAFlatDoor *local_this = (DNAFlatDoor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAFlatDoor) {
    return local_this;
  }
  if (requested_type == &Dtool_DNADoor) {
    return (DNADoor *) local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNADoor *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNADoor *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAFlatDoor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAFlatDoor) {
    return from_this;
  }
  if (from_type == &Dtool_DNADoor) {
    DNADoor* other_this = (DNADoor*)from_this;
    return (DNAFlatDoor*)other_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNAFlatDoor*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAFlatDoor*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNAStreet
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_code(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_code_159(PyObject *self, PyObject *arg) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAStreet::set_code(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_code(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.set_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_code(DNAStreet this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_set_code_159_comment =
  "C++ Interface:\n"
  "set_code(DNAStreet this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_set_code_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAStreet::get_code(void)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_code_160(PyObject *self) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNAStreet::get_code(void)
    basic_string< char > return_value = (local_this)->get_code();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.get_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_code(DNAStreet this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_get_code_160_comment =
  "C++ Interface:\n"
  "get_code(DNAStreet this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_get_code_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_street_texture(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_street_texture_161(PyObject *self, PyObject *arg) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAStreet::set_street_texture(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_street_texture(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.set_street_texture() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_street_texture(DNAStreet this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_set_street_texture_161_comment =
  "C++ Interface:\n"
  "set_street_texture(DNAStreet this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_set_street_texture_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAStreet::get_street_texture(void)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_street_texture_162(PyObject *self) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNAStreet::get_street_texture(void)
    basic_string< char > return_value = (local_this)->get_street_texture();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.get_street_texture() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_street_texture(DNAStreet this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_get_street_texture_162_comment =
  "C++ Interface:\n"
  "get_street_texture(DNAStreet this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_get_street_texture_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_sidewalk_texture(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_sidewalk_texture_163(PyObject *self, PyObject *arg) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAStreet::set_sidewalk_texture(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_sidewalk_texture(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.set_sidewalk_texture() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_sidewalk_texture(DNAStreet this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_set_sidewalk_texture_163_comment =
  "C++ Interface:\n"
  "set_sidewalk_texture(DNAStreet this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_set_sidewalk_texture_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAStreet::get_sidewalk_texture(void)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_sidewalk_texture_164(PyObject *self) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNAStreet::get_sidewalk_texture(void)
    basic_string< char > return_value = (local_this)->get_sidewalk_texture();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.get_sidewalk_texture() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_sidewalk_texture(DNAStreet this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_get_sidewalk_texture_164_comment =
  "C++ Interface:\n"
  "get_sidewalk_texture(DNAStreet this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_get_sidewalk_texture_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_curb_texture(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_curb_texture_165(PyObject *self, PyObject *arg) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAStreet::set_curb_texture(basic_string< char > const &value)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_curb_texture(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.set_curb_texture() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_curb_texture(DNAStreet this, str value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_set_curb_texture_165_comment =
  "C++ Interface:\n"
  "set_curb_texture(DNAStreet this, str value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_set_curb_texture_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAStreet::get_curb_texture(void)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_curb_texture_166(PyObject *self) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline basic_string< char > DNAStreet::get_curb_texture(void)
    basic_string< char > return_value = (local_this)->get_curb_texture();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.get_curb_texture() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_curb_texture(DNAStreet this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_get_curb_texture_166_comment =
  "C++ Interface:\n"
  "get_curb_texture(DNAStreet this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_get_curb_texture_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_street_color(LVecBase4f value)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_street_color_167(PyObject *self, PyObject *arg) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNAStreet::set_street_color(LVecBase4f value)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "DNAStreet.set_street_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_street_color(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAStreet.set_street_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_street_color(DNAStreet this, const LVecBase4f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_set_street_color_167_comment =
  "C++ Interface:\n"
  "set_street_color(DNAStreet this, const LVecBase4f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_set_street_color_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAStreet::get_street_color(void)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_street_color_168(PyObject *self) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f DNAStreet::get_street_color(void)
    LVecBase4f result = (local_this)->get_street_color();
    LVecBase4f *return_value = new LVecBase4f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.get_street_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_street_color(DNAStreet this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_get_street_color_168_comment =
  "C++ Interface:\n"
  "get_street_color(DNAStreet this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_get_street_color_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_sidewalk_color(LVecBase4f value)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_sidewalk_color_169(PyObject *self, PyObject *arg) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNAStreet::set_sidewalk_color(LVecBase4f value)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "DNAStreet.set_sidewalk_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_sidewalk_color(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAStreet.set_sidewalk_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_sidewalk_color(DNAStreet this, const LVecBase4f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_set_sidewalk_color_169_comment =
  "C++ Interface:\n"
  "set_sidewalk_color(DNAStreet this, const LVecBase4f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_set_sidewalk_color_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAStreet::get_sidewalk_color(void)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_sidewalk_color_170(PyObject *self) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f DNAStreet::get_sidewalk_color(void)
    LVecBase4f result = (local_this)->get_sidewalk_color();
    LVecBase4f *return_value = new LVecBase4f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.get_sidewalk_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_sidewalk_color(DNAStreet this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_get_sidewalk_color_170_comment =
  "C++ Interface:\n"
  "get_sidewalk_color(DNAStreet this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_get_sidewalk_color_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_curb_color(LVecBase4f value)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_curb_color_171(PyObject *self, PyObject *arg) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNAStreet::set_curb_color(LVecBase4f value)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "DNAStreet.set_curb_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_curb_color(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAStreet.set_curb_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_curb_color(DNAStreet this, const LVecBase4f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_set_curb_color_171_comment =
  "C++ Interface:\n"
  "set_curb_color(DNAStreet this, const LVecBase4f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_set_curb_color_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAStreet::get_curb_color(void)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_curb_color_172(PyObject *self) {
  DNAStreet *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStreet, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f DNAStreet::get_curb_color(void)
    LVecBase4f result = (local_this)->get_curb_color();
    LVecBase4f *return_value = new LVecBase4f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStreet.get_curb_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_curb_color(DNAStreet this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_get_curb_color_172_comment =
  "C++ Interface:\n"
  "get_curb_color(DNAStreet this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_get_curb_color_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAStreet::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_class_type_173(PyObject *) {

  // 1-static TypeHandle DNAStreet::get_class_type(void)
  TypeHandle result = DNAStreet::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStreet_get_class_type_173_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStreet_get_class_type_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAStreet::DNAStreet(basic_string< char > const &name)
 *******************************************************************/
int Dtool_Init_DNAStreet(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-DNAStreet::DNAStreet(basic_string< char > const &name)
  char *param0_str;
  Py_ssize_t param0_len;
  static char *keyword_list[] = {(char *)"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DNAStreet", keyword_list, &param0_str, &param0_len)) {
    DNAStreet *return_value = new DNAStreet(basic_string<char>(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return -1;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return -1;
      }
#endif
      return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAStreet, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAStreet(str name)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAStreet(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAStreet(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAStreet(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAStreet) {
    printf("DNAStreet ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAStreet *local_this = (DNAStreet *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAStreet) {
    return local_this;
  }
  if (requested_type == &Dtool_DNAGroup) {
    return (DNAGroup *)(DNANode *) local_this;
  }
  if (requested_type == &Dtool_DNANode) {
    return (DNANode *) local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *)(DNAGroup *)(DNANode *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAStreet(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAStreet) {
    return from_this;
  }
  if (from_type == &Dtool_DNAGroup) {
    DNAGroup* other_this = (DNAGroup*)from_this;
    return (DNAStreet*)other_this;
  }
  if (from_type == &Dtool_DNANode) {
    DNANode* other_this = (DNANode*)from_this;
    return (DNAStreet*)other_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNAStreet*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Py Init Code For .. DNAGroup | DNAGroup
//********************************************************************
PyMethodDef Dtool_Methods_DNAGroup[] = {
  { "add", (PyCFunction) &Dtool_DNAGroup_add_4, METH_O, (char *) Dtool_DNAGroup_add_4_comment},
  { "at", (PyCFunction) &Dtool_DNAGroup_at_5, METH_O, (char *) Dtool_DNAGroup_at_5_comment},
  { "get_num_children", (PyCFunction) &Dtool_DNAGroup_get_num_children_6, METH_NOARGS, (char *) Dtool_DNAGroup_get_num_children_6_comment},
  { "getNumChildren", (PyCFunction) &Dtool_DNAGroup_get_num_children_6, METH_NOARGS, (char *) Dtool_DNAGroup_get_num_children_6_comment},
  { "clear_parent", (PyCFunction) &Dtool_DNAGroup_clear_parent_7, METH_NOARGS, (char *) Dtool_DNAGroup_clear_parent_7_comment},
  { "clearParent", (PyCFunction) &Dtool_DNAGroup_clear_parent_7, METH_NOARGS, (char *) Dtool_DNAGroup_clear_parent_7_comment},
  { "set_name", (PyCFunction) &Dtool_DNAGroup_set_name_8, METH_O, (char *) Dtool_DNAGroup_set_name_8_comment},
  { "setName", (PyCFunction) &Dtool_DNAGroup_set_name_8, METH_O, (char *) Dtool_DNAGroup_set_name_8_comment},
  { "get_name", (PyCFunction) &Dtool_DNAGroup_get_name_9, METH_NOARGS, (char *) Dtool_DNAGroup_get_name_9_comment},
  { "getName", (PyCFunction) &Dtool_DNAGroup_get_name_9, METH_NOARGS, (char *) Dtool_DNAGroup_get_name_9_comment},
  { "set_parent", (PyCFunction) &Dtool_DNAGroup_set_parent_10, METH_O, (char *) Dtool_DNAGroup_set_parent_10_comment},
  { "setParent", (PyCFunction) &Dtool_DNAGroup_set_parent_10, METH_O, (char *) Dtool_DNAGroup_set_parent_10_comment},
  { "get_parent", (PyCFunction) &Dtool_DNAGroup_get_parent_11, METH_NOARGS, (char *) Dtool_DNAGroup_get_parent_11_comment},
  { "getParent", (PyCFunction) &Dtool_DNAGroup_get_parent_11, METH_NOARGS, (char *) Dtool_DNAGroup_get_parent_11_comment},
  { "set_vis_group", (PyCFunction) &Dtool_DNAGroup_set_vis_group_12, METH_O, (char *) Dtool_DNAGroup_set_vis_group_12_comment},
  { "setVisGroup", (PyCFunction) &Dtool_DNAGroup_set_vis_group_12, METH_O, (char *) Dtool_DNAGroup_set_vis_group_12_comment},
  { "get_vis_group", (PyCFunction) &Dtool_DNAGroup_get_vis_group_13, METH_NOARGS, (char *) Dtool_DNAGroup_get_vis_group_13_comment},
  { "getVisGroup", (PyCFunction) &Dtool_DNAGroup_get_vis_group_13, METH_NOARGS, (char *) Dtool_DNAGroup_get_vis_group_13_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNAGroup_get_class_type_14, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAGroup_get_class_type_14_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAGroup_get_class_type_14, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAGroup_get_class_type_14_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAGroup(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypedObject._Dtool_ClassInit(NULL);
    Dtool_DNAGroup.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_TypedObject.As_PyTypeObject());
    Dtool_DNAGroup.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAGroup.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAGroup.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAGroup.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAGroup)");
      printf("Error in PyType_Ready(DNAGroup)");
      return;
    }
    Py_INCREF(&Dtool_DNAGroup.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAGroup, DNAGroup::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAGroup.As_PyTypeObject());
    PyModule_AddObject(module, "DNAGroup", (PyObject *)&Dtool_DNAGroup.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNABattleCell | DNABattleCell
//********************************************************************
PyMethodDef Dtool_Methods_DNABattleCell[] = {
  { "set_width_height", (PyCFunction) &Dtool_DNABattleCell_set_width_height_17, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNABattleCell_set_width_height_17_comment},
  { "setWidthHeight", (PyCFunction) &Dtool_DNABattleCell_set_width_height_17, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNABattleCell_set_width_height_17_comment},
  { "set_width", (PyCFunction) &Dtool_DNABattleCell_set_width_18, METH_O, (char *) Dtool_DNABattleCell_set_width_18_comment},
  { "setWidth", (PyCFunction) &Dtool_DNABattleCell_set_width_18, METH_O, (char *) Dtool_DNABattleCell_set_width_18_comment},
  { "get_width", (PyCFunction) &Dtool_DNABattleCell_get_width_19, METH_NOARGS, (char *) Dtool_DNABattleCell_get_width_19_comment},
  { "getWidth", (PyCFunction) &Dtool_DNABattleCell_get_width_19, METH_NOARGS, (char *) Dtool_DNABattleCell_get_width_19_comment},
  { "set_height", (PyCFunction) &Dtool_DNABattleCell_set_height_20, METH_O, (char *) Dtool_DNABattleCell_set_height_20_comment},
  { "setHeight", (PyCFunction) &Dtool_DNABattleCell_set_height_20, METH_O, (char *) Dtool_DNABattleCell_set_height_20_comment},
  { "get_height", (PyCFunction) &Dtool_DNABattleCell_get_height_21, METH_NOARGS, (char *) Dtool_DNABattleCell_get_height_21_comment},
  { "getHeight", (PyCFunction) &Dtool_DNABattleCell_get_height_21, METH_NOARGS, (char *) Dtool_DNABattleCell_get_height_21_comment},
  { "set_pos", (PyCFunction) &Dtool_DNABattleCell_set_pos_22, METH_O, (char *) Dtool_DNABattleCell_set_pos_22_comment},
  { "setPos", (PyCFunction) &Dtool_DNABattleCell_set_pos_22, METH_O, (char *) Dtool_DNABattleCell_set_pos_22_comment},
  { "get_pos", (PyCFunction) &Dtool_DNABattleCell_get_pos_23, METH_NOARGS, (char *) Dtool_DNABattleCell_get_pos_23_comment},
  { "getPos", (PyCFunction) &Dtool_DNABattleCell_get_pos_23, METH_NOARGS, (char *) Dtool_DNABattleCell_get_pos_23_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNABattleCell_get_class_type_24, METH_NOARGS | METH_STATIC, (char *) Dtool_DNABattleCell_get_class_type_24_comment},
  { "getClassType", (PyCFunction) &Dtool_DNABattleCell_get_class_type_24, METH_NOARGS | METH_STATIC, (char *) Dtool_DNABattleCell_get_class_type_24_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNABattleCell(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypedObject._Dtool_ClassInit(NULL);
    Dtool_DNABattleCell.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_TypedObject.As_PyTypeObject());
    Dtool_DNABattleCell.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNABattleCell.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNABattleCell.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNABattleCell.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNABattleCell)");
      printf("Error in PyType_Ready(DNABattleCell)");
      return;
    }
    Py_INCREF(&Dtool_DNABattleCell.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNABattleCell, DNABattleCell::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNABattleCell.As_PyTypeObject());
    PyModule_AddObject(module, "DNABattleCell", (PyObject *)&Dtool_DNABattleCell.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNAVisGroup | DNAVisGroup
//********************************************************************
PyMethodDef Dtool_Methods_DNAVisGroup[] = {
  { "add_visible", (PyCFunction) &Dtool_DNAVisGroup_add_visible_27, METH_O, (char *) Dtool_DNAVisGroup_add_visible_27_comment},
  { "addVisible", (PyCFunction) &Dtool_DNAVisGroup_add_visible_27, METH_O, (char *) Dtool_DNAVisGroup_add_visible_27_comment},
  { "remove_visible", (PyCFunction) &Dtool_DNAVisGroup_remove_visible_28, METH_O, (char *) Dtool_DNAVisGroup_remove_visible_28_comment},
  { "removeVisible", (PyCFunction) &Dtool_DNAVisGroup_remove_visible_28, METH_O, (char *) Dtool_DNAVisGroup_remove_visible_28_comment},
  { "get_num_visibles", (PyCFunction) &Dtool_DNAVisGroup_get_num_visibles_29, METH_NOARGS, (char *) Dtool_DNAVisGroup_get_num_visibles_29_comment},
  { "getNumVisibles", (PyCFunction) &Dtool_DNAVisGroup_get_num_visibles_29, METH_NOARGS, (char *) Dtool_DNAVisGroup_get_num_visibles_29_comment},
  { "get_visible", (PyCFunction) &Dtool_DNAVisGroup_get_visible_30, METH_O, (char *) Dtool_DNAVisGroup_get_visible_30_comment},
  { "getVisible", (PyCFunction) &Dtool_DNAVisGroup_get_visible_30, METH_O, (char *) Dtool_DNAVisGroup_get_visible_30_comment},
  { "add_suit_edge", (PyCFunction) &Dtool_DNAVisGroup_add_suit_edge_31, METH_O, (char *) Dtool_DNAVisGroup_add_suit_edge_31_comment},
  { "addSuitEdge", (PyCFunction) &Dtool_DNAVisGroup_add_suit_edge_31, METH_O, (char *) Dtool_DNAVisGroup_add_suit_edge_31_comment},
  { "remove_suit_edge", (PyCFunction) &Dtool_DNAVisGroup_remove_suit_edge_32, METH_O, (char *) Dtool_DNAVisGroup_remove_suit_edge_32_comment},
  { "removeSuitEdge", (PyCFunction) &Dtool_DNAVisGroup_remove_suit_edge_32, METH_O, (char *) Dtool_DNAVisGroup_remove_suit_edge_32_comment},
  { "get_num_suit_edges", (PyCFunction) &Dtool_DNAVisGroup_get_num_suit_edges_33, METH_NOARGS, (char *) Dtool_DNAVisGroup_get_num_suit_edges_33_comment},
  { "getNumSuitEdges", (PyCFunction) &Dtool_DNAVisGroup_get_num_suit_edges_33, METH_NOARGS, (char *) Dtool_DNAVisGroup_get_num_suit_edges_33_comment},
  { "get_suit_edge", (PyCFunction) &Dtool_DNAVisGroup_get_suit_edge_34, METH_O, (char *) Dtool_DNAVisGroup_get_suit_edge_34_comment},
  { "getSuitEdge", (PyCFunction) &Dtool_DNAVisGroup_get_suit_edge_34, METH_O, (char *) Dtool_DNAVisGroup_get_suit_edge_34_comment},
  { "add_battle_cell", (PyCFunction) &Dtool_DNAVisGroup_add_battle_cell_35, METH_O, (char *) Dtool_DNAVisGroup_add_battle_cell_35_comment},
  { "addBattleCell", (PyCFunction) &Dtool_DNAVisGroup_add_battle_cell_35, METH_O, (char *) Dtool_DNAVisGroup_add_battle_cell_35_comment},
  { "remove_battle_cell", (PyCFunction) &Dtool_DNAVisGroup_remove_battle_cell_36, METH_O, (char *) Dtool_DNAVisGroup_remove_battle_cell_36_comment},
  { "removeBattleCell", (PyCFunction) &Dtool_DNAVisGroup_remove_battle_cell_36, METH_O, (char *) Dtool_DNAVisGroup_remove_battle_cell_36_comment},
  { "get_num_battle_cells", (PyCFunction) &Dtool_DNAVisGroup_get_num_battle_cells_37, METH_NOARGS, (char *) Dtool_DNAVisGroup_get_num_battle_cells_37_comment},
  { "getNumBattleCells", (PyCFunction) &Dtool_DNAVisGroup_get_num_battle_cells_37, METH_NOARGS, (char *) Dtool_DNAVisGroup_get_num_battle_cells_37_comment},
  { "get_battle_cell", (PyCFunction) &Dtool_DNAVisGroup_get_battle_cell_38, METH_O, (char *) Dtool_DNAVisGroup_get_battle_cell_38_comment},
  { "getBattleCell", (PyCFunction) &Dtool_DNAVisGroup_get_battle_cell_38, METH_O, (char *) Dtool_DNAVisGroup_get_battle_cell_38_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNAVisGroup_get_class_type_39, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAVisGroup_get_class_type_39_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAVisGroup_get_class_type_39, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAVisGroup_get_class_type_39_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAVisGroup(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNAGroup._Dtool_ClassInit(NULL);
    Dtool_DNAVisGroup.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNAGroup.As_PyTypeObject());
    Dtool_DNAVisGroup.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAVisGroup.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAVisGroup.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAVisGroup.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAVisGroup)");
      printf("Error in PyType_Ready(DNAVisGroup)");
      return;
    }
    Py_INCREF(&Dtool_DNAVisGroup.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAVisGroup, DNAVisGroup::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAVisGroup.As_PyTypeObject());
    PyModule_AddObject(module, "DNAVisGroup", (PyObject *)&Dtool_DNAVisGroup.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNANode | DNANode
//********************************************************************
PyMethodDef Dtool_Methods_DNANode[] = {
  { "set_pos", (PyCFunction) &Dtool_DNANode_set_pos_42, METH_O, (char *) Dtool_DNANode_set_pos_42_comment},
  { "setPos", (PyCFunction) &Dtool_DNANode_set_pos_42, METH_O, (char *) Dtool_DNANode_set_pos_42_comment},
  { "get_pos", (PyCFunction) &Dtool_DNANode_get_pos_43, METH_NOARGS, (char *) Dtool_DNANode_get_pos_43_comment},
  { "getPos", (PyCFunction) &Dtool_DNANode_get_pos_43, METH_NOARGS, (char *) Dtool_DNANode_get_pos_43_comment},
  { "set_hpr", (PyCFunction) &Dtool_DNANode_set_hpr_44, METH_O, (char *) Dtool_DNANode_set_hpr_44_comment},
  { "setHpr", (PyCFunction) &Dtool_DNANode_set_hpr_44, METH_O, (char *) Dtool_DNANode_set_hpr_44_comment},
  { "get_hpr", (PyCFunction) &Dtool_DNANode_get_hpr_45, METH_NOARGS, (char *) Dtool_DNANode_get_hpr_45_comment},
  { "getHpr", (PyCFunction) &Dtool_DNANode_get_hpr_45, METH_NOARGS, (char *) Dtool_DNANode_get_hpr_45_comment},
  { "set_scale", (PyCFunction) &Dtool_DNANode_set_scale_46, METH_O, (char *) Dtool_DNANode_set_scale_46_comment},
  { "setScale", (PyCFunction) &Dtool_DNANode_set_scale_46, METH_O, (char *) Dtool_DNANode_set_scale_46_comment},
  { "get_scale", (PyCFunction) &Dtool_DNANode_get_scale_47, METH_NOARGS, (char *) Dtool_DNANode_get_scale_47_comment},
  { "getScale", (PyCFunction) &Dtool_DNANode_get_scale_47, METH_NOARGS, (char *) Dtool_DNANode_get_scale_47_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNANode_get_class_type_48, METH_NOARGS | METH_STATIC, (char *) Dtool_DNANode_get_class_type_48_comment},
  { "getClassType", (PyCFunction) &Dtool_DNANode_get_class_type_48, METH_NOARGS | METH_STATIC, (char *) Dtool_DNANode_get_class_type_48_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNANode(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNAGroup._Dtool_ClassInit(NULL);
    Dtool_DNANode.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNAGroup.As_PyTypeObject());
    Dtool_DNANode.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNANode.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNANode.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNANode.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNANode)");
      printf("Error in PyType_Ready(DNANode)");
      return;
    }
    Py_INCREF(&Dtool_DNANode.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNANode, DNANode::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNANode.As_PyTypeObject());
    PyModule_AddObject(module, "DNANode", (PyObject *)&Dtool_DNANode.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNAProp | DNAProp
//********************************************************************
PyMethodDef Dtool_Methods_DNAProp[] = {
  { "set_color", (PyCFunction) &Dtool_DNAProp_set_color_51, METH_O, (char *) Dtool_DNAProp_set_color_51_comment},
  { "setColor", (PyCFunction) &Dtool_DNAProp_set_color_51, METH_O, (char *) Dtool_DNAProp_set_color_51_comment},
  { "get_color", (PyCFunction) &Dtool_DNAProp_get_color_52, METH_NOARGS, (char *) Dtool_DNAProp_get_color_52_comment},
  { "getColor", (PyCFunction) &Dtool_DNAProp_get_color_52, METH_NOARGS, (char *) Dtool_DNAProp_get_color_52_comment},
  { "set_code", (PyCFunction) &Dtool_DNAProp_set_code_53, METH_O, (char *) Dtool_DNAProp_set_code_53_comment},
  { "setCode", (PyCFunction) &Dtool_DNAProp_set_code_53, METH_O, (char *) Dtool_DNAProp_set_code_53_comment},
  { "get_code", (PyCFunction) &Dtool_DNAProp_get_code_54, METH_NOARGS, (char *) Dtool_DNAProp_get_code_54_comment},
  { "getCode", (PyCFunction) &Dtool_DNAProp_get_code_54, METH_NOARGS, (char *) Dtool_DNAProp_get_code_54_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNAProp_get_class_type_55, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAProp_get_class_type_55_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAProp_get_class_type_55, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAProp_get_class_type_55_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAProp(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNANode._Dtool_ClassInit(NULL);
    Dtool_DNAProp.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNANode.As_PyTypeObject());
    Dtool_DNAProp.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAProp.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAProp.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAProp.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAProp)");
      printf("Error in PyType_Ready(DNAProp)");
      return;
    }
    Py_INCREF(&Dtool_DNAProp.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAProp, DNAProp::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAProp.As_PyTypeObject());
    PyModule_AddObject(module, "DNAProp", (PyObject *)&Dtool_DNAProp.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNASign | DNASign
//********************************************************************
PyMethodDef Dtool_Methods_DNASign[] = {
  { "get_class_type", (PyCFunction) &Dtool_DNASign_get_class_type_58, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASign_get_class_type_58_comment},
  { "getClassType", (PyCFunction) &Dtool_DNASign_get_class_type_58, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASign_get_class_type_58_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNASign(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNAProp._Dtool_ClassInit(NULL);
    Dtool_DNASign.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNAProp.As_PyTypeObject());
    Dtool_DNASign.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNASign.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNASign.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNASign.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASign)");
      printf("Error in PyType_Ready(DNASign)");
      return;
    }
    Py_INCREF(&Dtool_DNASign.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNASign, DNASign::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNASign.As_PyTypeObject());
    PyModule_AddObject(module, "DNASign", (PyObject *)&Dtool_DNASign.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNASignBaseline | DNASignBaseline
//********************************************************************
PyMethodDef Dtool_Methods_DNASignBaseline[] = {
  { "set_text", (PyCFunction) &Dtool_DNASignBaseline_set_text_61, METH_O, (char *) Dtool_DNASignBaseline_set_text_61_comment},
  { "setText", (PyCFunction) &Dtool_DNASignBaseline_set_text_61, METH_O, (char *) Dtool_DNASignBaseline_set_text_61_comment},
  { "get_text", (PyCFunction) &Dtool_DNASignBaseline_get_text_62, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_text_62_comment},
  { "getText", (PyCFunction) &Dtool_DNASignBaseline_get_text_62, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_text_62_comment},
  { "set_code", (PyCFunction) &Dtool_DNASignBaseline_set_code_63, METH_O, (char *) Dtool_DNASignBaseline_set_code_63_comment},
  { "setCode", (PyCFunction) &Dtool_DNASignBaseline_set_code_63, METH_O, (char *) Dtool_DNASignBaseline_set_code_63_comment},
  { "get_code", (PyCFunction) &Dtool_DNASignBaseline_get_code_64, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_code_64_comment},
  { "getCode", (PyCFunction) &Dtool_DNASignBaseline_get_code_64, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_code_64_comment},
  { "set_flags", (PyCFunction) &Dtool_DNASignBaseline_set_flags_65, METH_O, (char *) Dtool_DNASignBaseline_set_flags_65_comment},
  { "setFlags", (PyCFunction) &Dtool_DNASignBaseline_set_flags_65, METH_O, (char *) Dtool_DNASignBaseline_set_flags_65_comment},
  { "get_flags", (PyCFunction) &Dtool_DNASignBaseline_get_flags_66, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_flags_66_comment},
  { "getFlags", (PyCFunction) &Dtool_DNASignBaseline_get_flags_66, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_flags_66_comment},
  { "set_color", (PyCFunction) &Dtool_DNASignBaseline_set_color_67, METH_O, (char *) Dtool_DNASignBaseline_set_color_67_comment},
  { "setColor", (PyCFunction) &Dtool_DNASignBaseline_set_color_67, METH_O, (char *) Dtool_DNASignBaseline_set_color_67_comment},
  { "get_color", (PyCFunction) &Dtool_DNASignBaseline_get_color_68, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_color_68_comment},
  { "getColor", (PyCFunction) &Dtool_DNASignBaseline_get_color_68, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_color_68_comment},
  { "set_indent", (PyCFunction) &Dtool_DNASignBaseline_set_indent_69, METH_O, (char *) Dtool_DNASignBaseline_set_indent_69_comment},
  { "setIndent", (PyCFunction) &Dtool_DNASignBaseline_set_indent_69, METH_O, (char *) Dtool_DNASignBaseline_set_indent_69_comment},
  { "get_indent", (PyCFunction) &Dtool_DNASignBaseline_get_indent_70, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_indent_70_comment},
  { "getIndent", (PyCFunction) &Dtool_DNASignBaseline_get_indent_70, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_indent_70_comment},
  { "set_kern", (PyCFunction) &Dtool_DNASignBaseline_set_kern_71, METH_O, (char *) Dtool_DNASignBaseline_set_kern_71_comment},
  { "setKern", (PyCFunction) &Dtool_DNASignBaseline_set_kern_71, METH_O, (char *) Dtool_DNASignBaseline_set_kern_71_comment},
  { "get_kern", (PyCFunction) &Dtool_DNASignBaseline_get_kern_72, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_kern_72_comment},
  { "getKern", (PyCFunction) &Dtool_DNASignBaseline_get_kern_72, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_kern_72_comment},
  { "set_wiggle", (PyCFunction) &Dtool_DNASignBaseline_set_wiggle_73, METH_O, (char *) Dtool_DNASignBaseline_set_wiggle_73_comment},
  { "setWiggle", (PyCFunction) &Dtool_DNASignBaseline_set_wiggle_73, METH_O, (char *) Dtool_DNASignBaseline_set_wiggle_73_comment},
  { "get_wiggle", (PyCFunction) &Dtool_DNASignBaseline_get_wiggle_74, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_wiggle_74_comment},
  { "getWiggle", (PyCFunction) &Dtool_DNASignBaseline_get_wiggle_74, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_wiggle_74_comment},
  { "set_stumble", (PyCFunction) &Dtool_DNASignBaseline_set_stumble_75, METH_O, (char *) Dtool_DNASignBaseline_set_stumble_75_comment},
  { "setStumble", (PyCFunction) &Dtool_DNASignBaseline_set_stumble_75, METH_O, (char *) Dtool_DNASignBaseline_set_stumble_75_comment},
  { "get_stumble", (PyCFunction) &Dtool_DNASignBaseline_get_stumble_76, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_stumble_76_comment},
  { "getStumble", (PyCFunction) &Dtool_DNASignBaseline_get_stumble_76, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_stumble_76_comment},
  { "set_stomp", (PyCFunction) &Dtool_DNASignBaseline_set_stomp_77, METH_O, (char *) Dtool_DNASignBaseline_set_stomp_77_comment},
  { "setStomp", (PyCFunction) &Dtool_DNASignBaseline_set_stomp_77, METH_O, (char *) Dtool_DNASignBaseline_set_stomp_77_comment},
  { "get_stomp", (PyCFunction) &Dtool_DNASignBaseline_get_stomp_78, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_stomp_78_comment},
  { "getStomp", (PyCFunction) &Dtool_DNASignBaseline_get_stomp_78, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_stomp_78_comment},
  { "set_width", (PyCFunction) &Dtool_DNASignBaseline_set_width_79, METH_O, (char *) Dtool_DNASignBaseline_set_width_79_comment},
  { "setWidth", (PyCFunction) &Dtool_DNASignBaseline_set_width_79, METH_O, (char *) Dtool_DNASignBaseline_set_width_79_comment},
  { "get_width", (PyCFunction) &Dtool_DNASignBaseline_get_width_80, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_width_80_comment},
  { "getWidth", (PyCFunction) &Dtool_DNASignBaseline_get_width_80, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_width_80_comment},
  { "set_height", (PyCFunction) &Dtool_DNASignBaseline_set_height_81, METH_O, (char *) Dtool_DNASignBaseline_set_height_81_comment},
  { "setHeight", (PyCFunction) &Dtool_DNASignBaseline_set_height_81, METH_O, (char *) Dtool_DNASignBaseline_set_height_81_comment},
  { "get_height", (PyCFunction) &Dtool_DNASignBaseline_get_height_82, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_height_82_comment},
  { "getHeight", (PyCFunction) &Dtool_DNASignBaseline_get_height_82, METH_NOARGS, (char *) Dtool_DNASignBaseline_get_height_82_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNASignBaseline_get_class_type_83, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASignBaseline_get_class_type_83_comment},
  { "getClassType", (PyCFunction) &Dtool_DNASignBaseline_get_class_type_83, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASignBaseline_get_class_type_83_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNASignBaseline(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNANode._Dtool_ClassInit(NULL);
    Dtool_DNASignBaseline.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNANode.As_PyTypeObject());
    Dtool_DNASignBaseline.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNASignBaseline.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNASignBaseline.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNASignBaseline.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASignBaseline)");
      printf("Error in PyType_Ready(DNASignBaseline)");
      return;
    }
    Py_INCREF(&Dtool_DNASignBaseline.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNASignBaseline, DNASignBaseline::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNASignBaseline.As_PyTypeObject());
    PyModule_AddObject(module, "DNASignBaseline", (PyObject *)&Dtool_DNASignBaseline.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNASignGraphic | DNASignGraphic
//********************************************************************
PyMethodDef Dtool_Methods_DNASignGraphic[] = {
  { "set_width", (PyCFunction) &Dtool_DNASignGraphic_set_width_86, METH_O, (char *) Dtool_DNASignGraphic_set_width_86_comment},
  { "setWidth", (PyCFunction) &Dtool_DNASignGraphic_set_width_86, METH_O, (char *) Dtool_DNASignGraphic_set_width_86_comment},
  { "get_width", (PyCFunction) &Dtool_DNASignGraphic_get_width_87, METH_NOARGS, (char *) Dtool_DNASignGraphic_get_width_87_comment},
  { "getWidth", (PyCFunction) &Dtool_DNASignGraphic_get_width_87, METH_NOARGS, (char *) Dtool_DNASignGraphic_get_width_87_comment},
  { "set_height", (PyCFunction) &Dtool_DNASignGraphic_set_height_88, METH_O, (char *) Dtool_DNASignGraphic_set_height_88_comment},
  { "setHeight", (PyCFunction) &Dtool_DNASignGraphic_set_height_88, METH_O, (char *) Dtool_DNASignGraphic_set_height_88_comment},
  { "get_height", (PyCFunction) &Dtool_DNASignGraphic_get_height_89, METH_NOARGS, (char *) Dtool_DNASignGraphic_get_height_89_comment},
  { "getHeight", (PyCFunction) &Dtool_DNASignGraphic_get_height_89, METH_NOARGS, (char *) Dtool_DNASignGraphic_get_height_89_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNASignGraphic_get_class_type_90, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASignGraphic_get_class_type_90_comment},
  { "getClassType", (PyCFunction) &Dtool_DNASignGraphic_get_class_type_90, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASignGraphic_get_class_type_90_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNASignGraphic(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNAProp._Dtool_ClassInit(NULL);
    Dtool_DNASignGraphic.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNAProp.As_PyTypeObject());
    Dtool_DNASignGraphic.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNASignGraphic.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNASignGraphic.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNASignGraphic.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASignGraphic)");
      printf("Error in PyType_Ready(DNASignGraphic)");
      return;
    }
    Py_INCREF(&Dtool_DNASignGraphic.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNASignGraphic, DNASignGraphic::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNASignGraphic.As_PyTypeObject());
    PyModule_AddObject(module, "DNASignGraphic", (PyObject *)&Dtool_DNASignGraphic.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNAFlatBuilding | DNAFlatBuilding
//********************************************************************
PyMethodDef Dtool_Methods_DNAFlatBuilding[] = {
  { "set_width", (PyCFunction) &Dtool_DNAFlatBuilding_set_width_93, METH_O, (char *) Dtool_DNAFlatBuilding_set_width_93_comment},
  { "setWidth", (PyCFunction) &Dtool_DNAFlatBuilding_set_width_93, METH_O, (char *) Dtool_DNAFlatBuilding_set_width_93_comment},
  { "get_width", (PyCFunction) &Dtool_DNAFlatBuilding_get_width_94, METH_NOARGS, (char *) Dtool_DNAFlatBuilding_get_width_94_comment},
  { "getWidth", (PyCFunction) &Dtool_DNAFlatBuilding_get_width_94, METH_NOARGS, (char *) Dtool_DNAFlatBuilding_get_width_94_comment},
  { "set_has_door", (PyCFunction) &Dtool_DNAFlatBuilding_set_has_door_95, METH_O, (char *) Dtool_DNAFlatBuilding_set_has_door_95_comment},
  { "setHasDoor", (PyCFunction) &Dtool_DNAFlatBuilding_set_has_door_95, METH_O, (char *) Dtool_DNAFlatBuilding_set_has_door_95_comment},
  { "get_has_door", (PyCFunction) &Dtool_DNAFlatBuilding_get_has_door_96, METH_NOARGS, (char *) Dtool_DNAFlatBuilding_get_has_door_96_comment},
  { "getHasDoor", (PyCFunction) &Dtool_DNAFlatBuilding_get_has_door_96, METH_NOARGS, (char *) Dtool_DNAFlatBuilding_get_has_door_96_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNAFlatBuilding_get_class_type_97, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAFlatBuilding_get_class_type_97_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAFlatBuilding_get_class_type_97, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAFlatBuilding_get_class_type_97_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAFlatBuilding(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNANode._Dtool_ClassInit(NULL);
    Dtool_DNAFlatBuilding.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNANode.As_PyTypeObject());
    Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAFlatBuilding.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAFlatBuilding)");
      printf("Error in PyType_Ready(DNAFlatBuilding)");
      return;
    }
    Py_INCREF(&Dtool_DNAFlatBuilding.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAFlatBuilding, DNAFlatBuilding::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAFlatBuilding.As_PyTypeObject());
    PyModule_AddObject(module, "DNAFlatBuilding", (PyObject *)&Dtool_DNAFlatBuilding.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNAWall | DNAWall
//********************************************************************
PyMethodDef Dtool_Methods_DNAWall[] = {
  { "set_color", (PyCFunction) &Dtool_DNAWall_set_color_100, METH_O, (char *) Dtool_DNAWall_set_color_100_comment},
  { "setColor", (PyCFunction) &Dtool_DNAWall_set_color_100, METH_O, (char *) Dtool_DNAWall_set_color_100_comment},
  { "get_color", (PyCFunction) &Dtool_DNAWall_get_color_101, METH_NOARGS, (char *) Dtool_DNAWall_get_color_101_comment},
  { "getColor", (PyCFunction) &Dtool_DNAWall_get_color_101, METH_NOARGS, (char *) Dtool_DNAWall_get_color_101_comment},
  { "set_height", (PyCFunction) &Dtool_DNAWall_set_height_102, METH_O, (char *) Dtool_DNAWall_set_height_102_comment},
  { "setHeight", (PyCFunction) &Dtool_DNAWall_set_height_102, METH_O, (char *) Dtool_DNAWall_set_height_102_comment},
  { "get_height", (PyCFunction) &Dtool_DNAWall_get_height_103, METH_NOARGS, (char *) Dtool_DNAWall_get_height_103_comment},
  { "getHeight", (PyCFunction) &Dtool_DNAWall_get_height_103, METH_NOARGS, (char *) Dtool_DNAWall_get_height_103_comment},
  { "set_code", (PyCFunction) &Dtool_DNAWall_set_code_104, METH_O, (char *) Dtool_DNAWall_set_code_104_comment},
  { "setCode", (PyCFunction) &Dtool_DNAWall_set_code_104, METH_O, (char *) Dtool_DNAWall_set_code_104_comment},
  { "get_code", (PyCFunction) &Dtool_DNAWall_get_code_105, METH_NOARGS, (char *) Dtool_DNAWall_get_code_105_comment},
  { "getCode", (PyCFunction) &Dtool_DNAWall_get_code_105, METH_NOARGS, (char *) Dtool_DNAWall_get_code_105_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNAWall_get_class_type_106, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAWall_get_class_type_106_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAWall_get_class_type_106, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAWall_get_class_type_106_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAWall(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNANode._Dtool_ClassInit(NULL);
    Dtool_DNAWall.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNANode.As_PyTypeObject());
    Dtool_DNAWall.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAWall.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAWall.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAWall.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAWall)");
      printf("Error in PyType_Ready(DNAWall)");
      return;
    }
    Py_INCREF(&Dtool_DNAWall.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAWall, DNAWall::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAWall.As_PyTypeObject());
    PyModule_AddObject(module, "DNAWall", (PyObject *)&Dtool_DNAWall.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNAWindows | DNAWindows
//********************************************************************
PyMethodDef Dtool_Methods_DNAWindows[] = {
  { "make_windows", (PyCFunction) &Dtool_DNAWindows_make_windows_109, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAWindows_make_windows_109_comment},
  { "makeWindows", (PyCFunction) &Dtool_DNAWindows_make_windows_109, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAWindows_make_windows_109_comment},
  { "set_color", (PyCFunction) &Dtool_DNAWindows_set_color_110, METH_O, (char *) Dtool_DNAWindows_set_color_110_comment},
  { "setColor", (PyCFunction) &Dtool_DNAWindows_set_color_110, METH_O, (char *) Dtool_DNAWindows_set_color_110_comment},
  { "get_color", (PyCFunction) &Dtool_DNAWindows_get_color_111, METH_NOARGS, (char *) Dtool_DNAWindows_get_color_111_comment},
  { "getColor", (PyCFunction) &Dtool_DNAWindows_get_color_111, METH_NOARGS, (char *) Dtool_DNAWindows_get_color_111_comment},
  { "set_window_count", (PyCFunction) &Dtool_DNAWindows_set_window_count_112, METH_O, (char *) Dtool_DNAWindows_set_window_count_112_comment},
  { "setWindowCount", (PyCFunction) &Dtool_DNAWindows_set_window_count_112, METH_O, (char *) Dtool_DNAWindows_set_window_count_112_comment},
  { "get_window_count", (PyCFunction) &Dtool_DNAWindows_get_window_count_113, METH_NOARGS, (char *) Dtool_DNAWindows_get_window_count_113_comment},
  { "getWindowCount", (PyCFunction) &Dtool_DNAWindows_get_window_count_113, METH_NOARGS, (char *) Dtool_DNAWindows_get_window_count_113_comment},
  { "set_code", (PyCFunction) &Dtool_DNAWindows_set_code_114, METH_O, (char *) Dtool_DNAWindows_set_code_114_comment},
  { "setCode", (PyCFunction) &Dtool_DNAWindows_set_code_114, METH_O, (char *) Dtool_DNAWindows_set_code_114_comment},
  { "get_code", (PyCFunction) &Dtool_DNAWindows_get_code_115, METH_NOARGS, (char *) Dtool_DNAWindows_get_code_115_comment},
  { "getCode", (PyCFunction) &Dtool_DNAWindows_get_code_115, METH_NOARGS, (char *) Dtool_DNAWindows_get_code_115_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNAWindows_get_class_type_116, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAWindows_get_class_type_116_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAWindows_get_class_type_116, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAWindows_get_class_type_116_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAWindows(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNAGroup._Dtool_ClassInit(NULL);
    Dtool_DNAWindows.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNAGroup.As_PyTypeObject());
    Dtool_DNAWindows.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAWindows.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAWindows.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAWindows.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAWindows)");
      printf("Error in PyType_Ready(DNAWindows)");
      return;
    }
    Py_INCREF(&Dtool_DNAWindows.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAWindows, DNAWindows::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAWindows.As_PyTypeObject());
    PyModule_AddObject(module, "DNAWindows", (PyObject *)&Dtool_DNAWindows.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNACornice | DNACornice
//********************************************************************
PyMethodDef Dtool_Methods_DNACornice[] = {
  { "set_color", (PyCFunction) &Dtool_DNACornice_set_color_119, METH_O, (char *) Dtool_DNACornice_set_color_119_comment},
  { "setColor", (PyCFunction) &Dtool_DNACornice_set_color_119, METH_O, (char *) Dtool_DNACornice_set_color_119_comment},
  { "get_color", (PyCFunction) &Dtool_DNACornice_get_color_120, METH_NOARGS, (char *) Dtool_DNACornice_get_color_120_comment},
  { "getColor", (PyCFunction) &Dtool_DNACornice_get_color_120, METH_NOARGS, (char *) Dtool_DNACornice_get_color_120_comment},
  { "set_code", (PyCFunction) &Dtool_DNACornice_set_code_121, METH_O, (char *) Dtool_DNACornice_set_code_121_comment},
  { "setCode", (PyCFunction) &Dtool_DNACornice_set_code_121, METH_O, (char *) Dtool_DNACornice_set_code_121_comment},
  { "get_code", (PyCFunction) &Dtool_DNACornice_get_code_122, METH_NOARGS, (char *) Dtool_DNACornice_get_code_122_comment},
  { "getCode", (PyCFunction) &Dtool_DNACornice_get_code_122, METH_NOARGS, (char *) Dtool_DNACornice_get_code_122_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNACornice_get_class_type_123, METH_NOARGS | METH_STATIC, (char *) Dtool_DNACornice_get_class_type_123_comment},
  { "getClassType", (PyCFunction) &Dtool_DNACornice_get_class_type_123, METH_NOARGS | METH_STATIC, (char *) Dtool_DNACornice_get_class_type_123_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNACornice(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNAGroup._Dtool_ClassInit(NULL);
    Dtool_DNACornice.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNAGroup.As_PyTypeObject());
    Dtool_DNACornice.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNACornice.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNACornice.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNACornice.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNACornice)");
      printf("Error in PyType_Ready(DNACornice)");
      return;
    }
    Py_INCREF(&Dtool_DNACornice.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNACornice, DNACornice::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNACornice.As_PyTypeObject());
    PyModule_AddObject(module, "DNACornice", (PyObject *)&Dtool_DNACornice.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNALandmarkBuilding | DNALandmarkBuilding
//********************************************************************
PyMethodDef Dtool_Methods_DNALandmarkBuilding[] = {
  { "set_wall_color", (PyCFunction) &Dtool_DNALandmarkBuilding_set_wall_color_126, METH_O, (char *) Dtool_DNALandmarkBuilding_set_wall_color_126_comment},
  { "setWallColor", (PyCFunction) &Dtool_DNALandmarkBuilding_set_wall_color_126, METH_O, (char *) Dtool_DNALandmarkBuilding_set_wall_color_126_comment},
  { "get_wall_color", (PyCFunction) &Dtool_DNALandmarkBuilding_get_wall_color_127, METH_NOARGS, (char *) Dtool_DNALandmarkBuilding_get_wall_color_127_comment},
  { "getWallColor", (PyCFunction) &Dtool_DNALandmarkBuilding_get_wall_color_127, METH_NOARGS, (char *) Dtool_DNALandmarkBuilding_get_wall_color_127_comment},
  { "set_code", (PyCFunction) &Dtool_DNALandmarkBuilding_set_code_128, METH_O, (char *) Dtool_DNALandmarkBuilding_set_code_128_comment},
  { "setCode", (PyCFunction) &Dtool_DNALandmarkBuilding_set_code_128, METH_O, (char *) Dtool_DNALandmarkBuilding_set_code_128_comment},
  { "get_code", (PyCFunction) &Dtool_DNALandmarkBuilding_get_code_129, METH_NOARGS, (char *) Dtool_DNALandmarkBuilding_get_code_129_comment},
  { "getCode", (PyCFunction) &Dtool_DNALandmarkBuilding_get_code_129, METH_NOARGS, (char *) Dtool_DNALandmarkBuilding_get_code_129_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNALandmarkBuilding_get_class_type_130, METH_NOARGS | METH_STATIC, (char *) Dtool_DNALandmarkBuilding_get_class_type_130_comment},
  { "getClassType", (PyCFunction) &Dtool_DNALandmarkBuilding_get_class_type_130, METH_NOARGS | METH_STATIC, (char *) Dtool_DNALandmarkBuilding_get_class_type_130_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNALandmarkBuilding(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNANode._Dtool_ClassInit(NULL);
    Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNANode.As_PyTypeObject());
    Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNALandmarkBuilding.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNALandmarkBuilding)");
      printf("Error in PyType_Ready(DNALandmarkBuilding)");
      return;
    }
    Py_INCREF(&Dtool_DNALandmarkBuilding.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNALandmarkBuilding, DNALandmarkBuilding::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNALandmarkBuilding.As_PyTypeObject());
    PyModule_AddObject(module, "DNALandmarkBuilding", (PyObject *)&Dtool_DNALandmarkBuilding.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNAAnimProp | DNAAnimProp
//********************************************************************
PyMethodDef Dtool_Methods_DNAAnimProp[] = {
  { "set_anim_name", (PyCFunction) &Dtool_DNAAnimProp_set_anim_name_133, METH_O, (char *) Dtool_DNAAnimProp_set_anim_name_133_comment},
  { "setAnimName", (PyCFunction) &Dtool_DNAAnimProp_set_anim_name_133, METH_O, (char *) Dtool_DNAAnimProp_set_anim_name_133_comment},
  { "get_anim_name", (PyCFunction) &Dtool_DNAAnimProp_get_anim_name_134, METH_NOARGS, (char *) Dtool_DNAAnimProp_get_anim_name_134_comment},
  { "getAnimName", (PyCFunction) &Dtool_DNAAnimProp_get_anim_name_134, METH_NOARGS, (char *) Dtool_DNAAnimProp_get_anim_name_134_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNAAnimProp_get_class_type_135, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAAnimProp_get_class_type_135_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAAnimProp_get_class_type_135, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAAnimProp_get_class_type_135_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAAnimProp(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNAProp._Dtool_ClassInit(NULL);
    Dtool_DNAAnimProp.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNAProp.As_PyTypeObject());
    Dtool_DNAAnimProp.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAAnimProp.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAAnimProp.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAAnimProp.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAAnimProp)");
      printf("Error in PyType_Ready(DNAAnimProp)");
      return;
    }
    Py_INCREF(&Dtool_DNAAnimProp.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAAnimProp, DNAAnimProp::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAAnimProp.As_PyTypeObject());
    PyModule_AddObject(module, "DNAAnimProp", (PyObject *)&Dtool_DNAAnimProp.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNAInteractiveProp | DNAInteractiveProp
//********************************************************************
PyMethodDef Dtool_Methods_DNAInteractiveProp[] = {
  { "set_cell_id", (PyCFunction) &Dtool_DNAInteractiveProp_set_cell_id_138, METH_O, (char *) Dtool_DNAInteractiveProp_set_cell_id_138_comment},
  { "setCellId", (PyCFunction) &Dtool_DNAInteractiveProp_set_cell_id_138, METH_O, (char *) Dtool_DNAInteractiveProp_set_cell_id_138_comment},
  { "get_cell_id", (PyCFunction) &Dtool_DNAInteractiveProp_get_cell_id_139, METH_NOARGS, (char *) Dtool_DNAInteractiveProp_get_cell_id_139_comment},
  { "getCellId", (PyCFunction) &Dtool_DNAInteractiveProp_get_cell_id_139, METH_NOARGS, (char *) Dtool_DNAInteractiveProp_get_cell_id_139_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNAInteractiveProp_get_class_type_140, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAInteractiveProp_get_class_type_140_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAInteractiveProp_get_class_type_140, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAInteractiveProp_get_class_type_140_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAInteractiveProp(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNAAnimProp._Dtool_ClassInit(NULL);
    Dtool_DNAInteractiveProp.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNAAnimProp.As_PyTypeObject());
    Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAInteractiveProp.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAInteractiveProp)");
      printf("Error in PyType_Ready(DNAInteractiveProp)");
      return;
    }
    Py_INCREF(&Dtool_DNAInteractiveProp.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAInteractiveProp, DNAInteractiveProp::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAInteractiveProp.As_PyTypeObject());
    PyModule_AddObject(module, "DNAInteractiveProp", (PyObject *)&Dtool_DNAInteractiveProp.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNAAnimBuilding | DNAAnimBuilding
//********************************************************************
PyMethodDef Dtool_Methods_DNAAnimBuilding[] = {
  { "set_anim_name", (PyCFunction) &Dtool_DNAAnimBuilding_set_anim_name_143, METH_O, (char *) Dtool_DNAAnimBuilding_set_anim_name_143_comment},
  { "setAnimName", (PyCFunction) &Dtool_DNAAnimBuilding_set_anim_name_143, METH_O, (char *) Dtool_DNAAnimBuilding_set_anim_name_143_comment},
  { "get_anim_name", (PyCFunction) &Dtool_DNAAnimBuilding_get_anim_name_144, METH_NOARGS, (char *) Dtool_DNAAnimBuilding_get_anim_name_144_comment},
  { "getAnimName", (PyCFunction) &Dtool_DNAAnimBuilding_get_anim_name_144, METH_NOARGS, (char *) Dtool_DNAAnimBuilding_get_anim_name_144_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNAAnimBuilding_get_class_type_145, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAAnimBuilding_get_class_type_145_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAAnimBuilding_get_class_type_145, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAAnimBuilding_get_class_type_145_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAAnimBuilding(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNALandmarkBuilding._Dtool_ClassInit(NULL);
    Dtool_DNAAnimBuilding.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNALandmarkBuilding.As_PyTypeObject());
    Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAAnimBuilding.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAAnimBuilding)");
      printf("Error in PyType_Ready(DNAAnimBuilding)");
      return;
    }
    Py_INCREF(&Dtool_DNAAnimBuilding.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAAnimBuilding, DNAAnimBuilding::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAAnimBuilding.As_PyTypeObject());
    PyModule_AddObject(module, "DNAAnimBuilding", (PyObject *)&Dtool_DNAAnimBuilding.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNADoor | DNADoor
//********************************************************************
PyMethodDef Dtool_Methods_DNADoor[] = {
  { "setup_door", (PyCFunction) &Dtool_DNADoor_setup_door_148, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (char *) Dtool_DNADoor_setup_door_148_comment},
  { "setupDoor", (PyCFunction) &Dtool_DNADoor_setup_door_148, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (char *) Dtool_DNADoor_setup_door_148_comment},
  { "set_color", (PyCFunction) &Dtool_DNADoor_set_color_149, METH_O, (char *) Dtool_DNADoor_set_color_149_comment},
  { "setColor", (PyCFunction) &Dtool_DNADoor_set_color_149, METH_O, (char *) Dtool_DNADoor_set_color_149_comment},
  { "get_color", (PyCFunction) &Dtool_DNADoor_get_color_150, METH_NOARGS, (char *) Dtool_DNADoor_get_color_150_comment},
  { "getColor", (PyCFunction) &Dtool_DNADoor_get_color_150, METH_NOARGS, (char *) Dtool_DNADoor_get_color_150_comment},
  { "set_code", (PyCFunction) &Dtool_DNADoor_set_code_151, METH_O, (char *) Dtool_DNADoor_set_code_151_comment},
  { "setCode", (PyCFunction) &Dtool_DNADoor_set_code_151, METH_O, (char *) Dtool_DNADoor_set_code_151_comment},
  { "get_code", (PyCFunction) &Dtool_DNADoor_get_code_152, METH_NOARGS, (char *) Dtool_DNADoor_get_code_152_comment},
  { "getCode", (PyCFunction) &Dtool_DNADoor_get_code_152, METH_NOARGS, (char *) Dtool_DNADoor_get_code_152_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNADoor_get_class_type_153, METH_NOARGS | METH_STATIC, (char *) Dtool_DNADoor_get_class_type_153_comment},
  { "getClassType", (PyCFunction) &Dtool_DNADoor_get_class_type_153, METH_NOARGS | METH_STATIC, (char *) Dtool_DNADoor_get_class_type_153_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNADoor(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNAGroup._Dtool_ClassInit(NULL);
    Dtool_DNADoor.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNAGroup.As_PyTypeObject());
    Dtool_DNADoor.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNADoor.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNADoor.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNADoor.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNADoor)");
      printf("Error in PyType_Ready(DNADoor)");
      return;
    }
    Py_INCREF(&Dtool_DNADoor.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNADoor, DNADoor::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNADoor.As_PyTypeObject());
    PyModule_AddObject(module, "DNADoor", (PyObject *)&Dtool_DNADoor.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNAFlatDoor | DNAFlatDoor
//********************************************************************
PyMethodDef Dtool_Methods_DNAFlatDoor[] = {
  { "get_class_type", (PyCFunction) &Dtool_DNAFlatDoor_get_class_type_156, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAFlatDoor_get_class_type_156_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAFlatDoor_get_class_type_156, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAFlatDoor_get_class_type_156_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAFlatDoor(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNADoor._Dtool_ClassInit(NULL);
    Dtool_DNAFlatDoor.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNADoor.As_PyTypeObject());
    Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAFlatDoor.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAFlatDoor)");
      printf("Error in PyType_Ready(DNAFlatDoor)");
      return;
    }
    Py_INCREF(&Dtool_DNAFlatDoor.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAFlatDoor, DNAFlatDoor::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAFlatDoor.As_PyTypeObject());
    PyModule_AddObject(module, "DNAFlatDoor", (PyObject *)&Dtool_DNAFlatDoor.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNAStreet | DNAStreet
//********************************************************************
PyMethodDef Dtool_Methods_DNAStreet[] = {
  { "set_code", (PyCFunction) &Dtool_DNAStreet_set_code_159, METH_O, (char *) Dtool_DNAStreet_set_code_159_comment},
  { "setCode", (PyCFunction) &Dtool_DNAStreet_set_code_159, METH_O, (char *) Dtool_DNAStreet_set_code_159_comment},
  { "get_code", (PyCFunction) &Dtool_DNAStreet_get_code_160, METH_NOARGS, (char *) Dtool_DNAStreet_get_code_160_comment},
  { "getCode", (PyCFunction) &Dtool_DNAStreet_get_code_160, METH_NOARGS, (char *) Dtool_DNAStreet_get_code_160_comment},
  { "set_street_texture", (PyCFunction) &Dtool_DNAStreet_set_street_texture_161, METH_O, (char *) Dtool_DNAStreet_set_street_texture_161_comment},
  { "setStreetTexture", (PyCFunction) &Dtool_DNAStreet_set_street_texture_161, METH_O, (char *) Dtool_DNAStreet_set_street_texture_161_comment},
  { "get_street_texture", (PyCFunction) &Dtool_DNAStreet_get_street_texture_162, METH_NOARGS, (char *) Dtool_DNAStreet_get_street_texture_162_comment},
  { "getStreetTexture", (PyCFunction) &Dtool_DNAStreet_get_street_texture_162, METH_NOARGS, (char *) Dtool_DNAStreet_get_street_texture_162_comment},
  { "set_sidewalk_texture", (PyCFunction) &Dtool_DNAStreet_set_sidewalk_texture_163, METH_O, (char *) Dtool_DNAStreet_set_sidewalk_texture_163_comment},
  { "setSidewalkTexture", (PyCFunction) &Dtool_DNAStreet_set_sidewalk_texture_163, METH_O, (char *) Dtool_DNAStreet_set_sidewalk_texture_163_comment},
  { "get_sidewalk_texture", (PyCFunction) &Dtool_DNAStreet_get_sidewalk_texture_164, METH_NOARGS, (char *) Dtool_DNAStreet_get_sidewalk_texture_164_comment},
  { "getSidewalkTexture", (PyCFunction) &Dtool_DNAStreet_get_sidewalk_texture_164, METH_NOARGS, (char *) Dtool_DNAStreet_get_sidewalk_texture_164_comment},
  { "set_curb_texture", (PyCFunction) &Dtool_DNAStreet_set_curb_texture_165, METH_O, (char *) Dtool_DNAStreet_set_curb_texture_165_comment},
  { "setCurbTexture", (PyCFunction) &Dtool_DNAStreet_set_curb_texture_165, METH_O, (char *) Dtool_DNAStreet_set_curb_texture_165_comment},
  { "get_curb_texture", (PyCFunction) &Dtool_DNAStreet_get_curb_texture_166, METH_NOARGS, (char *) Dtool_DNAStreet_get_curb_texture_166_comment},
  { "getCurbTexture", (PyCFunction) &Dtool_DNAStreet_get_curb_texture_166, METH_NOARGS, (char *) Dtool_DNAStreet_get_curb_texture_166_comment},
  { "set_street_color", (PyCFunction) &Dtool_DNAStreet_set_street_color_167, METH_O, (char *) Dtool_DNAStreet_set_street_color_167_comment},
  { "setStreetColor", (PyCFunction) &Dtool_DNAStreet_set_street_color_167, METH_O, (char *) Dtool_DNAStreet_set_street_color_167_comment},
  { "get_street_color", (PyCFunction) &Dtool_DNAStreet_get_street_color_168, METH_NOARGS, (char *) Dtool_DNAStreet_get_street_color_168_comment},
  { "getStreetColor", (PyCFunction) &Dtool_DNAStreet_get_street_color_168, METH_NOARGS, (char *) Dtool_DNAStreet_get_street_color_168_comment},
  { "set_sidewalk_color", (PyCFunction) &Dtool_DNAStreet_set_sidewalk_color_169, METH_O, (char *) Dtool_DNAStreet_set_sidewalk_color_169_comment},
  { "setSidewalkColor", (PyCFunction) &Dtool_DNAStreet_set_sidewalk_color_169, METH_O, (char *) Dtool_DNAStreet_set_sidewalk_color_169_comment},
  { "get_sidewalk_color", (PyCFunction) &Dtool_DNAStreet_get_sidewalk_color_170, METH_NOARGS, (char *) Dtool_DNAStreet_get_sidewalk_color_170_comment},
  { "getSidewalkColor", (PyCFunction) &Dtool_DNAStreet_get_sidewalk_color_170, METH_NOARGS, (char *) Dtool_DNAStreet_get_sidewalk_color_170_comment},
  { "set_curb_color", (PyCFunction) &Dtool_DNAStreet_set_curb_color_171, METH_O, (char *) Dtool_DNAStreet_set_curb_color_171_comment},
  { "setCurbColor", (PyCFunction) &Dtool_DNAStreet_set_curb_color_171, METH_O, (char *) Dtool_DNAStreet_set_curb_color_171_comment},
  { "get_curb_color", (PyCFunction) &Dtool_DNAStreet_get_curb_color_172, METH_NOARGS, (char *) Dtool_DNAStreet_get_curb_color_172_comment},
  { "getCurbColor", (PyCFunction) &Dtool_DNAStreet_get_curb_color_172, METH_NOARGS, (char *) Dtool_DNAStreet_get_curb_color_172_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNAStreet_get_class_type_173, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAStreet_get_class_type_173_comment},
  { "getClassType", (PyCFunction) &Dtool_DNAStreet_get_class_type_173, METH_NOARGS | METH_STATIC, (char *) Dtool_DNAStreet_get_class_type_173_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAStreet(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DNANode._Dtool_ClassInit(NULL);
    Dtool_DNAStreet.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DNANode.As_PyTypeObject());
    Dtool_DNAStreet.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAStreet.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAStreet.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAStreet.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAStreet)");
      printf("Error in PyType_Ready(DNAStreet)");
      return;
    }
    Py_INCREF(&Dtool_DNAStreet.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAStreet, DNAStreet::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAStreet.As_PyTypeObject());
    PyModule_AddObject(module, "DNAStreet", (PyObject *)&Dtool_DNAStreet.As_PyTypeObject());
  }
}


//********************************************************************
//*** Module Object Linker ..
//********************************************************************
static void BuildInstants(PyObject * module) {
  // Module init upcall for DNAGroup
  Dtool_PyModuleClassInit_DNAGroup(module);
  // Module init upcall for DNABattleCell
  Dtool_PyModuleClassInit_DNABattleCell(module);
  // Module init upcall for DNAVisGroup
  Dtool_PyModuleClassInit_DNAVisGroup(module);
  // Module init upcall for DNANode
  Dtool_PyModuleClassInit_DNANode(module);
  // Module init upcall for DNAProp
  Dtool_PyModuleClassInit_DNAProp(module);
  // Module init upcall for DNASign
  Dtool_PyModuleClassInit_DNASign(module);
  // Module init upcall for DNASignBaseline
  Dtool_PyModuleClassInit_DNASignBaseline(module);
  // Module init upcall for DNASignGraphic
  Dtool_PyModuleClassInit_DNASignGraphic(module);
  // Module init upcall for DNAFlatBuilding
  Dtool_PyModuleClassInit_DNAFlatBuilding(module);
  // Module init upcall for DNAWall
  Dtool_PyModuleClassInit_DNAWall(module);
  // Module init upcall for DNAWindows
  Dtool_PyModuleClassInit_DNAWindows(module);
  // Module init upcall for DNACornice
  Dtool_PyModuleClassInit_DNACornice(module);
  // Module init upcall for DNALandmarkBuilding
  Dtool_PyModuleClassInit_DNALandmarkBuilding(module);
  // Module init upcall for DNAAnimProp
  Dtool_PyModuleClassInit_DNAAnimProp(module);
  // Module init upcall for DNAInteractiveProp
  Dtool_PyModuleClassInit_DNAInteractiveProp(module);
  // Module init upcall for DNAAnimBuilding
  Dtool_PyModuleClassInit_DNAAnimBuilding(module);
  // Module init upcall for DNADoor
  Dtool_PyModuleClassInit_DNADoor(module);
  // Module init upcall for DNAFlatDoor
  Dtool_PyModuleClassInit_DNAFlatDoor(module);
  // Module init upcall for DNAStreet
  Dtool_PyModuleClassInit_DNAStreet(module);
//********************************************************************
//*** Module Init Upcall ..  Externally Defined Class
//********************************************************************
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

EXPORT_THIS struct LibraryDef components_moddef = {python_simple_funcs, BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1425932686,  /* file_identifier */
  "components",  /* library_name */
  "8m9W",  /* library_hash_name */
  "libpandadna",  /* module_name */
  "components.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  370  /* next_index */
};

Configure(_in_configure_components);
ConfigureFn(_in_configure_components) {
  interrogate_request_module(&_in_module_def);
}

