/*
 * This file generated by:
 * C:\Panda3D-ttn\bin\interrogate.exe -D__inline -DCPPPARSER -DP3_INTERROGATE=1 -D__cplusplus -fnames -string -refcount -assert -S C:\Panda3D-ttn\include\parser-inc -S C:\Panda3D-ttn\include -I C:\Panda3D-ttn\include -IC:/Users/Usuario/workspace/libpandadna/src\suit -IC:/Users/Usuario/workspace/libpandadna/src\base -IC:/Users/Usuario/workspace/libpandadna/src\components -srcdir C:/Users/Usuario/workspace/libpandadna/src\suit -oc C:/Users/Usuario/workspace/libpandadna/src\suit_igate.cxx -od C:/Users/Usuario/workspace/libpandadna/src\suit.in -python-native -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -module libpandadna -library suit -Dvolatile= DNASuitPoint.h DNASuitPath.h DNASuitEdge.h SuitLeg.h SuitLegList.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_suit
#include "py_panda.h"
#include "extension.h"

#include "DNAStorage.h"
#include "DNASuitEdge.h"
#include "DNASuitPath.h"
#include "DNASuitPoint.h"
#include "SuitLeg.h"
#include "SuitLegList.h"
#include "dnabase.h"
#include <luse.h>
#include <typedObject.h>
#include <vector>

#undef _POSIX_C_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif

//********************************************************************
//*** prototypes for .. Global
//********************************************************************
//********************************************************************
//*** prototypes for .. DNASuitPoint
//********************************************************************
typedef DNASuitPoint DNASuitPoint_localtype;
Define_Module_Class(libpandadna, DNASuitPoint, DNASuitPoint_localtype, DNASuitPoint);

//********************************************************************
//*** prototypes for .. DNASuitPath
//********************************************************************
typedef DNASuitPath DNASuitPath_localtype;
Define_Module_Class(libpandadna, DNASuitPath, DNASuitPath_localtype, DNASuitPath);

//********************************************************************
//*** prototypes for .. DNASuitEdge
//********************************************************************
typedef DNASuitEdge DNASuitEdge_localtype;
Define_Module_Class(libpandadna, DNASuitEdge, DNASuitEdge_localtype, DNASuitEdge);

//********************************************************************
//*** prototypes for .. SuitLeg
//********************************************************************
typedef SuitLeg SuitLeg_localtype;
Define_Module_Class(libpandadna, SuitLeg, SuitLeg_localtype, SuitLeg);

//********************************************************************
//*** prototypes for .. SuitLegList
//********************************************************************
typedef SuitLegList SuitLegList_localtype;
Define_Module_Class(libpandadna, SuitLegList, SuitLegList_localtype, SuitLegList);

//********************************************************************
//*** prototypes for .. External Objects
//********************************************************************
IMPORT_THIS struct Dtool_PyTypedObject Dtool_DNAStorage;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_TypedObject;

//********************************************************************
//*** Functions for .. Global
//********************************************************************
//********************************************************************
//*** Functions for .. DNASuitPoint
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitPoint::set_point_type(DNASuitPoint::PointType value)
 * void DNASuitPoint::set_point_type(basic_string< char > const &point_type)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_point_type_5(PyObject *self, PyObject *arg) {
  DNASuitPoint *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPoint, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
  // -2 void DNASuitPoint::set_point_type(basic_string< char > const &point_type)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (local_this)->set_point_type(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
    PyErr_Clear();
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
  // -2 inline void DNASuitPoint::set_point_type(DNASuitPoint::PointType value)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      (local_this)->set_point_type((DNASuitPoint::PointType)param1);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
    PyErr_Clear();
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_point_type(DNASuitPoint this, str point_type)\n"
      "set_point_type(DNASuitPoint this, int value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPoint_set_point_type_5_comment =
  "C++ Interface:\n"
  "set_point_type(DNASuitPoint this, str point_type)\n"
  "set_point_type(DNASuitPoint this, int value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPoint_set_point_type_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitPoint::set_index(unsigned short int value)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_index_6(PyObject *self, PyObject *arg) {
  DNASuitPoint *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPoint, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASuitPoint::set_index(unsigned short int value)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      (local_this)->set_index(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitPoint.set_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_index(DNASuitPoint this, unsigned int value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPoint_set_index_6_comment =
  "C++ Interface:\n"
  "set_index(DNASuitPoint this, unsigned int value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPoint_set_index_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int DNASuitPoint::get_index(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_index_7(PyObject *self) {
  DNASuitPoint *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPoint, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline unsigned short int DNASuitPoint::get_index(void)
    unsigned short int return_value = (local_this)->get_index();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitPoint.get_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_index(DNASuitPoint this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPoint_get_index_7_comment =
  "C++ Interface:\n"
  "get_index(DNASuitPoint this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPoint_get_index_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DNASuitPoint::PointType DNASuitPoint::get_point_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_point_type_8(PyObject *self) {
  DNASuitPoint *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPoint, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline DNASuitPoint::PointType DNASuitPoint::get_point_type(void)
    DNASuitPoint::PointType return_value = (local_this)->get_point_type();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromLong(return_value);
#else
      return PyInt_FromLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitPoint.get_point_type() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_point_type(DNASuitPoint this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPoint_get_point_type_8_comment =
  "C++ Interface:\n"
  "get_point_type(DNASuitPoint this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPoint_get_point_type_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitPoint::set_pos(LPoint3f value)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_pos_9(PyObject *self, PyObject *arg) {
  DNASuitPoint *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPoint, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNASuitPoint::set_pos(LPoint3f value)
        LPoint3f *arg_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LPoint3f, 1, "DNASuitPoint.set_pos", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_pos(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNASuitPoint.set_pos() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_pos(DNASuitPoint this, const LPoint3f value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPoint_set_pos_9_comment =
  "C++ Interface:\n"
  "set_pos(DNASuitPoint this, const LPoint3f value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPoint_set_pos_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f DNASuitPoint::get_pos(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_pos_10(PyObject *self) {
  DNASuitPoint *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPoint, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LPoint3f DNASuitPoint::get_pos(void)
    LPoint3f result = (local_this)->get_pos();
    LPoint3f *return_value = new LPoint3f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LPoint3f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitPoint.get_pos() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_pos(DNASuitPoint this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPoint_get_pos_10_comment =
  "C++ Interface:\n"
  "get_pos(DNASuitPoint this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPoint_get_pos_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitPoint::set_landmark_building_index(short int value)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_landmark_building_index_11(PyObject *self, PyObject *arg) {
  DNASuitPoint *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPoint, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASuitPoint::set_landmark_building_index(short int value)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      (local_this)->set_landmark_building_index((short int)param1);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitPoint.set_landmark_building_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_landmark_building_index(DNASuitPoint this, int value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPoint_set_landmark_building_index_11_comment =
  "C++ Interface:\n"
  "set_landmark_building_index(DNASuitPoint this, int value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPoint_set_landmark_building_index_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline short int DNASuitPoint::get_landmark_building_index(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_landmark_building_index_12(PyObject *self) {
  DNASuitPoint *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPoint, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline short int DNASuitPoint::get_landmark_building_index(void)
    short int return_value = (local_this)->get_landmark_building_index();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromLong(return_value);
#else
      return PyInt_FromLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitPoint.get_landmark_building_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_landmark_building_index(DNASuitPoint this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPoint_get_landmark_building_index_12_comment =
  "C++ Interface:\n"
  "get_landmark_building_index(DNASuitPoint this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPoint_get_landmark_building_index_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASuitPoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_class_type_13(PyObject *) {

  // 1-static TypeHandle DNASuitPoint::get_class_type(void)
  TypeHandle result = DNASuitPoint::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPoint_get_class_type_13_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPoint_get_class_type_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPoint::DNASuitPoint(unsigned short int index, DNASuitPoint::PointType point_type, LPoint3f pos, short int landmark_building_index)
 * DNASuitPoint::DNASuitPoint(unsigned short int index, DNASuitPoint::PointType point_type, LPoint3f pos, short int landmark_building_index = (-1))
 *******************************************************************/
int Dtool_Init_DNASuitPoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        // 1-DNASuitPoint::DNASuitPoint(unsigned short int index, DNASuitPoint::PointType point_type, LPoint3f pos, short int landmark_building_index = (-1))
        PyObject *param0;
        int param1;
        PyObject *param2;
        static char *keyword_list[] = {(char *)"index", (char *)"point_type", (char *)"pos", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO:DNASuitPoint", keyword_list, &param0, &param1, &param2)) {
          PyObject *param0_long = PyNumber_Long(param0);LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNASuitPoint.DNASuitPoint", 1, coerced_ptr, report_errors);

          if (param0_long != NULL && param2_this != NULL) {
            DNASuitPoint *return_value = new DNASuitPoint(PyLong_AsUnsignedLong(param0_long), (DNASuitPoint::PointType)param1, *param2_this);
            Py_XDECREF(param0_long);
            Py_XDECREF(coerced);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (PyErr_Occurred()) {
              delete return_value;
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return -1;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              return DTool_PyInit_Finalize(self, return_value, &Dtool_DNASuitPoint, true, false);
            }
          }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 4: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        // 1-DNASuitPoint::DNASuitPoint(unsigned short int index, DNASuitPoint::PointType point_type, LPoint3f pos, short int landmark_building_index)
        PyObject *param0;
        int param1;
        PyObject *param2;
        int param3;
        static char *keyword_list[] = {(char *)"index", (char *)"point_type", (char *)"pos", (char *)"landmark_building_index", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OiOi:DNASuitPoint", keyword_list, &param0, &param1, &param2, &param3)) {
          PyObject *param0_long = PyNumber_Long(param0);LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNASuitPoint.DNASuitPoint", 1, coerced_ptr, report_errors);

          if (param0_long != NULL && param2_this != NULL) {
            DNASuitPoint *return_value = new DNASuitPoint(PyLong_AsUnsignedLong(param0_long), (DNASuitPoint::PointType)param1, *param2_this, (short int)param3);
            Py_XDECREF(param0_long);
            Py_XDECREF(coerced);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (PyErr_Occurred()) {
              delete return_value;
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return -1;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              return DTool_PyInit_Finalize(self, return_value, &Dtool_DNASuitPoint, true, false);
            }
          }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "DNASuitPoint() takes 3 or 4 arguments (%d given)", parameter_count + 0);
    return -1;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "DNASuitPoint(unsigned int index, int point_type, const LPoint3f pos)\n"
      "DNASuitPoint(unsigned int index, int point_type, const LPoint3f pos, int landmark_building_index)\n"
      "");
 }
  return -1;
}


/******************************************************************
 * Python type method wrapper for
 * DNASuitPoint::DNASuitPoint(unsigned short int index, DNASuitPoint::PointType point_type, LPoint3f pos, short int landmark_building_index)
 * DNASuitPoint::DNASuitPoint(unsigned short int index, DNASuitPoint::PointType point_type, LPoint3f pos, short int landmark_building_index = (-1))
 *******************************************************************/
int Dtool_InitNoCoerce_DNASuitPoint(PyObject *self, PyObject *args) {
  int parameter_count = PyTuple_Size(args);
  switch (parameter_count) {
  case 3: {

    // 1-DNASuitPoint::DNASuitPoint(unsigned short int index, DNASuitPoint::PointType point_type, LPoint3f pos, short int landmark_building_index = (-1))
    PyObject *param0;
    int param1;
    PyObject *param2;
    if (PyArg_ParseTuple(args, "OiO:DNASuitPoint", &param0, &param1, &param2)) {
      PyObject *param0_long = PyNumber_Long(param0);LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNASuitPoint.DNASuitPoint", 1, NULL, true);

      if (param0_long != NULL && param2_this != NULL) {
        DNASuitPoint *return_value = new DNASuitPoint(PyLong_AsUnsignedLong(param0_long), (DNASuitPoint::PointType)param1, *param2_this);
        Py_XDECREF(param0_long);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (PyErr_Occurred()) {
          delete return_value;
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return -1;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            delete return_value;
            return -1;
          }
#endif
          return DTool_PyInit_Finalize(self, return_value, &Dtool_DNASuitPoint, true, false);
        }
      }
    }

    break;
  }
  case 4: {

    // 1-DNASuitPoint::DNASuitPoint(unsigned short int index, DNASuitPoint::PointType point_type, LPoint3f pos, short int landmark_building_index)
    PyObject *param0;
    int param1;
    PyObject *param2;
    int param3;
    if (PyArg_ParseTuple(args, "OiOi:DNASuitPoint", &param0, &param1, &param2, &param3)) {
      PyObject *param0_long = PyNumber_Long(param0);LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNASuitPoint.DNASuitPoint", 1, NULL, true);

      if (param0_long != NULL && param2_this != NULL) {
        DNASuitPoint *return_value = new DNASuitPoint(PyLong_AsUnsignedLong(param0_long), (DNASuitPoint::PointType)param1, *param2_this, (short int)param3);
        Py_XDECREF(param0_long);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (PyErr_Occurred()) {
          delete return_value;
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return -1;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            delete return_value;
            return -1;
          }
#endif
          return DTool_PyInit_Finalize(self, return_value, &Dtool_DNASuitPoint, true, false);
        }
      }
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "DNASuitPoint() takes 3 or 4 arguments (%d given)", parameter_count + 0);
    return -1;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "DNASuitPoint(unsigned int index, int point_type, const LPoint3f pos)\n"
      "DNASuitPoint(unsigned int index, int point_type, const LPoint3f pos, int landmark_building_index)\n"
      "");
 }
  return -1;
}


inline void *Dtool_UpcastInterface_DNASuitPoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNASuitPoint) {
    printf("DNASuitPoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNASuitPoint *local_this = (DNASuitPoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNASuitPoint) {
    return local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNASuitPoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNASuitPoint) {
    return from_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNASuitPoint*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNASuitPath
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNASuitPath::add_point(DNASuitPoint *point)
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_add_point_16(PyObject *self, PyObject *arg) {
  DNASuitPath *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPath, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void DNASuitPath::add_point(DNASuitPoint *point)
        DNASuitPoint *arg_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNASuitPoint, 1, "DNASuitPath.add_point", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->add_point(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNASuitPath.add_point() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "add_point(DNASuitPath this, DNASuitPoint point)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPath_add_point_16_comment =
  "C++ Interface:\n"
  "add_point(DNASuitPath this, DNASuitPoint point)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPath_add_point_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPoint *DNASuitPath::get_point(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_get_point_17(PyObject *self, PyObject *arg) {
  DNASuitPath *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPath, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-DNASuitPoint *DNASuitPath::get_point(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      DNASuitPoint *return_value = (local_this)->get_point(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPoint, false, false, (return_value)->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitPath.get_point() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_point(DNASuitPath this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPath_get_point_17_comment =
  "C++ Interface:\n"
  "get_point(DNASuitPath this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPath_get_point_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNASuitPath::get_num_points(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_get_num_points_18(PyObject *self) {
  DNASuitPath *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPath, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNASuitPath::get_num_points(void)
    unsigned int return_value = (local_this)->get_num_points();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitPath.get_num_points() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_points(DNASuitPath this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPath_get_num_points_18_comment =
  "C++ Interface:\n"
  "get_num_points(DNASuitPath this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPath_get_num_points_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int DNASuitPath::get_point_index(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_get_point_index_19(PyObject *self, PyObject *arg) {
  DNASuitPath *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPath, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned short int DNASuitPath::get_point_index(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      unsigned short int return_value = (local_this)->get_point_index(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyLong_FromUnsignedLong(return_value);
#else
        return PyLongOrInt_FromUnsignedLong(return_value);
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitPath.get_point_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_point_index(DNASuitPath this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPath_get_point_index_19_comment =
  "C++ Interface:\n"
  "get_point_index(DNASuitPath this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPath_get_point_index_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitPath::reverse_path(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_reverse_path_20(PyObject *self) {
  DNASuitPath *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitPath, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNASuitPath::reverse_path(void)
    (local_this)->reverse_path();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitPath.reverse_path() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reverse_path(DNASuitPath this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPath_reverse_path_20_comment =
  "C++ Interface:\n"
  "reverse_path(DNASuitPath this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPath_reverse_path_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASuitPath::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_get_class_type_21(PyObject *) {

  // 1-static TypeHandle DNASuitPath::get_class_type(void)
  TypeHandle result = DNASuitPath::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitPath_get_class_type_21_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitPath_get_class_type_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPath::DNASuitPath(void)
 *******************************************************************/
int Dtool_Init_DNASuitPath(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += PyDict_Size(kwds);
    }
    PyErr_Format(PyExc_TypeError,
                 "DNASuitPath() takes no arguments (%d given)",
                 parameter_count);
    return -1;
  }

  // 1-DNASuitPath::DNASuitPath(void)
  DNASuitPath *return_value = new DNASuitPath();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return -1;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return -1;
    }
#endif
    return DTool_PyInit_Finalize(self, return_value, &Dtool_DNASuitPath, true, false);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNASuitPath()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNASuitPath(PyObject *self, PyObject *args) {
  return Dtool_Init_DNASuitPath(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNASuitPath(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNASuitPath) {
    printf("DNASuitPath ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNASuitPath *local_this = (DNASuitPath *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNASuitPath) {
    return local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNASuitPath(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNASuitPath) {
    return from_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNASuitPath*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNASuitEdge
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitEdge::set_zone_id(unsigned short int value)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_set_zone_id_24(PyObject *self, PyObject *arg) {
  DNASuitEdge *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitEdge, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNASuitEdge::set_zone_id(unsigned short int value)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      (local_this)->set_zone_id(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitEdge.set_zone_id() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_zone_id(DNASuitEdge this, unsigned int value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitEdge_set_zone_id_24_comment =
  "C++ Interface:\n"
  "set_zone_id(DNASuitEdge this, unsigned int value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitEdge_set_zone_id_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int DNASuitEdge::get_zone_id(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_zone_id_25(PyObject *self) {
  DNASuitEdge *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitEdge, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline unsigned short int DNASuitEdge::get_zone_id(void)
    unsigned short int return_value = (local_this)->get_zone_id();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitEdge.get_zone_id() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_zone_id(DNASuitEdge this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitEdge_get_zone_id_25_comment =
  "C++ Interface:\n"
  "get_zone_id(DNASuitEdge this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitEdge_get_zone_id_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitEdge::set_start_point(DNASuitPoint *value)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_set_start_point_26(PyObject *self, PyObject *arg) {
  DNASuitEdge *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitEdge, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNASuitEdge::set_start_point(DNASuitPoint *value)
        DNASuitPoint *arg_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNASuitPoint, 1, "DNASuitEdge.set_start_point", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_start_point(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNASuitEdge.set_start_point() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_start_point(DNASuitEdge this, DNASuitPoint value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitEdge_set_start_point_26_comment =
  "C++ Interface:\n"
  "set_start_point(DNASuitEdge this, DNASuitPoint value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitEdge_set_start_point_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DNASuitPoint *DNASuitEdge::get_start_point(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_start_point_27(PyObject *self) {
  DNASuitEdge *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitEdge, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline DNASuitPoint *DNASuitEdge::get_start_point(void)
    DNASuitPoint *return_value = (local_this)->get_start_point();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPoint, false, false, (return_value)->as_typed_object()->get_type_index());
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitEdge.get_start_point() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_start_point(DNASuitEdge this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitEdge_get_start_point_27_comment =
  "C++ Interface:\n"
  "get_start_point(DNASuitEdge this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitEdge_get_start_point_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitEdge::set_end_point(DNASuitPoint *value)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_set_end_point_28(PyObject *self, PyObject *arg) {
  DNASuitEdge *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitEdge, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void DNASuitEdge::set_end_point(DNASuitPoint *value)
        DNASuitPoint *arg_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNASuitPoint, 1, "DNASuitEdge.set_end_point", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_end_point(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNASuitEdge.set_end_point() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_end_point(DNASuitEdge this, DNASuitPoint value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitEdge_set_end_point_28_comment =
  "C++ Interface:\n"
  "set_end_point(DNASuitEdge this, DNASuitPoint value)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitEdge_set_end_point_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DNASuitPoint *DNASuitEdge::get_end_point(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_end_point_29(PyObject *self) {
  DNASuitEdge *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNASuitEdge, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline DNASuitPoint *DNASuitEdge::get_end_point(void)
    DNASuitPoint *return_value = (local_this)->get_end_point();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPoint, false, false, (return_value)->as_typed_object()->get_type_index());
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNASuitEdge.get_end_point() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_end_point(DNASuitEdge this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitEdge_get_end_point_29_comment =
  "C++ Interface:\n"
  "get_end_point(DNASuitEdge this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitEdge_get_end_point_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASuitEdge::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_class_type_30(PyObject *) {

  // 1-static TypeHandle DNASuitEdge::get_class_type(void)
  TypeHandle result = DNASuitEdge::get_class_type();
  TypeHandle *return_value = new TypeHandle(result);
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return (PyObject *)NULL;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_TypeHandle, true, false);
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_class_type()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNASuitEdge_get_class_type_30_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "";
#else
static const char *Dtool_DNASuitEdge_get_class_type_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitEdge::DNASuitEdge(DNASuitPoint *start_point, DNASuitPoint *end_point, unsigned short int zone_id)
 *******************************************************************/
int Dtool_Init_DNASuitEdge(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      // 1-DNASuitEdge::DNASuitEdge(DNASuitPoint *start_point, DNASuitPoint *end_point, unsigned short int zone_id)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static char *keyword_list[] = {(char *)"start_point", (char *)"end_point", (char *)"zone_id", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:DNASuitEdge", keyword_list, &param0, &param1, &param2)) {
        DNASuitPoint *param0_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASuitPoint, 0, "DNASuitEdge.DNASuitEdge", 0, coerced_ptr, report_errors);
DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "DNASuitEdge.DNASuitEdge", 0, coerced_ptr, report_errors);
PyObject *param2_long = PyNumber_Long(param2);
        if (param0_this != NULL && param1_this != NULL && param2_long != NULL) {
          DNASuitEdge *return_value = new DNASuitEdge(param0_this, param1_this, PyLong_AsUnsignedLong(param2_long));
          Py_XDECREF(param2_long);
          Py_XDECREF(coerced);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (PyErr_Occurred()) {
            delete return_value;
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return -1;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              delete return_value;
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, return_value, &Dtool_DNASuitEdge, true, false);
          }
        }
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNASuitEdge(DNASuitPoint start_point, DNASuitPoint end_point, unsigned int zone_id)\n"
      "");
  }
  return -1;
}


/******************************************************************
 * Python type method wrapper for
 * DNASuitEdge::DNASuitEdge(DNASuitPoint *start_point, DNASuitPoint *end_point, unsigned short int zone_id)
 *******************************************************************/
int Dtool_InitNoCoerce_DNASuitEdge(PyObject *self, PyObject *args) {

  // 1-DNASuitEdge::DNASuitEdge(DNASuitPoint *start_point, DNASuitPoint *end_point, unsigned short int zone_id)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  if (PyArg_UnpackTuple(args, "DNASuitEdge", 3, 3, &param0, &param1, &param2)) {
    DNASuitPoint *param0_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASuitPoint, 0, "DNASuitEdge.DNASuitEdge", 0, NULL, true);
DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "DNASuitEdge.DNASuitEdge", 0, NULL, true);
PyObject *param2_long = PyNumber_Long(param2);
    if (param0_this != NULL && param1_this != NULL && param2_long != NULL) {
      DNASuitEdge *return_value = new DNASuitEdge(param0_this, param1_this, PyLong_AsUnsignedLong(param2_long));
      Py_XDECREF(param2_long);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (PyErr_Occurred()) {
        delete return_value;
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return -1;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          delete return_value;
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, return_value, &Dtool_DNASuitEdge, true, false);
      }
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNASuitEdge(DNASuitPoint start_point, DNASuitPoint end_point, unsigned int zone_id)\n"
      "");
  }
  return -1;
}


inline void *Dtool_UpcastInterface_DNASuitEdge(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNASuitEdge) {
    printf("DNASuitEdge ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNASuitEdge *local_this = (DNASuitEdge *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNASuitEdge) {
    return local_this;
  }
  if (requested_type == &Dtool_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNASuitEdge(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNASuitEdge) {
    return from_this;
  }
  if (from_type == &Dtool_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DNASuitEdge*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. SuitLeg
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * double SuitLeg::get_leg_time(void)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_leg_time_35(PyObject *self) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-double SuitLeg::get_leg_time(void)
    double return_value = (local_this)->get_leg_time();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_leg_time() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_leg_time(SuitLeg this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_leg_time_35_comment =
  "C++ Interface:\n"
  "get_leg_time(SuitLeg this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_leg_time_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f SuitLeg::get_pos_at_time(double time)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_pos_at_time_36(PyObject *self, PyObject *arg) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-LPoint3f SuitLeg::get_pos_at_time(double time)
    if (PyNumber_Check(arg)) {
      LPoint3f result = (local_this)->get_pos_at_time(PyFloat_AsDouble(arg));
      LPoint3f *return_value = new LPoint3f(result);
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (PyErr_Occurred()) {
        delete return_value;
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          delete return_value;
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstance((void *)return_value, Dtool_LPoint3f, true, false);
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_pos_at_time() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_pos_at_time(SuitLeg this, double time)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_pos_at_time_36_comment =
  "C++ Interface:\n"
  "get_pos_at_time(SuitLeg this, double time)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_pos_at_time_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f SuitLeg::get_pos_a(void)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_pos_a_37(PyObject *self) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-LPoint3f SuitLeg::get_pos_a(void)
    LPoint3f result = (local_this)->get_pos_a();
    LPoint3f *return_value = new LPoint3f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LPoint3f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_pos_a() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_pos_a(SuitLeg this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_pos_a_37_comment =
  "C++ Interface:\n"
  "get_pos_a(SuitLeg this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_pos_a_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f SuitLeg::get_pos_b(void)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_pos_b_38(PyObject *self) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-LPoint3f SuitLeg::get_pos_b(void)
    LPoint3f result = (local_this)->get_pos_b();
    LPoint3f *return_value = new LPoint3f(result);
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (PyErr_Occurred()) {
      delete return_value;
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        delete return_value;
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LPoint3f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_pos_b() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_pos_b(SuitLeg this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_pos_b_38_comment =
  "C++ Interface:\n"
  "get_pos_b(SuitLeg this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_pos_b_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SuitLeg::set_type(SuitLeg::LegType type)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_set_type_39(PyObject *self, PyObject *arg) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void SuitLeg::set_type(SuitLeg::LegType type)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      (local_this)->set_type((SuitLeg::LegType)param1);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.set_type() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_type(SuitLeg this, int type)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_set_type_39_comment =
  "C++ Interface:\n"
  "set_type(SuitLeg this, int type)\n"
  "\n"
  "// Aliases\n"
  "";
#else
static const char *Dtool_SuitLeg_set_type_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SuitLeg::LegType SuitLeg::get_type(void)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_type_40(PyObject *self) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline SuitLeg::LegType SuitLeg::get_type(void)
    SuitLeg::LegType return_value = (local_this)->get_type();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromLong(return_value);
#else
      return PyInt_FromLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_type() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_type(SuitLeg this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_type_40_comment =
  "C++ Interface:\n"
  "get_type(SuitLeg this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_type_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > const SuitLeg::get_type_name(SuitLeg::LegType leg_type)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_type_name_41(PyObject *, PyObject *arg) {

  // 1-static basic_string< char > const SuitLeg::get_type_name(SuitLeg::LegType leg_type)
  int param0;
  if (PyArg_Parse(arg, "i", &param0)) {
    basic_string< char > const return_value = SuitLeg::get_type_name((SuitLeg::LegType)param0);
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
      return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
    }
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_type_name(int leg_type)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_type_name_41_comment =
  "C++ Interface:\n"
  "get_type_name(int leg_type)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_type_name_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SuitLeg::set_start_time(double value)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_set_start_time_42(PyObject *self, PyObject *arg) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void SuitLeg::set_start_time(double value)
    if (PyNumber_Check(arg)) {
      (local_this)->set_start_time(PyFloat_AsDouble(arg));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.set_start_time() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_start_time(SuitLeg this, double value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_set_start_time_42_comment =
  "C++ Interface:\n"
  "set_start_time(SuitLeg this, double value)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_set_start_time_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SuitLeg::get_start_time(void)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_start_time_43(PyObject *self) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline double SuitLeg::get_start_time(void)
    double return_value = (local_this)->get_start_time();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyFloat_FromDouble(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_start_time() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_start_time(SuitLeg this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_start_time_43_comment =
  "C++ Interface:\n"
  "get_start_time(SuitLeg this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_start_time_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SuitLeg::set_zone_id(unsigned short int value)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_set_zone_id_44(PyObject *self, PyObject *arg) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void SuitLeg::set_zone_id(unsigned short int value)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      (local_this)->set_zone_id(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.set_zone_id() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_zone_id(SuitLeg this, unsigned int value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_set_zone_id_44_comment =
  "C++ Interface:\n"
  "set_zone_id(SuitLeg this, unsigned int value)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_set_zone_id_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int SuitLeg::get_zone_id(void)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_zone_id_45(PyObject *self) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline unsigned short int SuitLeg::get_zone_id(void)
    unsigned short int return_value = (local_this)->get_zone_id();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_zone_id() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_zone_id(SuitLeg this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_zone_id_45_comment =
  "C++ Interface:\n"
  "get_zone_id(SuitLeg this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_zone_id_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SuitLeg::set_block_number(short int value)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_set_block_number_46(PyObject *self, PyObject *arg) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void SuitLeg::set_block_number(short int value)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      (local_this)->set_block_number((short int)param1);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.set_block_number() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_block_number(SuitLeg this, int value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_set_block_number_46_comment =
  "C++ Interface:\n"
  "set_block_number(SuitLeg this, int value)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_set_block_number_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline short int SuitLeg::get_block_number(void)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_block_number_47(PyObject *self) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline short int SuitLeg::get_block_number(void)
    short int return_value = (local_this)->get_block_number();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromLong(return_value);
#else
      return PyInt_FromLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_block_number() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_block_number(SuitLeg this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_block_number_47_comment =
  "C++ Interface:\n"
  "get_block_number(SuitLeg this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_block_number_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SuitLeg::set_point_a(DNASuitPoint *value)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_set_point_a_48(PyObject *self, PyObject *arg) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void SuitLeg::set_point_a(DNASuitPoint *value)
        DNASuitPoint *arg_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNASuitPoint, 1, "SuitLeg.set_point_a", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_point_a(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call SuitLeg.set_point_a() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_point_a(SuitLeg this, DNASuitPoint value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_set_point_a_48_comment =
  "C++ Interface:\n"
  "set_point_a(SuitLeg this, DNASuitPoint value)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_set_point_a_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DNASuitPoint *SuitLeg::get_point_a(void)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_point_a_49(PyObject *self) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline DNASuitPoint *SuitLeg::get_point_a(void)
    DNASuitPoint *return_value = (local_this)->get_point_a();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPoint, false, false, (return_value)->as_typed_object()->get_type_index());
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_point_a() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_point_a(SuitLeg this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_point_a_49_comment =
  "C++ Interface:\n"
  "get_point_a(SuitLeg this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_point_a_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SuitLeg::set_point_b(DNASuitPoint *value)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_set_point_b_50(PyObject *self, PyObject *arg) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void SuitLeg::set_point_b(DNASuitPoint *value)
        DNASuitPoint *arg_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNASuitPoint, 1, "SuitLeg.set_point_b", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_point_b(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call SuitLeg.set_point_b() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_point_b(SuitLeg this, DNASuitPoint value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_set_point_b_50_comment =
  "C++ Interface:\n"
  "set_point_b(SuitLeg this, DNASuitPoint value)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_set_point_b_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DNASuitPoint *SuitLeg::get_point_b(void)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_point_b_51(PyObject *self) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline DNASuitPoint *SuitLeg::get_point_b(void)
    DNASuitPoint *return_value = (local_this)->get_point_b();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPoint, false, false, (return_value)->as_typed_object()->get_type_index());
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_point_b() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_point_b(SuitLeg this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_point_b_51_comment =
  "C++ Interface:\n"
  "get_point_b(SuitLeg this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_point_b_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SuitLeg::set_leg_type(SuitLeg::LegType value)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_set_leg_type_52(PyObject *self, PyObject *arg) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void SuitLeg::set_leg_type(SuitLeg::LegType value)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      (local_this)->set_leg_type((SuitLeg::LegType)param1);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.set_leg_type() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_leg_type(SuitLeg this, int value)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_set_leg_type_52_comment =
  "C++ Interface:\n"
  "set_leg_type(SuitLeg this, int value)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_set_leg_type_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SuitLeg::LegType SuitLeg::get_leg_type(void)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_leg_type_53(PyObject *self) {
  SuitLeg *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLeg, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline SuitLeg::LegType SuitLeg::get_leg_type(void)
    SuitLeg::LegType return_value = (local_this)->get_leg_type();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromLong(return_value);
#else
      return PyInt_FromLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLeg.get_leg_type() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_leg_type(SuitLeg this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLeg_get_leg_type_53_comment =
  "C++ Interface:\n"
  "get_leg_type(SuitLeg this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLeg_get_leg_type_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SuitLeg::SuitLeg(double start_time, unsigned short int zone_id, short int block_number, DNASuitPoint *point_a, DNASuitPoint *point_b, SuitLeg::LegType leg_type, double suit_walk_speed)
 * SuitLeg::SuitLeg(double start_time, unsigned short int zone_id, short int block_number, DNASuitPoint *point_a, DNASuitPoint *point_b, SuitLeg::LegType leg_type, double suit_walk_speed = (4.8))
 *******************************************************************/
int Dtool_Init_SuitLeg(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 6: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        // 1-SuitLeg::SuitLeg(double start_time, unsigned short int zone_id, short int block_number, DNASuitPoint *point_a, DNASuitPoint *point_b, SuitLeg::LegType leg_type, double suit_walk_speed = (4.8))
        double param0;
        PyObject *param1;
        int param2;
        PyObject *param3;
        PyObject *param4;
        int param5;
        static char *keyword_list[] = {(char *)"start_time", (char *)"zone_id", (char *)"block_number", (char *)"point_a", (char *)"point_b", (char *)"leg_type", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "dOiOOi:SuitLeg", keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          PyObject *param1_long = PyNumber_Long(param1);DNASuitPoint *param3_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DNASuitPoint, 3, "SuitLeg.SuitLeg", 0, coerced_ptr, report_errors);
DNASuitPoint *param4_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_DNASuitPoint, 4, "SuitLeg.SuitLeg", 0, coerced_ptr, report_errors);

          if (param1_long != NULL && param3_this != NULL && param4_this != NULL) {
            SuitLeg *return_value = new SuitLeg((double)param0, PyLong_AsUnsignedLong(param1_long), (short int)param2, param3_this, param4_this, (SuitLeg::LegType)param5);
            Py_XDECREF(param1_long);
            Py_XDECREF(coerced);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (PyErr_Occurred()) {
              delete return_value;
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return -1;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              return DTool_PyInit_Finalize(self, return_value, &Dtool_SuitLeg, true, false);
            }
          }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 7: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        // 1-SuitLeg::SuitLeg(double start_time, unsigned short int zone_id, short int block_number, DNASuitPoint *point_a, DNASuitPoint *point_b, SuitLeg::LegType leg_type, double suit_walk_speed)
        double param0;
        PyObject *param1;
        int param2;
        PyObject *param3;
        PyObject *param4;
        int param5;
        double param6;
        static char *keyword_list[] = {(char *)"start_time", (char *)"zone_id", (char *)"block_number", (char *)"point_a", (char *)"point_b", (char *)"leg_type", (char *)"suit_walk_speed", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "dOiOOid:SuitLeg", keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
          PyObject *param1_long = PyNumber_Long(param1);DNASuitPoint *param3_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DNASuitPoint, 3, "SuitLeg.SuitLeg", 0, coerced_ptr, report_errors);
DNASuitPoint *param4_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_DNASuitPoint, 4, "SuitLeg.SuitLeg", 0, coerced_ptr, report_errors);

          if (param1_long != NULL && param3_this != NULL && param4_this != NULL) {
            SuitLeg *return_value = new SuitLeg((double)param0, PyLong_AsUnsignedLong(param1_long), (short int)param2, param3_this, param4_this, (SuitLeg::LegType)param5, (double)param6);
            Py_XDECREF(param1_long);
            Py_XDECREF(coerced);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (PyErr_Occurred()) {
              delete return_value;
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return -1;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              return DTool_PyInit_Finalize(self, return_value, &Dtool_SuitLeg, true, false);
            }
          }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "SuitLeg() takes 6 or 7 arguments (%d given)", parameter_count + 0);
    return -1;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "SuitLeg(double start_time, unsigned int zone_id, int block_number, DNASuitPoint point_a, DNASuitPoint point_b, int leg_type)\n"
      "SuitLeg(double start_time, unsigned int zone_id, int block_number, DNASuitPoint point_a, DNASuitPoint point_b, int leg_type, double suit_walk_speed)\n"
      "");
 }
  return -1;
}


/******************************************************************
 * Python type method wrapper for
 * SuitLeg::SuitLeg(double start_time, unsigned short int zone_id, short int block_number, DNASuitPoint *point_a, DNASuitPoint *point_b, SuitLeg::LegType leg_type, double suit_walk_speed)
 * SuitLeg::SuitLeg(double start_time, unsigned short int zone_id, short int block_number, DNASuitPoint *point_a, DNASuitPoint *point_b, SuitLeg::LegType leg_type, double suit_walk_speed = (4.8))
 *******************************************************************/
int Dtool_InitNoCoerce_SuitLeg(PyObject *self, PyObject *args) {
  int parameter_count = PyTuple_Size(args);
  switch (parameter_count) {
  case 6: {

    // 1-SuitLeg::SuitLeg(double start_time, unsigned short int zone_id, short int block_number, DNASuitPoint *point_a, DNASuitPoint *point_b, SuitLeg::LegType leg_type, double suit_walk_speed = (4.8))
    double param0;
    PyObject *param1;
    int param2;
    PyObject *param3;
    PyObject *param4;
    int param5;
    if (PyArg_ParseTuple(args, "dOiOOi:SuitLeg", &param0, &param1, &param2, &param3, &param4, &param5)) {
      PyObject *param1_long = PyNumber_Long(param1);DNASuitPoint *param3_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DNASuitPoint, 3, "SuitLeg.SuitLeg", 0, NULL, true);
DNASuitPoint *param4_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_DNASuitPoint, 4, "SuitLeg.SuitLeg", 0, NULL, true);

      if (param1_long != NULL && param3_this != NULL && param4_this != NULL) {
        SuitLeg *return_value = new SuitLeg((double)param0, PyLong_AsUnsignedLong(param1_long), (short int)param2, param3_this, param4_this, (SuitLeg::LegType)param5);
        Py_XDECREF(param1_long);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (PyErr_Occurred()) {
          delete return_value;
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return -1;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            delete return_value;
            return -1;
          }
#endif
          return DTool_PyInit_Finalize(self, return_value, &Dtool_SuitLeg, true, false);
        }
      }
    }

    break;
  }
  case 7: {

    // 1-SuitLeg::SuitLeg(double start_time, unsigned short int zone_id, short int block_number, DNASuitPoint *point_a, DNASuitPoint *point_b, SuitLeg::LegType leg_type, double suit_walk_speed)
    double param0;
    PyObject *param1;
    int param2;
    PyObject *param3;
    PyObject *param4;
    int param5;
    double param6;
    if (PyArg_ParseTuple(args, "dOiOOid:SuitLeg", &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
      PyObject *param1_long = PyNumber_Long(param1);DNASuitPoint *param3_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DNASuitPoint, 3, "SuitLeg.SuitLeg", 0, NULL, true);
DNASuitPoint *param4_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_DNASuitPoint, 4, "SuitLeg.SuitLeg", 0, NULL, true);

      if (param1_long != NULL && param3_this != NULL && param4_this != NULL) {
        SuitLeg *return_value = new SuitLeg((double)param0, PyLong_AsUnsignedLong(param1_long), (short int)param2, param3_this, param4_this, (SuitLeg::LegType)param5, (double)param6);
        Py_XDECREF(param1_long);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (PyErr_Occurred()) {
          delete return_value;
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return -1;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            delete return_value;
            return -1;
          }
#endif
          return DTool_PyInit_Finalize(self, return_value, &Dtool_SuitLeg, true, false);
        }
      }
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "SuitLeg() takes 6 or 7 arguments (%d given)", parameter_count + 0);
    return -1;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "SuitLeg(double start_time, unsigned int zone_id, int block_number, DNASuitPoint point_a, DNASuitPoint point_b, int leg_type)\n"
      "SuitLeg(double start_time, unsigned int zone_id, int block_number, DNASuitPoint point_a, DNASuitPoint point_b, int leg_type, double suit_walk_speed)\n"
      "");
 }
  return -1;
}


inline void *Dtool_UpcastInterface_SuitLeg(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_SuitLeg) {
    printf("SuitLeg ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  SuitLeg *local_this = (SuitLeg *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_SuitLeg) {
    return local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_SuitLeg(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_SuitLeg) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. SuitLegList
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * SuitLeg::LegType SuitLegList::get_suit_leg_type(DNASuitPoint::PointType a, DNASuitPoint::PointType b)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_suit_leg_type_57(PyObject *self, PyObject *args, PyObject *kwds) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-SuitLeg::LegType SuitLegList::get_suit_leg_type(DNASuitPoint::PointType a, DNASuitPoint::PointType b)
    int param1;
    int param2;
    static char *keyword_list[] = {(char *)"a", (char *)"b", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_suit_leg_type", keyword_list, &param1, &param2)) {
      SuitLeg::LegType return_value = (local_this)->get_suit_leg_type((DNASuitPoint::PointType)param1, (DNASuitPoint::PointType)param2);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyLong_FromLong(return_value);
#else
        return PyInt_FromLong(return_value);
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_suit_leg_type() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_suit_leg_type(SuitLegList this, int a, int b)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_suit_leg_type_57_comment =
  "C++ Interface:\n"
  "get_suit_leg_type(SuitLegList this, int a, int b)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_suit_leg_type_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int SuitLegList::get_num_legs(void)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_num_legs_58(PyObject *self) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int SuitLegList::get_num_legs(void)
    unsigned int return_value = (local_this)->get_num_legs();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_num_legs() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_legs(SuitLegList this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_num_legs_58_comment =
  "C++ Interface:\n"
  "get_num_legs(SuitLegList this)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_num_legs_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SuitLeg *SuitLegList::get_leg(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_leg_59(PyObject *self, PyObject *arg) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-SuitLeg *SuitLegList::get_leg(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      SuitLeg *return_value = (local_this)->get_leg(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstance((void *)return_value, Dtool_SuitLeg, false, false);
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_leg() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_leg(SuitLegList this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_leg_59_comment =
  "C++ Interface:\n"
  "get_leg(SuitLegList this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_leg_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SuitLeg::LegType SuitLegList::get_type(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_type_60(PyObject *self, PyObject *arg) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-SuitLeg::LegType SuitLegList::get_type(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      SuitLeg::LegType return_value = (local_this)->get_type(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyLong_FromLong(return_value);
#else
        return PyInt_FromLong(return_value);
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_type() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_type(SuitLegList this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_type_60_comment =
  "C++ Interface:\n"
  "get_type(SuitLegList this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_type_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double SuitLegList::get_leg_time(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_leg_time_61(PyObject *self, PyObject *arg) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-double SuitLegList::get_leg_time(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      double return_value = (local_this)->get_leg_time(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        return PyFloat_FromDouble(return_value);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_leg_time() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_leg_time(SuitLegList this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_leg_time_61_comment =
  "C++ Interface:\n"
  "get_leg_time(SuitLegList this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_leg_time_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int SuitLegList::get_zone_id(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_zone_id_62(PyObject *self, PyObject *arg) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned short int SuitLegList::get_zone_id(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      unsigned short int return_value = (local_this)->get_zone_id(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyLong_FromUnsignedLong(return_value);
#else
        return PyLongOrInt_FromUnsignedLong(return_value);
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_zone_id() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_zone_id(SuitLegList this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_zone_id_62_comment =
  "C++ Interface:\n"
  "get_zone_id(SuitLegList this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_zone_id_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * short int SuitLegList::get_block_number(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_block_number_63(PyObject *self, PyObject *arg) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-short int SuitLegList::get_block_number(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      short int return_value = (local_this)->get_block_number(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyLong_FromLong(return_value);
#else
        return PyInt_FromLong(return_value);
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_block_number() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_block_number(SuitLegList this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_block_number_63_comment =
  "C++ Interface:\n"
  "get_block_number(SuitLegList this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_block_number_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPoint *SuitLegList::get_point_a(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_point_a_64(PyObject *self, PyObject *arg) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-DNASuitPoint *SuitLegList::get_point_a(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      DNASuitPoint *return_value = (local_this)->get_point_a(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPoint, false, false, (return_value)->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_point_a() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_point_a(SuitLegList this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_point_a_64_comment =
  "C++ Interface:\n"
  "get_point_a(SuitLegList this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_point_a_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPoint *SuitLegList::get_point_b(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_point_b_65(PyObject *self, PyObject *arg) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-DNASuitPoint *SuitLegList::get_point_b(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      DNASuitPoint *return_value = (local_this)->get_point_b(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPoint, false, false, (return_value)->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_point_b() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_point_b(SuitLegList this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_point_b_65_comment =
  "C++ Interface:\n"
  "get_point_b(SuitLegList this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_point_b_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double SuitLegList::get_start_time(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_start_time_66(PyObject *self, PyObject *arg) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-double SuitLegList::get_start_time(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      double return_value = (local_this)->get_start_time(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        return PyFloat_FromDouble(return_value);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_start_time() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_start_time(SuitLegList this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_start_time_66_comment =
  "C++ Interface:\n"
  "get_start_time(SuitLegList this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_start_time_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int SuitLegList::get_leg_index_at_time(double time, unsigned int start_leg)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_leg_index_at_time_67(PyObject *self, PyObject *args, PyObject *kwds) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int SuitLegList::get_leg_index_at_time(double time, unsigned int start_leg)
    double param1;
    PyObject *param2;
    static char *keyword_list[] = {(char *)"time", (char *)"start_leg", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "dO:get_leg_index_at_time", keyword_list, &param1, &param2)) {
      PyObject *param2_long = PyNumber_Long(param2);
      if (param2_long != NULL) {
        unsigned int return_value = (local_this)->get_leg_index_at_time((double)param1, PyLong_AsUnsignedLong(param2_long));
        Py_XDECREF(param2_long);
        if (PyErr_Occurred()) {
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return (PyObject *)NULL;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
#if PY_MAJOR_VERSION >= 3
          return PyLong_FromUnsignedLong(return_value);
#else
          return PyLongOrInt_FromUnsignedLong(return_value);
#endif
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_leg_index_at_time() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_leg_index_at_time(SuitLegList this, double time, unsigned int start_leg)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_leg_index_at_time_67_comment =
  "C++ Interface:\n"
  "get_leg_index_at_time(SuitLegList this, double time, unsigned int start_leg)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_leg_index_at_time_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool SuitLegList::is_point_in_range(DNASuitPoint *point, double low_time, double high_time)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_is_point_in_range_68(PyObject *self, PyObject *args, PyObject *kwds) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-bool SuitLegList::is_point_in_range(DNASuitPoint *point, double low_time, double high_time)
        PyObject *param1;
        double param2;
        double param3;
        static char *keyword_list[] = {(char *)"point", (char *)"low_time", (char *)"high_time", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Odd:is_point_in_range", keyword_list, &param1, &param2, &param3)) {
          DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "SuitLegList.is_point_in_range", 0, coerced_ptr, report_errors);

          if (param1_this != NULL) {
            bool return_value = (local_this)->is_point_in_range(param1_this, (double)param2, (double)param3);
            Py_XDECREF(coerced);
            if (PyErr_Occurred()) {
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return (PyObject *)NULL;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              return PyBool_FromLong(return_value);
            }
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call SuitLegList.is_point_in_range() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "is_point_in_range(SuitLegList this, DNASuitPoint point, double low_time, double high_time)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_is_point_in_range_68_comment =
  "C++ Interface:\n"
  "is_point_in_range(SuitLegList this, DNASuitPoint point, double low_time, double high_time)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_is_point_in_range_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SuitLeg::LegType SuitLegList::get_next_leg_type(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_next_leg_type_69(PyObject *self, PyObject *arg) {
  SuitLegList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SuitLegList, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-SuitLeg::LegType SuitLegList::get_next_leg_type(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      SuitLeg::LegType return_value = (local_this)->get_next_leg_type(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyLong_FromLong(return_value);
#else
        return PyInt_FromLong(return_value);
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call SuitLegList.get_next_leg_type() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_next_leg_type(SuitLegList this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_SuitLegList_get_next_leg_type_69_comment =
  "C++ Interface:\n"
  "get_next_leg_type(SuitLegList this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_SuitLegList_get_next_leg_type_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SuitLegList::SuitLegList(DNASuitPath *path, DNAStorage *store, double suit_walk_speed)
 * SuitLegList::SuitLegList(DNASuitPath *path, DNAStorage *store, double suit_walk_speed = (4.8))
 *******************************************************************/
int Dtool_Init_SuitLegList(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        // 1-SuitLegList::SuitLegList(DNASuitPath *path, DNAStorage *store, double suit_walk_speed = (4.8))
        PyObject *param0;
        PyObject *param1;
        static char *keyword_list[] = {(char *)"path", (char *)"store", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:SuitLegList", keyword_list, &param0, &param1)) {
          DNASuitPath *param0_this = (DNASuitPath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASuitPath, 0, "SuitLegList.SuitLegList", 0, coerced_ptr, report_errors);
DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "SuitLegList.SuitLegList", 0, coerced_ptr, report_errors);

          if (param0_this != NULL && param1_this != NULL) {
            SuitLegList *return_value = new SuitLegList(param0_this, param1_this);
            Py_XDECREF(coerced);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (PyErr_Occurred()) {
              delete return_value;
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return -1;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              return DTool_PyInit_Finalize(self, return_value, &Dtool_SuitLegList, true, false);
            }
          }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 3: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        // 1-SuitLegList::SuitLegList(DNASuitPath *path, DNAStorage *store, double suit_walk_speed)
        PyObject *param0;
        PyObject *param1;
        double param2;
        static char *keyword_list[] = {(char *)"path", (char *)"store", (char *)"suit_walk_speed", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOd:SuitLegList", keyword_list, &param0, &param1, &param2)) {
          DNASuitPath *param0_this = (DNASuitPath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASuitPath, 0, "SuitLegList.SuitLegList", 0, coerced_ptr, report_errors);
DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "SuitLegList.SuitLegList", 0, coerced_ptr, report_errors);

          if (param0_this != NULL && param1_this != NULL) {
            SuitLegList *return_value = new SuitLegList(param0_this, param1_this, (double)param2);
            Py_XDECREF(coerced);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (PyErr_Occurred()) {
              delete return_value;
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return -1;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              return DTool_PyInit_Finalize(self, return_value, &Dtool_SuitLegList, true, false);
            }
          }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "SuitLegList() takes 2 or 3 arguments (%d given)", parameter_count + 0);
    return -1;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "SuitLegList(DNASuitPath path, DNAStorage store)\n"
      "SuitLegList(DNASuitPath path, DNAStorage store, double suit_walk_speed)\n"
      "");
 }
  return -1;
}


/******************************************************************
 * Python type method wrapper for
 * SuitLegList::SuitLegList(DNASuitPath *path, DNAStorage *store, double suit_walk_speed)
 * SuitLegList::SuitLegList(DNASuitPath *path, DNAStorage *store, double suit_walk_speed = (4.8))
 *******************************************************************/
int Dtool_InitNoCoerce_SuitLegList(PyObject *self, PyObject *args) {
  int parameter_count = PyTuple_Size(args);
  switch (parameter_count) {
  case 2: {

    // 1-SuitLegList::SuitLegList(DNASuitPath *path, DNAStorage *store, double suit_walk_speed = (4.8))
    PyObject *param0;
    PyObject *param1;
    if (PyArg_UnpackTuple(args, "SuitLegList", 2, 2, &param0, &param1)) {
      DNASuitPath *param0_this = (DNASuitPath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASuitPath, 0, "SuitLegList.SuitLegList", 0, NULL, true);
DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "SuitLegList.SuitLegList", 0, NULL, true);

      if (param0_this != NULL && param1_this != NULL) {
        SuitLegList *return_value = new SuitLegList(param0_this, param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (PyErr_Occurred()) {
          delete return_value;
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return -1;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            delete return_value;
            return -1;
          }
#endif
          return DTool_PyInit_Finalize(self, return_value, &Dtool_SuitLegList, true, false);
        }
      }
    }

    break;
  }
  case 3: {

    // 1-SuitLegList::SuitLegList(DNASuitPath *path, DNAStorage *store, double suit_walk_speed)
    PyObject *param0;
    PyObject *param1;
    double param2;
    if (PyArg_ParseTuple(args, "OOd:SuitLegList", &param0, &param1, &param2)) {
      DNASuitPath *param0_this = (DNASuitPath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASuitPath, 0, "SuitLegList.SuitLegList", 0, NULL, true);
DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "SuitLegList.SuitLegList", 0, NULL, true);

      if (param0_this != NULL && param1_this != NULL) {
        SuitLegList *return_value = new SuitLegList(param0_this, param1_this, (double)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (PyErr_Occurred()) {
          delete return_value;
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return -1;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            delete return_value;
            return -1;
          }
#endif
          return DTool_PyInit_Finalize(self, return_value, &Dtool_SuitLegList, true, false);
        }
      }
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "SuitLegList() takes 2 or 3 arguments (%d given)", parameter_count + 0);
    return -1;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "SuitLegList(DNASuitPath path, DNAStorage store)\n"
      "SuitLegList(DNASuitPath path, DNAStorage store, double suit_walk_speed)\n"
      "");
 }
  return -1;
}


inline void *Dtool_UpcastInterface_SuitLegList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_SuitLegList) {
    printf("SuitLegList ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  SuitLegList *local_this = (SuitLegList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_SuitLegList) {
    return local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_SuitLegList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_SuitLegList) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Py Init Code For .. DNASuitPoint | DNASuitPoint
//********************************************************************
PyMethodDef Dtool_Methods_DNASuitPoint[] = {
  { "set_point_type", (PyCFunction) &Dtool_DNASuitPoint_set_point_type_5, METH_O, (char *) Dtool_DNASuitPoint_set_point_type_5_comment},
  { "setPointType", (PyCFunction) &Dtool_DNASuitPoint_set_point_type_5, METH_O, (char *) Dtool_DNASuitPoint_set_point_type_5_comment},
  { "set_index", (PyCFunction) &Dtool_DNASuitPoint_set_index_6, METH_O, (char *) Dtool_DNASuitPoint_set_index_6_comment},
  { "setIndex", (PyCFunction) &Dtool_DNASuitPoint_set_index_6, METH_O, (char *) Dtool_DNASuitPoint_set_index_6_comment},
  { "get_index", (PyCFunction) &Dtool_DNASuitPoint_get_index_7, METH_NOARGS, (char *) Dtool_DNASuitPoint_get_index_7_comment},
  { "getIndex", (PyCFunction) &Dtool_DNASuitPoint_get_index_7, METH_NOARGS, (char *) Dtool_DNASuitPoint_get_index_7_comment},
  { "get_point_type", (PyCFunction) &Dtool_DNASuitPoint_get_point_type_8, METH_NOARGS, (char *) Dtool_DNASuitPoint_get_point_type_8_comment},
  { "getPointType", (PyCFunction) &Dtool_DNASuitPoint_get_point_type_8, METH_NOARGS, (char *) Dtool_DNASuitPoint_get_point_type_8_comment},
  { "set_pos", (PyCFunction) &Dtool_DNASuitPoint_set_pos_9, METH_O, (char *) Dtool_DNASuitPoint_set_pos_9_comment},
  { "setPos", (PyCFunction) &Dtool_DNASuitPoint_set_pos_9, METH_O, (char *) Dtool_DNASuitPoint_set_pos_9_comment},
  { "get_pos", (PyCFunction) &Dtool_DNASuitPoint_get_pos_10, METH_NOARGS, (char *) Dtool_DNASuitPoint_get_pos_10_comment},
  { "getPos", (PyCFunction) &Dtool_DNASuitPoint_get_pos_10, METH_NOARGS, (char *) Dtool_DNASuitPoint_get_pos_10_comment},
  { "set_landmark_building_index", (PyCFunction) &Dtool_DNASuitPoint_set_landmark_building_index_11, METH_O, (char *) Dtool_DNASuitPoint_set_landmark_building_index_11_comment},
  { "setLandmarkBuildingIndex", (PyCFunction) &Dtool_DNASuitPoint_set_landmark_building_index_11, METH_O, (char *) Dtool_DNASuitPoint_set_landmark_building_index_11_comment},
  { "get_landmark_building_index", (PyCFunction) &Dtool_DNASuitPoint_get_landmark_building_index_12, METH_NOARGS, (char *) Dtool_DNASuitPoint_get_landmark_building_index_12_comment},
  { "getLandmarkBuildingIndex", (PyCFunction) &Dtool_DNASuitPoint_get_landmark_building_index_12, METH_NOARGS, (char *) Dtool_DNASuitPoint_get_landmark_building_index_12_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNASuitPoint_get_class_type_13, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASuitPoint_get_class_type_13_comment},
  { "getClassType", (PyCFunction) &Dtool_DNASuitPoint_get_class_type_13, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASuitPoint_get_class_type_13_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNASuitPoint(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypedObject._Dtool_ClassInit(NULL);
    Dtool_DNASuitPoint.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_TypedObject.As_PyTypeObject());
    Dtool_DNASuitPoint.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNASuitPoint.As_PyTypeObject().tp_dict);
    // Enum  DNASuitPoint::PointType;
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "STREET_POINT", PyLong_FromLong(0));
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "STREETPOINT", PyLong_FromLong(0));
#else
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "STREET_POINT", PyInt_FromLong(0));
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "STREETPOINT", PyInt_FromLong(0));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "FRONT_DOOR_POINT", PyLong_FromLong(1));
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "FRONTDOORPOINT", PyLong_FromLong(1));
#else
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "FRONT_DOOR_POINT", PyInt_FromLong(1));
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "FRONTDOORPOINT", PyInt_FromLong(1));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "SIDE_DOOR_POINT", PyLong_FromLong(2));
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "SIDEDOORPOINT", PyLong_FromLong(2));
#else
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "SIDE_DOOR_POINT", PyInt_FromLong(2));
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "SIDEDOORPOINT", PyInt_FromLong(2));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "COGHQ_IN_POINT", PyLong_FromLong(3));
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "COGHQINPOINT", PyLong_FromLong(3));
#else
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "COGHQ_IN_POINT", PyInt_FromLong(3));
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "COGHQINPOINT", PyInt_FromLong(3));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "COGHQ_OUT_POINT", PyLong_FromLong(4));
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "COGHQOUTPOINT", PyLong_FromLong(4));
#else
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "COGHQ_OUT_POINT", PyInt_FromLong(4));
    PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict, "COGHQOUTPOINT", PyInt_FromLong(4));
#endif
    if (PyType_Ready(&Dtool_DNASuitPoint.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASuitPoint)");
      printf("Error in PyType_Ready(DNASuitPoint)");
      return;
    }
    Py_INCREF(&Dtool_DNASuitPoint.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNASuitPoint, DNASuitPoint::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNASuitPoint.As_PyTypeObject());
    PyModule_AddObject(module, "DNASuitPoint", (PyObject *)&Dtool_DNASuitPoint.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNASuitPath | DNASuitPath
//********************************************************************
PyMethodDef Dtool_Methods_DNASuitPath[] = {
  { "add_point", (PyCFunction) &Dtool_DNASuitPath_add_point_16, METH_O, (char *) Dtool_DNASuitPath_add_point_16_comment},
  { "addPoint", (PyCFunction) &Dtool_DNASuitPath_add_point_16, METH_O, (char *) Dtool_DNASuitPath_add_point_16_comment},
  { "get_point", (PyCFunction) &Dtool_DNASuitPath_get_point_17, METH_O, (char *) Dtool_DNASuitPath_get_point_17_comment},
  { "getPoint", (PyCFunction) &Dtool_DNASuitPath_get_point_17, METH_O, (char *) Dtool_DNASuitPath_get_point_17_comment},
  { "get_num_points", (PyCFunction) &Dtool_DNASuitPath_get_num_points_18, METH_NOARGS, (char *) Dtool_DNASuitPath_get_num_points_18_comment},
  { "getNumPoints", (PyCFunction) &Dtool_DNASuitPath_get_num_points_18, METH_NOARGS, (char *) Dtool_DNASuitPath_get_num_points_18_comment},
  { "get_point_index", (PyCFunction) &Dtool_DNASuitPath_get_point_index_19, METH_O, (char *) Dtool_DNASuitPath_get_point_index_19_comment},
  { "getPointIndex", (PyCFunction) &Dtool_DNASuitPath_get_point_index_19, METH_O, (char *) Dtool_DNASuitPath_get_point_index_19_comment},
  { "reverse_path", (PyCFunction) &Dtool_DNASuitPath_reverse_path_20, METH_NOARGS, (char *) Dtool_DNASuitPath_reverse_path_20_comment},
  { "reversePath", (PyCFunction) &Dtool_DNASuitPath_reverse_path_20, METH_NOARGS, (char *) Dtool_DNASuitPath_reverse_path_20_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNASuitPath_get_class_type_21, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASuitPath_get_class_type_21_comment},
  { "getClassType", (PyCFunction) &Dtool_DNASuitPath_get_class_type_21, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASuitPath_get_class_type_21_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNASuitPath(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypedObject._Dtool_ClassInit(NULL);
    Dtool_DNASuitPath.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_TypedObject.As_PyTypeObject());
    Dtool_DNASuitPath.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNASuitPath.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNASuitPath.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNASuitPath.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASuitPath)");
      printf("Error in PyType_Ready(DNASuitPath)");
      return;
    }
    Py_INCREF(&Dtool_DNASuitPath.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNASuitPath, DNASuitPath::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNASuitPath.As_PyTypeObject());
    PyModule_AddObject(module, "DNASuitPath", (PyObject *)&Dtool_DNASuitPath.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNASuitEdge | DNASuitEdge
//********************************************************************
PyMethodDef Dtool_Methods_DNASuitEdge[] = {
  { "set_zone_id", (PyCFunction) &Dtool_DNASuitEdge_set_zone_id_24, METH_O, (char *) Dtool_DNASuitEdge_set_zone_id_24_comment},
  { "setZoneId", (PyCFunction) &Dtool_DNASuitEdge_set_zone_id_24, METH_O, (char *) Dtool_DNASuitEdge_set_zone_id_24_comment},
  { "get_zone_id", (PyCFunction) &Dtool_DNASuitEdge_get_zone_id_25, METH_NOARGS, (char *) Dtool_DNASuitEdge_get_zone_id_25_comment},
  { "getZoneId", (PyCFunction) &Dtool_DNASuitEdge_get_zone_id_25, METH_NOARGS, (char *) Dtool_DNASuitEdge_get_zone_id_25_comment},
  { "set_start_point", (PyCFunction) &Dtool_DNASuitEdge_set_start_point_26, METH_O, (char *) Dtool_DNASuitEdge_set_start_point_26_comment},
  { "setStartPoint", (PyCFunction) &Dtool_DNASuitEdge_set_start_point_26, METH_O, (char *) Dtool_DNASuitEdge_set_start_point_26_comment},
  { "get_start_point", (PyCFunction) &Dtool_DNASuitEdge_get_start_point_27, METH_NOARGS, (char *) Dtool_DNASuitEdge_get_start_point_27_comment},
  { "getStartPoint", (PyCFunction) &Dtool_DNASuitEdge_get_start_point_27, METH_NOARGS, (char *) Dtool_DNASuitEdge_get_start_point_27_comment},
  { "set_end_point", (PyCFunction) &Dtool_DNASuitEdge_set_end_point_28, METH_O, (char *) Dtool_DNASuitEdge_set_end_point_28_comment},
  { "setEndPoint", (PyCFunction) &Dtool_DNASuitEdge_set_end_point_28, METH_O, (char *) Dtool_DNASuitEdge_set_end_point_28_comment},
  { "get_end_point", (PyCFunction) &Dtool_DNASuitEdge_get_end_point_29, METH_NOARGS, (char *) Dtool_DNASuitEdge_get_end_point_29_comment},
  { "getEndPoint", (PyCFunction) &Dtool_DNASuitEdge_get_end_point_29, METH_NOARGS, (char *) Dtool_DNASuitEdge_get_end_point_29_comment},
  { "get_class_type", (PyCFunction) &Dtool_DNASuitEdge_get_class_type_30, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASuitEdge_get_class_type_30_comment},
  { "getClassType", (PyCFunction) &Dtool_DNASuitEdge_get_class_type_30, METH_NOARGS | METH_STATIC, (char *) Dtool_DNASuitEdge_get_class_type_30_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNASuitEdge(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypedObject._Dtool_ClassInit(NULL);
    Dtool_DNASuitEdge.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_TypedObject.As_PyTypeObject());
    Dtool_DNASuitEdge.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNASuitEdge.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNASuitEdge.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNASuitEdge.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASuitEdge)");
      printf("Error in PyType_Ready(DNASuitEdge)");
      return;
    }
    Py_INCREF(&Dtool_DNASuitEdge.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNASuitEdge, DNASuitEdge::get_class_type().get_index());
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNASuitEdge.As_PyTypeObject());
    PyModule_AddObject(module, "DNASuitEdge", (PyObject *)&Dtool_DNASuitEdge.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. SuitLeg | SuitLeg
//********************************************************************
PyMethodDef Dtool_Methods_SuitLeg[] = {
  { "get_leg_time", (PyCFunction) &Dtool_SuitLeg_get_leg_time_35, METH_NOARGS, (char *) Dtool_SuitLeg_get_leg_time_35_comment},
  { "getLegTime", (PyCFunction) &Dtool_SuitLeg_get_leg_time_35, METH_NOARGS, (char *) Dtool_SuitLeg_get_leg_time_35_comment},
  { "get_pos_at_time", (PyCFunction) &Dtool_SuitLeg_get_pos_at_time_36, METH_O, (char *) Dtool_SuitLeg_get_pos_at_time_36_comment},
  { "getPosAtTime", (PyCFunction) &Dtool_SuitLeg_get_pos_at_time_36, METH_O, (char *) Dtool_SuitLeg_get_pos_at_time_36_comment},
  { "get_pos_a", (PyCFunction) &Dtool_SuitLeg_get_pos_a_37, METH_NOARGS, (char *) Dtool_SuitLeg_get_pos_a_37_comment},
  { "getPosA", (PyCFunction) &Dtool_SuitLeg_get_pos_a_37, METH_NOARGS, (char *) Dtool_SuitLeg_get_pos_a_37_comment},
  { "get_pos_b", (PyCFunction) &Dtool_SuitLeg_get_pos_b_38, METH_NOARGS, (char *) Dtool_SuitLeg_get_pos_b_38_comment},
  { "getPosB", (PyCFunction) &Dtool_SuitLeg_get_pos_b_38, METH_NOARGS, (char *) Dtool_SuitLeg_get_pos_b_38_comment},
  { "set_type", (PyCFunction) &Dtool_SuitLeg_set_type_39, METH_O, (char *) Dtool_SuitLeg_set_type_39_comment},
  { "setType", (PyCFunction) &Dtool_SuitLeg_set_type_39, METH_O, (char *) Dtool_SuitLeg_set_type_39_comment},
  { "get_type", (PyCFunction) &Dtool_SuitLeg_get_type_40, METH_NOARGS, (char *) Dtool_SuitLeg_get_type_40_comment},
  { "getType", (PyCFunction) &Dtool_SuitLeg_get_type_40, METH_NOARGS, (char *) Dtool_SuitLeg_get_type_40_comment},
  { "get_type_name", (PyCFunction) &Dtool_SuitLeg_get_type_name_41, METH_O | METH_STATIC, (char *) Dtool_SuitLeg_get_type_name_41_comment},
  { "getTypeName", (PyCFunction) &Dtool_SuitLeg_get_type_name_41, METH_O | METH_STATIC, (char *) Dtool_SuitLeg_get_type_name_41_comment},
  { "set_start_time", (PyCFunction) &Dtool_SuitLeg_set_start_time_42, METH_O, (char *) Dtool_SuitLeg_set_start_time_42_comment},
  { "setStartTime", (PyCFunction) &Dtool_SuitLeg_set_start_time_42, METH_O, (char *) Dtool_SuitLeg_set_start_time_42_comment},
  { "get_start_time", (PyCFunction) &Dtool_SuitLeg_get_start_time_43, METH_NOARGS, (char *) Dtool_SuitLeg_get_start_time_43_comment},
  { "getStartTime", (PyCFunction) &Dtool_SuitLeg_get_start_time_43, METH_NOARGS, (char *) Dtool_SuitLeg_get_start_time_43_comment},
  { "set_zone_id", (PyCFunction) &Dtool_SuitLeg_set_zone_id_44, METH_O, (char *) Dtool_SuitLeg_set_zone_id_44_comment},
  { "setZoneId", (PyCFunction) &Dtool_SuitLeg_set_zone_id_44, METH_O, (char *) Dtool_SuitLeg_set_zone_id_44_comment},
  { "get_zone_id", (PyCFunction) &Dtool_SuitLeg_get_zone_id_45, METH_NOARGS, (char *) Dtool_SuitLeg_get_zone_id_45_comment},
  { "getZoneId", (PyCFunction) &Dtool_SuitLeg_get_zone_id_45, METH_NOARGS, (char *) Dtool_SuitLeg_get_zone_id_45_comment},
  { "set_block_number", (PyCFunction) &Dtool_SuitLeg_set_block_number_46, METH_O, (char *) Dtool_SuitLeg_set_block_number_46_comment},
  { "setBlockNumber", (PyCFunction) &Dtool_SuitLeg_set_block_number_46, METH_O, (char *) Dtool_SuitLeg_set_block_number_46_comment},
  { "get_block_number", (PyCFunction) &Dtool_SuitLeg_get_block_number_47, METH_NOARGS, (char *) Dtool_SuitLeg_get_block_number_47_comment},
  { "getBlockNumber", (PyCFunction) &Dtool_SuitLeg_get_block_number_47, METH_NOARGS, (char *) Dtool_SuitLeg_get_block_number_47_comment},
  { "set_point_a", (PyCFunction) &Dtool_SuitLeg_set_point_a_48, METH_O, (char *) Dtool_SuitLeg_set_point_a_48_comment},
  { "setPointA", (PyCFunction) &Dtool_SuitLeg_set_point_a_48, METH_O, (char *) Dtool_SuitLeg_set_point_a_48_comment},
  { "get_point_a", (PyCFunction) &Dtool_SuitLeg_get_point_a_49, METH_NOARGS, (char *) Dtool_SuitLeg_get_point_a_49_comment},
  { "getPointA", (PyCFunction) &Dtool_SuitLeg_get_point_a_49, METH_NOARGS, (char *) Dtool_SuitLeg_get_point_a_49_comment},
  { "set_point_b", (PyCFunction) &Dtool_SuitLeg_set_point_b_50, METH_O, (char *) Dtool_SuitLeg_set_point_b_50_comment},
  { "setPointB", (PyCFunction) &Dtool_SuitLeg_set_point_b_50, METH_O, (char *) Dtool_SuitLeg_set_point_b_50_comment},
  { "get_point_b", (PyCFunction) &Dtool_SuitLeg_get_point_b_51, METH_NOARGS, (char *) Dtool_SuitLeg_get_point_b_51_comment},
  { "getPointB", (PyCFunction) &Dtool_SuitLeg_get_point_b_51, METH_NOARGS, (char *) Dtool_SuitLeg_get_point_b_51_comment},
  { "set_leg_type", (PyCFunction) &Dtool_SuitLeg_set_leg_type_52, METH_O, (char *) Dtool_SuitLeg_set_leg_type_52_comment},
  { "setLegType", (PyCFunction) &Dtool_SuitLeg_set_leg_type_52, METH_O, (char *) Dtool_SuitLeg_set_leg_type_52_comment},
  { "get_leg_type", (PyCFunction) &Dtool_SuitLeg_get_leg_type_53, METH_NOARGS, (char *) Dtool_SuitLeg_get_leg_type_53_comment},
  { "getLegType", (PyCFunction) &Dtool_SuitLeg_get_leg_type_53, METH_NOARGS, (char *) Dtool_SuitLeg_get_leg_type_53_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_SuitLeg(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DTOOL_SUPER_BASE._Dtool_ClassInit(NULL);
    Dtool_SuitLeg.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DTOOL_SUPER_BASE.As_PyTypeObject());
    Dtool_SuitLeg.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_SuitLeg.As_PyTypeObject().tp_dict);
    // Enum  SuitLeg::LegType;
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_walk_from_street", PyLong_FromLong(0));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TWalkFromStreet", PyLong_FromLong(0));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_walk_from_street", PyInt_FromLong(0));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TWalkFromStreet", PyInt_FromLong(0));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_walk_to_street", PyLong_FromLong(1));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TWalkToStreet", PyLong_FromLong(1));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_walk_to_street", PyInt_FromLong(1));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TWalkToStreet", PyInt_FromLong(1));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_walk", PyLong_FromLong(2));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TWalk", PyLong_FromLong(2));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_walk", PyInt_FromLong(2));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TWalk", PyInt_FromLong(2));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_from_sky", PyLong_FromLong(3));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TFromSky", PyLong_FromLong(3));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_from_sky", PyInt_FromLong(3));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TFromSky", PyInt_FromLong(3));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_to_sky", PyLong_FromLong(4));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TToSky", PyLong_FromLong(4));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_to_sky", PyInt_FromLong(4));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TToSky", PyInt_FromLong(4));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_from_suit_building", PyLong_FromLong(5));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TFromSuitBuilding", PyLong_FromLong(5));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_from_suit_building", PyInt_FromLong(5));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TFromSuitBuilding", PyInt_FromLong(5));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_to_suit_building", PyLong_FromLong(6));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TToSuitBuilding", PyLong_FromLong(6));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_to_suit_building", PyInt_FromLong(6));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TToSuitBuilding", PyInt_FromLong(6));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_to_toon_building", PyLong_FromLong(7));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TToToonBuilding", PyLong_FromLong(7));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_to_toon_building", PyInt_FromLong(7));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TToToonBuilding", PyInt_FromLong(7));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_from_cog_HQ", PyLong_FromLong(8));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TFromCogHQ", PyLong_FromLong(8));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_from_cog_HQ", PyInt_FromLong(8));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TFromCogHQ", PyInt_FromLong(8));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_to_cog_HQ", PyLong_FromLong(9));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TToCogHQ", PyLong_FromLong(9));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_to_cog_HQ", PyInt_FromLong(9));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TToCogHQ", PyInt_FromLong(9));
#endif
#if PY_MAJOR_VERSION >= 3
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_off", PyLong_FromLong(10));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TOff", PyLong_FromLong(10));
#else
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "T_off", PyInt_FromLong(10));
    PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict, "TOff", PyInt_FromLong(10));
#endif
    if (PyType_Ready(&Dtool_SuitLeg.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(SuitLeg)");
      printf("Error in PyType_Ready(SuitLeg)");
      return;
    }
    Py_INCREF(&Dtool_SuitLeg.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_SuitLeg, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_SuitLeg.As_PyTypeObject());
    PyModule_AddObject(module, "SuitLeg", (PyObject *)&Dtool_SuitLeg.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. SuitLegList | SuitLegList
//********************************************************************
PyMethodDef Dtool_Methods_SuitLegList[] = {
  { "get_suit_leg_type", (PyCFunction) &Dtool_SuitLegList_get_suit_leg_type_57, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_SuitLegList_get_suit_leg_type_57_comment},
  { "getSuitLegType", (PyCFunction) &Dtool_SuitLegList_get_suit_leg_type_57, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_SuitLegList_get_suit_leg_type_57_comment},
  { "get_num_legs", (PyCFunction) &Dtool_SuitLegList_get_num_legs_58, METH_NOARGS, (char *) Dtool_SuitLegList_get_num_legs_58_comment},
  { "getNumLegs", (PyCFunction) &Dtool_SuitLegList_get_num_legs_58, METH_NOARGS, (char *) Dtool_SuitLegList_get_num_legs_58_comment},
  { "get_leg", (PyCFunction) &Dtool_SuitLegList_get_leg_59, METH_O, (char *) Dtool_SuitLegList_get_leg_59_comment},
  { "getLeg", (PyCFunction) &Dtool_SuitLegList_get_leg_59, METH_O, (char *) Dtool_SuitLegList_get_leg_59_comment},
  { "get_type", (PyCFunction) &Dtool_SuitLegList_get_type_60, METH_O, (char *) Dtool_SuitLegList_get_type_60_comment},
  { "getType", (PyCFunction) &Dtool_SuitLegList_get_type_60, METH_O, (char *) Dtool_SuitLegList_get_type_60_comment},
  { "get_leg_time", (PyCFunction) &Dtool_SuitLegList_get_leg_time_61, METH_O, (char *) Dtool_SuitLegList_get_leg_time_61_comment},
  { "getLegTime", (PyCFunction) &Dtool_SuitLegList_get_leg_time_61, METH_O, (char *) Dtool_SuitLegList_get_leg_time_61_comment},
  { "get_zone_id", (PyCFunction) &Dtool_SuitLegList_get_zone_id_62, METH_O, (char *) Dtool_SuitLegList_get_zone_id_62_comment},
  { "getZoneId", (PyCFunction) &Dtool_SuitLegList_get_zone_id_62, METH_O, (char *) Dtool_SuitLegList_get_zone_id_62_comment},
  { "get_block_number", (PyCFunction) &Dtool_SuitLegList_get_block_number_63, METH_O, (char *) Dtool_SuitLegList_get_block_number_63_comment},
  { "getBlockNumber", (PyCFunction) &Dtool_SuitLegList_get_block_number_63, METH_O, (char *) Dtool_SuitLegList_get_block_number_63_comment},
  { "get_point_a", (PyCFunction) &Dtool_SuitLegList_get_point_a_64, METH_O, (char *) Dtool_SuitLegList_get_point_a_64_comment},
  { "getPointA", (PyCFunction) &Dtool_SuitLegList_get_point_a_64, METH_O, (char *) Dtool_SuitLegList_get_point_a_64_comment},
  { "get_point_b", (PyCFunction) &Dtool_SuitLegList_get_point_b_65, METH_O, (char *) Dtool_SuitLegList_get_point_b_65_comment},
  { "getPointB", (PyCFunction) &Dtool_SuitLegList_get_point_b_65, METH_O, (char *) Dtool_SuitLegList_get_point_b_65_comment},
  { "get_start_time", (PyCFunction) &Dtool_SuitLegList_get_start_time_66, METH_O, (char *) Dtool_SuitLegList_get_start_time_66_comment},
  { "getStartTime", (PyCFunction) &Dtool_SuitLegList_get_start_time_66, METH_O, (char *) Dtool_SuitLegList_get_start_time_66_comment},
  { "get_leg_index_at_time", (PyCFunction) &Dtool_SuitLegList_get_leg_index_at_time_67, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_SuitLegList_get_leg_index_at_time_67_comment},
  { "getLegIndexAtTime", (PyCFunction) &Dtool_SuitLegList_get_leg_index_at_time_67, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_SuitLegList_get_leg_index_at_time_67_comment},
  { "is_point_in_range", (PyCFunction) &Dtool_SuitLegList_is_point_in_range_68, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_SuitLegList_is_point_in_range_68_comment},
  { "isPointInRange", (PyCFunction) &Dtool_SuitLegList_is_point_in_range_68, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_SuitLegList_is_point_in_range_68_comment},
  { "get_next_leg_type", (PyCFunction) &Dtool_SuitLegList_get_next_leg_type_69, METH_O, (char *) Dtool_SuitLegList_get_next_leg_type_69_comment},
  { "getNextLegType", (PyCFunction) &Dtool_SuitLegList_get_next_leg_type_69, METH_O, (char *) Dtool_SuitLegList_get_next_leg_type_69_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_SuitLegList(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DTOOL_SUPER_BASE._Dtool_ClassInit(NULL);
    Dtool_SuitLegList.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DTOOL_SUPER_BASE.As_PyTypeObject());
    Dtool_SuitLegList.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_SuitLegList.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_SuitLegList.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_SuitLegList.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(SuitLegList)");
      printf("Error in PyType_Ready(SuitLegList)");
      return;
    }
    Py_INCREF(&Dtool_SuitLegList.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_SuitLegList, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_SuitLegList.As_PyTypeObject());
    PyModule_AddObject(module, "SuitLegList", (PyObject *)&Dtool_SuitLegList.As_PyTypeObject());
  }
}


//********************************************************************
//*** Module Object Linker ..
//********************************************************************
static void BuildInstants(PyObject * module) {
  // Module init upcall for DNASuitPoint
  Dtool_PyModuleClassInit_DNASuitPoint(module);
  // Module init upcall for DNASuitPath
  Dtool_PyModuleClassInit_DNASuitPath(module);
  // Module init upcall for DNASuitEdge
  Dtool_PyModuleClassInit_DNASuitEdge(module);
  // Module init upcall for SuitLeg
  Dtool_PyModuleClassInit_SuitLeg(module);
  // Module init upcall for SuitLegList
  Dtool_PyModuleClassInit_SuitLegList(module);
//********************************************************************
//*** Module Init Upcall ..  Externally Defined Class
//********************************************************************
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

EXPORT_THIS struct LibraryDef suit_moddef = {python_simple_funcs, BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1425837832,  /* file_identifier */
  "suit",  /* library_name */
  "Iydx",  /* library_hash_name */
  "libpandadna",  /* module_name */
  "suit.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  152  /* next_index */
};

Configure(_in_configure_suit);
ConfigureFn(_in_configure_suit) {
  interrogate_request_module(&_in_module_def);
}

