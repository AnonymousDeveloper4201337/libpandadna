/*
 * This file generated by:
 * C:\Panda3D-ttn\bin\interrogate.exe -D__inline -DCPPPARSER -DP3_INTERROGATE=1 -D__cplusplus -fnames -string -refcount -assert -S C:\Panda3D-ttn\include\parser-inc -S C:\Panda3D-ttn\include -I C:\Panda3D-ttn\include -IC:/Users/Usuario/workspace/libpandadna/src\suit -IC:/Users/Usuario/workspace/libpandadna/src\base -IC:/Users/Usuario/workspace/libpandadna/src\components -srcdir C:/Users/Usuario/workspace/libpandadna/src\base -oc C:/Users/Usuario/workspace/libpandadna/src\base_igate.cxx -od C:/Users/Usuario/workspace/libpandadna/src\base.in -python-native -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -module libpandadna -library base -Dvolatile= DNAStorage.h DNALoader.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_base
#include "py_panda.h"
#include "extension.h"

#include "DNAGroup.h"
#include "DNALoader.h"
#include "DNAStorage.h"
#include "DNASuitEdge.h"
#include "DNASuitPath.h"
#include "DNAVisGroup.h"
#include "dnabase.h"
#include <nodePath.h>
#include <textFont.h>
#include <texture.h>

#undef _POSIX_C_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif

//********************************************************************
//*** prototypes for .. Global
//********************************************************************
//********************************************************************
//*** prototypes for .. DNAStorage
//********************************************************************
typedef DNAStorage DNAStorage_localtype;
Define_Module_Class(libpandadna, DNAStorage, DNAStorage_localtype, DNAStorage);

//********************************************************************
//*** prototypes for .. DNALoader
//********************************************************************
typedef DNALoader DNALoader_localtype;
Define_Module_Class(libpandadna, DNALoader, DNALoader_localtype, DNALoader);

//********************************************************************
//*** prototypes for .. External Objects
//********************************************************************
IMPORT_THIS struct Dtool_PyTypedObject Dtool_DNAGroup;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_DNASuitEdge;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_DNASuitPath;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_DNASuitPoint;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_DNAVisGroup;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_TextFont;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_Texture;

//********************************************************************
//*** Functions for .. Global
//********************************************************************
//********************************************************************
//*** Functions for .. DNAStorage
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_DNA_groups(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_DNA_groups_4(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAStorage::reset_DNA_groups(void)
    (local_this)->reset_DNA_groups();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_DNA_groups() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_DNA_groups(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_DNA_groups_4_comment =
  "C++ Interface:\n"
  "reset_DNA_groups(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_DNA_groups_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_battle_cells(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_battle_cells_5(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DNAStorage::reset_battle_cells(void)
    (local_this)->reset_battle_cells();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_battle_cells() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_battle_cells(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_battle_cells_5_comment =
  "C++ Interface:\n"
  "reset_battle_cells(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_battle_cells_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_DNA_vis_group(DNAVisGroup *group)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_DNA_vis_group_6(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void DNAStorage::store_DNA_vis_group(DNAVisGroup *group)
        DNAVisGroup *arg_this = (DNAVisGroup *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNAVisGroup, 1, "DNAStorage.store_DNA_vis_group", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->store_DNA_vis_group(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAStorage.store_DNA_vis_group() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_DNA_vis_group(DNAStorage this, DNAVisGroup group)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_DNA_vis_group_6_comment =
  "C++ Interface:\n"
  "store_DNA_vis_group(DNAStorage this, DNAVisGroup group)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_DNA_vis_group_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAStorage::get_num_DNA_vis_groups(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_DNA_vis_groups_7(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAStorage::get_num_DNA_vis_groups(void)
    unsigned int return_value = (local_this)->get_num_DNA_vis_groups();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_num_DNA_vis_groups() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_DNA_vis_groups(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_num_DNA_vis_groups_7_comment =
  "C++ Interface:\n"
  "get_num_DNA_vis_groups(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_num_DNA_vis_groups_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAStorage::get_num_DNA_vis_groups_AI(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_DNA_vis_groups_AI_8(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAStorage::get_num_DNA_vis_groups_AI(void)
    unsigned int return_value = (local_this)->get_num_DNA_vis_groups_AI();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_num_DNA_vis_groups_AI() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_DNA_vis_groups_AI(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_num_DNA_vis_groups_AI_8_comment =
  "C++ Interface:\n"
  "get_num_DNA_vis_groups_AI(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_num_DNA_vis_groups_AI_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAStorage::get_num_visibles_in_DNA_vis_group(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_visibles_in_DNA_vis_group_9(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAStorage::get_num_visibles_in_DNA_vis_group(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      unsigned int return_value = (local_this)->get_num_visibles_in_DNA_vis_group(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyLong_FromUnsignedLong(return_value);
#else
        return PyLongOrInt_FromUnsignedLong(return_value);
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_num_visibles_in_DNA_vis_group() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_visibles_in_DNA_vis_group(DNAStorage this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_num_visibles_in_DNA_vis_group_9_comment =
  "C++ Interface:\n"
  "get_num_visibles_in_DNA_vis_group(DNAStorage this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_num_visibles_in_DNA_vis_group_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_visible_name(unsigned int index, unsigned int visible_index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_visible_name_10(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-basic_string< char > DNAStorage::get_visible_name(unsigned int index, unsigned int visible_index)
    PyObject *param1;
    PyObject *param2;
    static char *keyword_list[] = {(char *)"index", (char *)"visible_index", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_visible_name", keyword_list, &param1, &param2)) {
      PyObject *param1_long = PyNumber_Long(param1);PyObject *param2_long = PyNumber_Long(param2);
      if (param1_long != NULL && param2_long != NULL) {
        basic_string< char > return_value = (local_this)->get_visible_name(PyLong_AsUnsignedLong(param1_long), PyLong_AsUnsignedLong(param2_long));
        Py_XDECREF(param1_long);Py_XDECREF(param2_long);
        if (PyErr_Occurred()) {
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return (PyObject *)NULL;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
#if PY_MAJOR_VERSION >= 3
          return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
          return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_visible_name() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_visible_name(DNAStorage this, unsigned int index, unsigned int visible_index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_visible_name_10_comment =
  "C++ Interface:\n"
  "get_visible_name(DNAStorage this, unsigned int index, unsigned int visible_index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_visible_name_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAVisGroup *DNAStorage::get_DNA_vis_group_AI(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_DNA_vis_group_AI_11(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-DNAVisGroup *DNAStorage::get_DNA_vis_group_AI(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      DNAVisGroup *return_value = (local_this)->get_DNA_vis_group_AI(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNAVisGroup, false, false, (return_value)->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_DNA_vis_group_AI() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_DNA_vis_group_AI(DNAStorage this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_DNA_vis_group_AI_11_comment =
  "C++ Interface:\n"
  "get_DNA_vis_group_AI(DNAStorage this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_DNA_vis_group_AI_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_DNA_vis_group_name(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_DNA_vis_group_name_12(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-basic_string< char > DNAStorage::get_DNA_vis_group_name(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      basic_string< char > return_value = (local_this)->get_DNA_vis_group_name(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
        return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_DNA_vis_group_name() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_DNA_vis_group_name(DNAStorage this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_DNA_vis_group_name_12_comment =
  "C++ Interface:\n"
  "get_DNA_vis_group_name(DNAStorage this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_DNA_vis_group_name_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_DNA_vis_groups(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_DNA_vis_groups_13(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_DNA_vis_groups(void)
    (local_this)->reset_DNA_vis_groups();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_DNA_vis_groups() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_DNA_vis_groups(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_DNA_vis_groups_13_comment =
  "C++ Interface:\n"
  "reset_DNA_vis_groups(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_DNA_vis_groups_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_DNA_vis_groups_AI(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_DNA_vis_groups_AI_14(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_DNA_vis_groups_AI(void)
    (local_this)->reset_DNA_vis_groups_AI();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_DNA_vis_groups_AI() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_DNA_vis_groups_AI(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_DNA_vis_groups_AI_14_comment =
  "C++ Interface:\n"
  "reset_DNA_vis_groups_AI(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_DNA_vis_groups_AI_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_texture(basic_string< char > const &name, PointerTo< Texture > texture)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_texture_15(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void DNAStorage::store_texture(basic_string< char > const &name, PointerTo< Texture > texture)
        char *param1_str;
        Py_ssize_t param1_len;
        PyObject *param2;
        static char *keyword_list[] = {(char *)"name", (char *)"texture", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:store_texture", keyword_list, &param1_str, &param1_len, &param2)) {
          Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Texture, 2, "DNAStorage.store_texture", 1, coerced_ptr, report_errors);

          if (param2_this != NULL) {
            (local_this)->store_texture(basic_string<char>(param1_str, param1_len), param2_this);
            Py_XDECREF(coerced);
            if (PyErr_Occurred()) {
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return (PyObject *)NULL;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAStorage.store_texture() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_texture(DNAStorage this, str name, const Texture texture)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_texture_15_comment =
  "C++ Interface:\n"
  "store_texture(DNAStorage this, str name, const Texture texture)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_texture_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< Texture > DNAStorage::find_texture(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_texture_16(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-PointerTo< Texture > DNAStorage::find_texture(basic_string< char > const &name)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      PointerTo< Texture > return_value = (local_this)->find_texture(basic_string<char>(param1_str, param1_len));
      if (return_value != (Texture *)NULL) {
        return_value->ref();
      }
      if (PyErr_Occurred()) {
        if (return_value.p() != (Texture *)NULL) {
          unref_delete(return_value.p());
        }
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          if (return_value.p() != (Texture *)NULL) {
            unref_delete(return_value.p());
          }
          return (PyObject *)NULL;
        }
#endif
        if (return_value.p() == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value.p(), Dtool_Texture, true, false, (return_value.p())->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.find_texture() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "find_texture(DNAStorage this, str name)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_find_texture_16_comment =
  "C++ Interface:\n"
  "find_texture(DNAStorage this, str name)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_find_texture_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_textures(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_textures_17(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_textures(void)
    (local_this)->reset_textures();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_textures() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_textures(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_textures_17_comment =
  "C++ Interface:\n"
  "reset_textures(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_textures_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_font(basic_string< char > const &code, PointerTo< TextFont > font)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_font_18(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void DNAStorage::store_font(basic_string< char > const &code, PointerTo< TextFont > font)
        char *param1_str;
        Py_ssize_t param1_len;
        PyObject *param2;
        static char *keyword_list[] = {(char *)"code", (char *)"font", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:store_font", keyword_list, &param1_str, &param1_len, &param2)) {
          TextFont *param2_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TextFont, 2, "DNAStorage.store_font", 1, coerced_ptr, report_errors);

          if (param2_this != NULL) {
            (local_this)->store_font(basic_string<char>(param1_str, param1_len), param2_this);
            Py_XDECREF(coerced);
            if (PyErr_Occurred()) {
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return (PyObject *)NULL;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAStorage.store_font() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_font(DNAStorage this, str code, const TextFont font)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_font_18_comment =
  "C++ Interface:\n"
  "store_font(DNAStorage this, str code, const TextFont font)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_font_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< TextFont > DNAStorage::find_font(basic_string< char > const &code)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_font_19(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-PointerTo< TextFont > DNAStorage::find_font(basic_string< char > const &code)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      PointerTo< TextFont > return_value = (local_this)->find_font(basic_string<char>(param1_str, param1_len));
      if (return_value != (TextFont *)NULL) {
        return_value->ref();
      }
      if (PyErr_Occurred()) {
        if (return_value.p() != (TextFont *)NULL) {
          unref_delete(return_value.p());
        }
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          if (return_value.p() != (TextFont *)NULL) {
            unref_delete(return_value.p());
          }
          return (PyObject *)NULL;
        }
#endif
        if (return_value.p() == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value.p(), Dtool_TextFont, true, false, (return_value.p())->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.find_font() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "find_font(DNAStorage this, str code)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_find_font_19_comment =
  "C++ Interface:\n"
  "find_font(DNAStorage this, str code)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_find_font_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_fonts(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_fonts_20(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_fonts(void)
    (local_this)->reset_fonts();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_fonts() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_fonts(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_fonts_20_comment =
  "C++ Interface:\n"
  "reset_fonts(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_fonts_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_catalog_code(basic_string< char > const &category, basic_string< char > const &code)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_catalog_code_21(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_catalog_code(basic_string< char > const &category, basic_string< char > const &code)
    char *param1_str;
    Py_ssize_t param1_len;
    char *param2_str;
    Py_ssize_t param2_len;
    static char *keyword_list[] = {(char *)"category", (char *)"code", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:store_catalog_code", keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
      (local_this)->store_catalog_code(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_catalog_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_catalog_code(DNAStorage this, str category, str code)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_catalog_code_21_comment =
  "C++ Interface:\n"
  "store_catalog_code(DNAStorage this, str category, str code)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_catalog_code_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAStorage::get_num_catalog_codes(basic_string< char > const &category)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_catalog_codes_22(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAStorage::get_num_catalog_codes(basic_string< char > const &category)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      unsigned int return_value = (local_this)->get_num_catalog_codes(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyLong_FromUnsignedLong(return_value);
#else
        return PyLongOrInt_FromUnsignedLong(return_value);
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_num_catalog_codes() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_catalog_codes(DNAStorage this, str category)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_num_catalog_codes_22_comment =
  "C++ Interface:\n"
  "get_num_catalog_codes(DNAStorage this, str category)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_num_catalog_codes_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_catalog_code(basic_string< char > const &category, unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_catalog_code_23(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-basic_string< char > DNAStorage::get_catalog_code(basic_string< char > const &category, unsigned int index)
    char *param1_str;
    Py_ssize_t param1_len;
    PyObject *param2;
    static char *keyword_list[] = {(char *)"category", (char *)"index", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:get_catalog_code", keyword_list, &param1_str, &param1_len, &param2)) {
      PyObject *param2_long = PyNumber_Long(param2);
      if (param2_long != NULL) {
        basic_string< char > return_value = (local_this)->get_catalog_code(basic_string<char>(param1_str, param1_len), PyLong_AsUnsignedLong(param2_long));
        Py_XDECREF(param2_long);
        if (PyErr_Occurred()) {
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return (PyObject *)NULL;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
#if PY_MAJOR_VERSION >= 3
          return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
          return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_catalog_code() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_catalog_code(DNAStorage this, str category, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_catalog_code_23_comment =
  "C++ Interface:\n"
  "get_catalog_code(DNAStorage this, str category, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_catalog_code_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath DNAStorage::find_node(basic_string< char > const &code)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_node_24(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-NodePath DNAStorage::find_node(basic_string< char > const &code)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      NodePath result = (local_this)->find_node(basic_string<char>(param1_str, param1_len));
      NodePath *return_value = new NodePath(result);
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (PyErr_Occurred()) {
        delete return_value;
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          delete return_value;
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstance((void *)return_value, Dtool_NodePath, true, false);
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.find_node() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "find_node(DNAStorage this, str code)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_find_node_24_comment =
  "C++ Interface:\n"
  "find_node(DNAStorage this, str code)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_find_node_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_node(basic_string< char > const &filename, basic_string< char > const &search, basic_string< char > const &code)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_node_25(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_node(basic_string< char > const &filename, basic_string< char > const &search, basic_string< char > const &code)
    char *param1_str;
    Py_ssize_t param1_len;
    char *param2_str;
    Py_ssize_t param2_len;
    char *param3_str;
    Py_ssize_t param3_len;
    static char *keyword_list[] = {(char *)"filename", (char *)"search", (char *)"code", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:store_node", keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len)) {
      (local_this)->store_node(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_node() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_node(DNAStorage this, str filename, str search, str code)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_node_25_comment =
  "C++ Interface:\n"
  "store_node(DNAStorage this, str filename, str search, str code)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_node_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_hood_node(basic_string< char > const &filename, basic_string< char > const &search, basic_string< char > const &code)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_hood_node_26(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_hood_node(basic_string< char > const &filename, basic_string< char > const &search, basic_string< char > const &code)
    char *param1_str;
    Py_ssize_t param1_len;
    char *param2_str;
    Py_ssize_t param2_len;
    char *param3_str;
    Py_ssize_t param3_len;
    static char *keyword_list[] = {(char *)"filename", (char *)"search", (char *)"code", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:store_hood_node", keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len)) {
      (local_this)->store_hood_node(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_hood_node() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_hood_node(DNAStorage this, str filename, str search, str code)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_hood_node_26_comment =
  "C++ Interface:\n"
  "store_hood_node(DNAStorage this, str filename, str search, str code)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_hood_node_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_place_node(basic_string< char > const &filename, basic_string< char > const &search, basic_string< char > const &code)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_place_node_27(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_place_node(basic_string< char > const &filename, basic_string< char > const &search, basic_string< char > const &code)
    char *param1_str;
    Py_ssize_t param1_len;
    char *param2_str;
    Py_ssize_t param2_len;
    char *param3_str;
    Py_ssize_t param3_len;
    static char *keyword_list[] = {(char *)"filename", (char *)"search", (char *)"code", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:store_place_node", keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len)) {
      (local_this)->store_place_node(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_place_node() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_place_node(DNAStorage this, str filename, str search, str code)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_place_node_27_comment =
  "C++ Interface:\n"
  "store_place_node(DNAStorage this, str filename, str search, str code)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_place_node_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_nodes(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_nodes_28(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_nodes(void)
    (local_this)->reset_nodes();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_nodes() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_nodes(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_nodes_28_comment =
  "C++ Interface:\n"
  "reset_nodes(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_nodes_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_hood_nodes(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_hood_nodes_29(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_hood_nodes(void)
    (local_this)->reset_hood_nodes();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_hood_nodes() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_hood_nodes(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_hood_nodes_29_comment =
  "C++ Interface:\n"
  "reset_hood_nodes(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_hood_nodes_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_place_nodes(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_place_nodes_30(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_place_nodes(void)
    (local_this)->reset_place_nodes();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_place_nodes() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_place_nodes(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_place_nodes_30_comment =
  "C++ Interface:\n"
  "reset_place_nodes(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_place_nodes_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_hood(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_hood_31(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_hood(void)
    (local_this)->reset_hood();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_hood() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_hood(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_hood_31_comment =
  "C++ Interface:\n"
  "reset_hood(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_hood_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_door(short int block_number, NodePath &door)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_door_32(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void DNAStorage::store_block_door(short int block_number, NodePath &door)
        int param1;
        PyObject *param2;
        static char *keyword_list[] = {(char *)"block_number", (char *)"door", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:store_block_door", keyword_list, &param1, &param2)) {
          NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNAStorage.store_block_door", 0, coerced_ptr, report_errors);

          if (param2_this != NULL) {
            (local_this)->store_block_door((short int)param1, *param2_this);
            Py_XDECREF(coerced);
            if (PyErr_Occurred()) {
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return (PyObject *)NULL;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAStorage.store_block_door() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_block_door(DNAStorage this, int block_number, NodePath door)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_block_door_32_comment =
  "C++ Interface:\n"
  "store_block_door(DNAStorage this, int block_number, NodePath door)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_block_door_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_zone(short int block_number, unsigned short int zone_id)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_zone_33(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_block_zone(short int block_number, unsigned short int zone_id)
    int param1;
    PyObject *param2;
    static char *keyword_list[] = {(char *)"block_number", (char *)"zone_id", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:store_block_zone", keyword_list, &param1, &param2)) {
      PyObject *param2_long = PyNumber_Long(param2);
      if (param2_long != NULL) {
        (local_this)->store_block_zone((short int)param1, PyLong_AsUnsignedLong(param2_long));
        Py_XDECREF(param2_long);
        if (PyErr_Occurred()) {
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return (PyObject *)NULL;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_block_zone() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_block_zone(DNAStorage this, int block_number, unsigned int zone_id)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_block_zone_33_comment =
  "C++ Interface:\n"
  "store_block_zone(DNAStorage this, int block_number, unsigned int zone_id)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_block_zone_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_number(short int block_number)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_number_34(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_block_number(short int block_number)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      (local_this)->store_block_number((short int)param1);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_block_number() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_block_number(DNAStorage this, int block_number)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_block_number_34_comment =
  "C++ Interface:\n"
  "store_block_number(DNAStorage this, int block_number)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_block_number_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_title(short int block_number, basic_string< char > const &title)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_title_35(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_block_title(short int block_number, basic_string< char > const &title)
    int param1;
    char *param2_str;
    Py_ssize_t param2_len;
    static char *keyword_list[] = {(char *)"block_number", (char *)"title", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "is#:store_block_title", keyword_list, &param1, &param2_str, &param2_len)) {
      (local_this)->store_block_title((short int)param1, basic_string<char>(param2_str, param2_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_block_title() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_block_title(DNAStorage this, int block_number, str title)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_block_title_35_comment =
  "C++ Interface:\n"
  "store_block_title(DNAStorage this, int block_number, str title)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_block_title_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_article(short int block_number, basic_string< char > const &article)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_article_36(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_block_article(short int block_number, basic_string< char > const &article)
    int param1;
    char *param2_str;
    Py_ssize_t param2_len;
    static char *keyword_list[] = {(char *)"block_number", (char *)"article", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "is#:store_block_article", keyword_list, &param1, &param2_str, &param2_len)) {
      (local_this)->store_block_article((short int)param1, basic_string<char>(param2_str, param2_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_block_article() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_block_article(DNAStorage this, int block_number, str article)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_block_article_36_comment =
  "C++ Interface:\n"
  "store_block_article(DNAStorage this, int block_number, str article)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_block_article_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_building_type(short int block_number, basic_string< char > const &bldg_type)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_building_type_37(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_block_building_type(short int block_number, basic_string< char > const &bldg_type)
    int param1;
    char *param2_str;
    Py_ssize_t param2_len;
    static char *keyword_list[] = {(char *)"block_number", (char *)"bldg_type", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "is#:store_block_building_type", keyword_list, &param1, &param2_str, &param2_len)) {
      (local_this)->store_block_building_type((short int)param1, basic_string<char>(param2_str, param2_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_block_building_type() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_block_building_type(DNAStorage this, int block_number, str bldg_type)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_block_building_type_37_comment =
  "C++ Interface:\n"
  "store_block_building_type(DNAStorage this, int block_number, str bldg_type)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_block_building_type_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block(short int block_number, basic_string< char > const &title, basic_string< char > const &article, basic_string< char > const &bldg_type, unsigned short int zone_id)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_38(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_block(short int block_number, basic_string< char > const &title, basic_string< char > const &article, basic_string< char > const &bldg_type, unsigned short int zone_id)
    int param1;
    char *param2_str;
    Py_ssize_t param2_len;
    char *param3_str;
    Py_ssize_t param3_len;
    char *param4_str;
    Py_ssize_t param4_len;
    PyObject *param5;
    static char *keyword_list[] = {(char *)"block_number", (char *)"title", (char *)"article", (char *)"bldg_type", (char *)"zone_id", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "is#s#s#O:store_block", keyword_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4_str, &param4_len, &param5)) {
      PyObject *param5_long = PyNumber_Long(param5);
      if (param5_long != NULL) {
        (local_this)->store_block((short int)param1, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len), basic_string<char>(param4_str, param4_len), PyLong_AsUnsignedLong(param5_long));
        Py_XDECREF(param5_long);
        if (PyErr_Occurred()) {
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return (PyObject *)NULL;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_block() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_block(DNAStorage this, int block_number, str title, str article, str bldg_type, unsigned int zone_id)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_block_38_comment =
  "C++ Interface:\n"
  "store_block(DNAStorage this, int block_number, str title, str article, str bldg_type, unsigned int zone_id)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_block_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAStorage::get_num_block_numbers(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_block_numbers_39(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAStorage::get_num_block_numbers(void)
    unsigned int return_value = (local_this)->get_num_block_numbers();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_num_block_numbers() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_block_numbers(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_num_block_numbers_39_comment =
  "C++ Interface:\n"
  "get_num_block_numbers(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_num_block_numbers_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_block(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_block_40(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-basic_string< char > DNAStorage::get_block(basic_string< char > const &name)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      basic_string< char > return_value = (local_this)->get_block(basic_string<char>(param1_str, param1_len));
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
        return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_block() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_block(DNAStorage this, str name)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_block_40_comment =
  "C++ Interface:\n"
  "get_block(DNAStorage this, str name)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_block_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_block_building_type(short int block_number)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_block_building_type_41(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-basic_string< char > DNAStorage::get_block_building_type(short int block_number)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      basic_string< char > return_value = (local_this)->get_block_building_type((short int)param1);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
        return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_block_building_type() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_block_building_type(DNAStorage this, int block_number)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_block_building_type_41_comment =
  "C++ Interface:\n"
  "get_block_building_type(DNAStorage this, int block_number)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_block_building_type_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_title_from_block_number(short int block_number)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_title_from_block_number_42(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-basic_string< char > DNAStorage::get_title_from_block_number(short int block_number)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      basic_string< char > return_value = (local_this)->get_title_from_block_number((short int)param1);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyUnicode_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#else
        return PyString_FromStringAndSize(return_value.data(), (Py_ssize_t)return_value.length());
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_title_from_block_number() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_title_from_block_number(DNAStorage this, int block_number)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_title_from_block_number_42_comment =
  "C++ Interface:\n"
  "get_title_from_block_number(DNAStorage this, int block_number)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_title_from_block_number_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath DNAStorage::get_door_pos_hpr_from_block_number(short int block_number)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_door_pos_hpr_from_block_number_43(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-NodePath DNAStorage::get_door_pos_hpr_from_block_number(short int block_number)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      NodePath result = (local_this)->get_door_pos_hpr_from_block_number((short int)param1);
      NodePath *return_value = new NodePath(result);
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (PyErr_Occurred()) {
        delete return_value;
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          delete return_value;
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstance((void *)return_value, Dtool_NodePath, true, false);
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_door_pos_hpr_from_block_number() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_door_pos_hpr_from_block_number(DNAStorage this, int block_number)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_door_pos_hpr_from_block_number_43_comment =
  "C++ Interface:\n"
  "get_door_pos_hpr_from_block_number(DNAStorage this, int block_number)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_door_pos_hpr_from_block_number_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAStorage::get_block_number_at(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_block_number_at_44(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAStorage::get_block_number_at(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      unsigned int return_value = (local_this)->get_block_number_at(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyLong_FromUnsignedLong(return_value);
#else
        return PyLongOrInt_FromUnsignedLong(return_value);
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_block_number_at() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_block_number_at(DNAStorage this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_block_number_at_44_comment =
  "C++ Interface:\n"
  "get_block_number_at(DNAStorage this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_block_number_at_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int DNAStorage::get_zone_from_block_number(short int block_number)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_zone_from_block_number_45(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned short int DNAStorage::get_zone_from_block_number(short int block_number)
    int param1;
    if (PyArg_Parse(arg, "i", &param1)) {
      unsigned short int return_value = (local_this)->get_zone_from_block_number((short int)param1);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
#if PY_MAJOR_VERSION >= 3
        return PyLong_FromUnsignedLong(return_value);
#else
        return PyLongOrInt_FromUnsignedLong(return_value);
#endif
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_zone_from_block_number() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_zone_from_block_number(DNAStorage this, int block_number)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_zone_from_block_number_45_comment =
  "C++ Interface:\n"
  "get_zone_from_block_number(DNAStorage this, int block_number)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_zone_from_block_number_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_block_numbers(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_block_numbers_46(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_block_numbers(void)
    (local_this)->reset_block_numbers();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_block_numbers() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_block_numbers(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_block_numbers_46_comment =
  "C++ Interface:\n"
  "reset_block_numbers(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_block_numbers_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_block_zones(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_block_zones_47(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_block_zones(void)
    (local_this)->reset_block_zones();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_block_zones() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_block_zones(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_block_zones_47_comment =
  "C++ Interface:\n"
  "reset_block_zones(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_block_zones_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DNAStorage::allow_suit_origin(NodePath &np)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_allow_suit_origin_48(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-bool DNAStorage::allow_suit_origin(NodePath &np)
        NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_NodePath, 1, "DNAStorage.allow_suit_origin", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          bool return_value = (local_this)->allow_suit_origin(*arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            return PyBool_FromLong(return_value);
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAStorage.allow_suit_origin() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "allow_suit_origin(DNAStorage this, NodePath np)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_allow_suit_origin_48_comment =
  "C++ Interface:\n"
  "allow_suit_origin(DNAStorage this, NodePath np)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_allow_suit_origin_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_suit_edge(unsigned short int start_index, unsigned short int end_index, unsigned short int zone_id)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_suit_edge_49(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::store_suit_edge(unsigned short int start_index, unsigned short int end_index, unsigned short int zone_id)
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    static char *keyword_list[] = {(char *)"start_index", (char *)"end_index", (char *)"zone_id", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:store_suit_edge", keyword_list, &param1, &param2, &param3)) {
      PyObject *param1_long = PyNumber_Long(param1);PyObject *param2_long = PyNumber_Long(param2);PyObject *param3_long = PyNumber_Long(param3);
      if (param1_long != NULL && param2_long != NULL && param3_long != NULL) {
        (local_this)->store_suit_edge(PyLong_AsUnsignedLong(param1_long), PyLong_AsUnsignedLong(param2_long), PyLong_AsUnsignedLong(param3_long));
        Py_XDECREF(param1_long);Py_XDECREF(param2_long);Py_XDECREF(param3_long);
        if (PyErr_Occurred()) {
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return (PyObject *)NULL;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.store_suit_edge() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_suit_edge(DNAStorage this, unsigned int start_index, unsigned int end_index, unsigned int zone_id)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_suit_edge_49_comment =
  "C++ Interface:\n"
  "store_suit_edge(DNAStorage this, unsigned int start_index, unsigned int end_index, unsigned int zone_id)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_suit_edge_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitEdge *DNAStorage::get_suit_edge(unsigned short int start_index, unsigned short int end_index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_edge_50(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-DNASuitEdge *DNAStorage::get_suit_edge(unsigned short int start_index, unsigned short int end_index)
    PyObject *param1;
    PyObject *param2;
    static char *keyword_list[] = {(char *)"start_index", (char *)"end_index", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_suit_edge", keyword_list, &param1, &param2)) {
      PyObject *param1_long = PyNumber_Long(param1);PyObject *param2_long = PyNumber_Long(param2);
      if (param1_long != NULL && param2_long != NULL) {
        DNASuitEdge *return_value = (local_this)->get_suit_edge(PyLong_AsUnsignedLong(param1_long), PyLong_AsUnsignedLong(param2_long));
        Py_XDECREF(param1_long);Py_XDECREF(param2_long);
        if (PyErr_Occurred()) {
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return (PyObject *)NULL;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          if (return_value == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitEdge, false, false, (return_value)->as_typed_object()->get_type_index());
          }
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_suit_edge() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_suit_edge(DNAStorage this, unsigned int start_index, unsigned int end_index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_suit_edge_50_comment =
  "C++ Interface:\n"
  "get_suit_edge(DNAStorage this, unsigned int start_index, unsigned int end_index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_suit_edge_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_suit_point(DNASuitPoint *suit_point)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_suit_point_51(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void DNAStorage::store_suit_point(DNASuitPoint *suit_point)
        DNASuitPoint *arg_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNASuitPoint, 1, "DNAStorage.store_suit_point", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->store_suit_point(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            Py_INCREF(Py_None);
            return Py_None;
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAStorage.store_suit_point() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "store_suit_point(DNAStorage this, DNASuitPoint suit_point)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_store_suit_point_51_comment =
  "C++ Interface:\n"
  "store_suit_point(DNAStorage this, DNASuitPoint suit_point)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_store_suit_point_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPoint *DNAStorage::get_suit_point_at_index(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_point_at_index_52(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-DNASuitPoint *DNAStorage::get_suit_point_at_index(unsigned int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      DNASuitPoint *return_value = (local_this)->get_suit_point_at_index(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPoint, false, false, (return_value)->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_suit_point_at_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_suit_point_at_index(DNAStorage this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_suit_point_at_index_52_comment =
  "C++ Interface:\n"
  "get_suit_point_at_index(DNAStorage this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_suit_point_at_index_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPoint *DNAStorage::get_suit_point_with_index(unsigned short int index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_point_with_index_53(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-DNASuitPoint *DNAStorage::get_suit_point_with_index(unsigned short int index)
    PyObject *arg_long = PyNumber_Long(arg);
    if (arg_long != NULL) {
      DNASuitPoint *return_value = (local_this)->get_suit_point_with_index(PyLong_AsUnsignedLong(arg_long));
      Py_XDECREF(arg_long);
      if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
          // TypeError raised; continue to next overload type.
        } else {
          return (PyObject *)NULL;
        }
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPoint, false, false, (return_value)->as_typed_object()->get_type_index());
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_suit_point_with_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_suit_point_with_index(DNAStorage this, unsigned int index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_suit_point_with_index_53_comment =
  "C++ Interface:\n"
  "get_suit_point_with_index(DNAStorage this, unsigned int index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_suit_point_with_index_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DNAStorage::get_num_suit_points(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_suit_points_54(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned int DNAStorage::get_num_suit_points(void)
    unsigned int return_value = (local_this)->get_num_suit_points();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
#if PY_MAJOR_VERSION >= 3
      return PyLong_FromUnsignedLong(return_value);
#else
      return PyLongOrInt_FromUnsignedLong(return_value);
#endif
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_num_suit_points() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_num_suit_points(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_num_suit_points_54_comment =
  "C++ Interface:\n"
  "get_num_suit_points(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_num_suit_points_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::reset_suit_points(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_suit_points_55(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void DNAStorage::reset_suit_points(void)
    (local_this)->reset_suit_points();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.reset_suit_points() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "reset_suit_points(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_reset_suit_points_55_comment =
  "C++ Interface:\n"
  "reset_suit_points(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_reset_suit_points_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPath *DNAStorage::get_suit_path(DNASuitPoint *start_point, DNASuitPoint *end_point, unsigned short int min_path_len, unsigned short int max_path_len)
 * DNASuitPath *DNAStorage::get_suit_path(DNASuitPoint *start_point, DNASuitPoint *end_point, unsigned short int min_path_len, unsigned short int max_path_len = (300))
 * DNASuitPath *DNAStorage::get_suit_path(DNASuitPoint *start_point, DNASuitPoint *end_point, unsigned short int min_path_len = (40), unsigned short int max_path_len = (300))
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_path_56(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-DNASuitPath *DNAStorage::get_suit_path(DNASuitPoint *start_point, DNASuitPoint *end_point, unsigned short int min_path_len = (40), unsigned short int max_path_len = (300))
          PyObject *param1;
          PyObject *param2;
          static char *keyword_list[] = {(char *)"start_point", (char *)"end_point", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_suit_path", keyword_list, &param1, &param2)) {
            DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "DNAStorage.get_suit_path", 0, coerced_ptr, report_errors);
DNASuitPoint *param2_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNASuitPoint, 2, "DNAStorage.get_suit_path", 0, coerced_ptr, report_errors);

            if (param1_this != NULL && param2_this != NULL) {
              DNASuitPath *return_value = (local_this)->get_suit_path(param1_this, param2_this);
              Py_XDECREF(coerced);
              if (PyErr_Occurred()) {
                if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
                  return (PyObject *)NULL;
                }
              } else {
#ifndef NDEBUG
                Notify *notify = Notify::ptr();
                if (notify->has_assert_failed()) {
                  PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                  notify->clear_assert_failed();
                  return (PyObject *)NULL;
                }
#endif
                if (return_value == NULL) {
                  Py_INCREF(Py_None);
                  return Py_None;
                } else {
                  return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPath, false, false, (return_value)->as_typed_object()->get_type_index());
                }
              }
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.get_suit_path() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 3: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-DNASuitPath *DNAStorage::get_suit_path(DNASuitPoint *start_point, DNASuitPoint *end_point, unsigned short int min_path_len, unsigned short int max_path_len = (300))
          PyObject *param1;
          PyObject *param2;
          PyObject *param3;
          static char *keyword_list[] = {(char *)"start_point", (char *)"end_point", (char *)"min_path_len", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:get_suit_path", keyword_list, &param1, &param2, &param3)) {
            DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "DNAStorage.get_suit_path", 0, coerced_ptr, report_errors);
DNASuitPoint *param2_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNASuitPoint, 2, "DNAStorage.get_suit_path", 0, coerced_ptr, report_errors);
PyObject *param3_long = PyNumber_Long(param3);
            if (param1_this != NULL && param2_this != NULL && param3_long != NULL) {
              DNASuitPath *return_value = (local_this)->get_suit_path(param1_this, param2_this, PyLong_AsUnsignedLong(param3_long));
              Py_XDECREF(param3_long);
              Py_XDECREF(coerced);
              if (PyErr_Occurred()) {
                if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
                  return (PyObject *)NULL;
                }
              } else {
#ifndef NDEBUG
                Notify *notify = Notify::ptr();
                if (notify->has_assert_failed()) {
                  PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                  notify->clear_assert_failed();
                  return (PyObject *)NULL;
                }
#endif
                if (return_value == NULL) {
                  Py_INCREF(Py_None);
                  return Py_None;
                } else {
                  return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPath, false, false, (return_value)->as_typed_object()->get_type_index());
                }
              }
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.get_suit_path() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 4: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-DNASuitPath *DNAStorage::get_suit_path(DNASuitPoint *start_point, DNASuitPoint *end_point, unsigned short int min_path_len, unsigned short int max_path_len)
          PyObject *param1;
          PyObject *param2;
          PyObject *param3;
          PyObject *param4;
          static char *keyword_list[] = {(char *)"start_point", (char *)"end_point", (char *)"min_path_len", (char *)"max_path_len", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:get_suit_path", keyword_list, &param1, &param2, &param3, &param4)) {
            DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "DNAStorage.get_suit_path", 0, coerced_ptr, report_errors);
DNASuitPoint *param2_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNASuitPoint, 2, "DNAStorage.get_suit_path", 0, coerced_ptr, report_errors);
PyObject *param3_long = PyNumber_Long(param3);PyObject *param4_long = PyNumber_Long(param4);
            if (param1_this != NULL && param2_this != NULL && param3_long != NULL && param4_long != NULL) {
              DNASuitPath *return_value = (local_this)->get_suit_path(param1_this, param2_this, PyLong_AsUnsignedLong(param3_long), PyLong_AsUnsignedLong(param4_long));
              Py_XDECREF(param3_long);Py_XDECREF(param4_long);
              Py_XDECREF(coerced);
              if (PyErr_Occurred()) {
                if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
                  return (PyObject *)NULL;
                }
              } else {
#ifndef NDEBUG
                Notify *notify = Notify::ptr();
                if (notify->has_assert_failed()) {
                  PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                  notify->clear_assert_failed();
                  return (PyObject *)NULL;
                }
#endif
                if (return_value == NULL) {
                  Py_INCREF(Py_None);
                  return Py_None;
                } else {
                  return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPath, false, false, (return_value)->as_typed_object()->get_type_index());
                }
              }
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.get_suit_path() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "get_suit_path() takes 3, 4, or 5 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "get_suit_path(DNAStorage this, DNASuitPoint start_point, DNASuitPoint end_point)\n"
      "get_suit_path(DNAStorage this, DNASuitPoint start_point, DNASuitPoint end_point, unsigned int min_path_len)\n"
      "get_suit_path(DNAStorage this, DNASuitPoint start_point, DNASuitPoint end_point, unsigned int min_path_len, unsigned int max_path_len)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_suit_path_56_comment =
  "C++ Interface:\n"
  "get_suit_path(DNAStorage this, DNASuitPoint start_point, DNASuitPoint end_point)\n"
  "get_suit_path(DNAStorage this, DNASuitPoint start_point, DNASuitPoint end_point, unsigned int min_path_len)\n"
  "get_suit_path(DNAStorage this, DNASuitPoint start_point, DNASuitPoint end_point, unsigned int min_path_len, unsigned int max_path_len)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_suit_path_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float DNAStorage::get_suit_edge_travel_time(unsigned short int start_index, unsigned short int end_index, float suit_walk_speed)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_edge_travel_time_57(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-float DNAStorage::get_suit_edge_travel_time(unsigned short int start_index, unsigned short int end_index, float suit_walk_speed)
    PyObject *param1;
    PyObject *param2;
    float param3;
    static char *keyword_list[] = {(char *)"start_index", (char *)"end_index", (char *)"suit_walk_speed", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOf:get_suit_edge_travel_time", keyword_list, &param1, &param2, &param3)) {
      PyObject *param1_long = PyNumber_Long(param1);PyObject *param2_long = PyNumber_Long(param2);
      if (param1_long != NULL && param2_long != NULL) {
        float return_value = (local_this)->get_suit_edge_travel_time(PyLong_AsUnsignedLong(param1_long), PyLong_AsUnsignedLong(param2_long), (float)param3);
        Py_XDECREF(param1_long);Py_XDECREF(param2_long);
        if (PyErr_Occurred()) {
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return (PyObject *)NULL;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          return PyFloat_FromDouble(return_value);
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_suit_edge_travel_time() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_suit_edge_travel_time(DNAStorage this, unsigned int start_index, unsigned int end_index, float suit_walk_speed)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_suit_edge_travel_time_57_comment =
  "C++ Interface:\n"
  "get_suit_edge_travel_time(DNAStorage this, unsigned int start_index, unsigned int end_index, float suit_walk_speed)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_suit_edge_travel_time_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int DNAStorage::get_suit_edge_zone(unsigned short int start_index, unsigned short int end_index)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_edge_zone_58(PyObject *self, PyObject *args, PyObject *kwds) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-unsigned short int DNAStorage::get_suit_edge_zone(unsigned short int start_index, unsigned short int end_index)
    PyObject *param1;
    PyObject *param2;
    static char *keyword_list[] = {(char *)"start_index", (char *)"end_index", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_suit_edge_zone", keyword_list, &param1, &param2)) {
      PyObject *param1_long = PyNumber_Long(param1);PyObject *param2_long = PyNumber_Long(param2);
      if (param1_long != NULL && param2_long != NULL) {
        unsigned short int return_value = (local_this)->get_suit_edge_zone(PyLong_AsUnsignedLong(param1_long), PyLong_AsUnsignedLong(param2_long));
        Py_XDECREF(param1_long);Py_XDECREF(param2_long);
        if (PyErr_Occurred()) {
          if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            // TypeError raised; continue to next overload type.
          } else {
            return (PyObject *)NULL;
          }
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
#if PY_MAJOR_VERSION >= 3
          return PyLong_FromUnsignedLong(return_value);
#else
          return PyLongOrInt_FromUnsignedLong(return_value);
#endif
        }
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.get_suit_edge_zone() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_suit_edge_zone(DNAStorage this, unsigned int start_index, unsigned int end_index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_suit_edge_zone_58_comment =
  "C++ Interface:\n"
  "get_suit_edge_zone(DNAStorage this, unsigned int start_index, unsigned int end_index)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_suit_edge_zone_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPath *DNAStorage::get_adjacent_points(DNASuitPoint *point)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_adjacent_points_59(PyObject *self, PyObject *arg) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-DNASuitPath *DNAStorage::get_adjacent_points(DNASuitPoint *point)
        DNASuitPoint *arg_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_DNASuitPoint, 1, "DNAStorage.get_adjacent_points", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          DNASuitPath *return_value = (local_this)->get_adjacent_points(arg_this);
          Py_XDECREF(coerced);
          if (PyErr_Occurred()) {
            if (PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
              return (PyObject *)NULL;
            }
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            if (return_value == NULL) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNASuitPath, false, false, (return_value)->as_typed_object()->get_type_index());
            }
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNAStorage.get_adjacent_points() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_adjacent_points(DNAStorage this, DNASuitPoint point)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_get_adjacent_points_59_comment =
  "C++ Interface:\n"
  "get_adjacent_points(DNAStorage this, DNASuitPoint point)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_get_adjacent_points_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DNAStorage::discover_continuity(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_discover_continuity_60(PyObject *self) {
  DNAStorage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNAStorage, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-bool DNAStorage::discover_continuity(void)
    bool return_value = (local_this)->discover_continuity();
    if (PyErr_Occurred()) {
      if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        // TypeError raised; continue to next overload type.
      } else {
        return (PyObject *)NULL;
      }
    } else {
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyBool_FromLong(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call DNAStorage.discover_continuity() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "discover_continuity(DNAStorage this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNAStorage_discover_continuity_60_comment =
  "C++ Interface:\n"
  "discover_continuity(DNAStorage this)\n"
  "\n"
  "";
#else
static const char *Dtool_DNAStorage_discover_continuity_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAStorage::DNAStorage(void)
 *******************************************************************/
int Dtool_Init_DNAStorage(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += PyDict_Size(kwds);
    }
    PyErr_Format(PyExc_TypeError,
                 "DNAStorage() takes no arguments (%d given)",
                 parameter_count);
    return -1;
  }

  // 1-DNAStorage::DNAStorage(void)
  DNAStorage *return_value = new DNAStorage();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return -1;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return -1;
    }
#endif
    return DTool_PyInit_Finalize(self, return_value, &Dtool_DNAStorage, true, false);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNAStorage()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNAStorage(PyObject *self, PyObject *args) {
  return Dtool_Init_DNAStorage(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNAStorage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNAStorage) {
    printf("DNAStorage ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNAStorage *local_this = (DNAStorage *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNAStorage) {
    return local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNAStorage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNAStorage) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. DNALoader
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * NodePath DNALoader::load_DNA_file(DNAStorage *store, Filename const &file)
 *******************************************************************/
static PyObject *Dtool_DNALoader_load_DNA_file_64(PyObject *self, PyObject *args, PyObject *kwds) {
  DNALoader *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNALoader, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-NodePath DNALoader::load_DNA_file(DNAStorage *store, Filename const &file)
        PyObject *param1;
        PyObject *param2;
        static char *keyword_list[] = {(char *)"store", (char *)"file", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:load_DNA_file", keyword_list, &param1, &param2)) {
          DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "DNALoader.load_DNA_file", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "DNALoader.load_DNA_file", 1, coerced_ptr, report_errors);

          if (param1_this != NULL && param2_this != NULL) {
            NodePath result = (local_this)->load_DNA_file(param1_this, *param2_this);
            NodePath *return_value = new NodePath(result);
            Py_XDECREF(coerced);
            if (return_value == NULL) {
              return PyErr_NoMemory();
            }
            if (PyErr_Occurred()) {
              delete return_value;
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return (PyObject *)NULL;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return (PyObject *)NULL;
              }
#endif
              if (return_value == NULL) {
                Py_INCREF(Py_None);
                return Py_None;
              } else {
                return DTool_CreatePyInstance((void *)return_value, Dtool_NodePath, true, false);
              }
            }
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNALoader.load_DNA_file() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "load_DNA_file(DNALoader this, DNAStorage store, const Filename file)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNALoader_load_DNA_file_64_comment =
  "C++ Interface:\n"
  "load_DNA_file(DNALoader this, DNAStorage store, const Filename file)\n"
  "\n"
  "";
#else
static const char *Dtool_DNALoader_load_DNA_file_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAGroup *DNALoader::load_DNA_file_AI(DNAStorage *store, Filename const &file)
 *******************************************************************/
static PyObject *Dtool_DNALoader_load_DNA_file_AI_65(PyObject *self, PyObject *args, PyObject *kwds) {
  DNALoader *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DNALoader, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-DNAGroup *DNALoader::load_DNA_file_AI(DNAStorage *store, Filename const &file)
        PyObject *param1;
        PyObject *param2;
        static char *keyword_list[] = {(char *)"store", (char *)"file", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:load_DNA_file_AI", keyword_list, &param1, &param2)) {
          DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "DNALoader.load_DNA_file_AI", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "DNALoader.load_DNA_file_AI", 1, coerced_ptr, report_errors);

          if (param1_this != NULL && param2_this != NULL) {
            DNAGroup *return_value = (local_this)->load_DNA_file_AI(param1_this, *param2_this);
            Py_XDECREF(coerced);
            if (PyErr_Occurred()) {
              if (PyErr_ExceptionMatches(PyExc_TypeError)) {
                // TypeError raised; continue to next overload type.
              } else {
                return (PyObject *)NULL;
              }
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (return_value == NULL) {
                Py_INCREF(Py_None);
                return Py_None;
              } else {
                return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_DNAGroup, false, false, (return_value)->as_typed_object()->get_type_index());
              }
            }
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call DNALoader.load_DNA_file_AI() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "load_DNA_file_AI(DNALoader this, DNAStorage store, const Filename file)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_DNALoader_load_DNA_file_AI_65_comment =
  "C++ Interface:\n"
  "load_DNA_file_AI(DNALoader this, DNAStorage store, const Filename file)\n"
  "\n"
  "";
#else
static const char *Dtool_DNALoader_load_DNA_file_AI_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNALoader::DNALoader(void)
 *******************************************************************/
int Dtool_Init_DNALoader(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += PyDict_Size(kwds);
    }
    PyErr_Format(PyExc_TypeError,
                 "DNALoader() takes no arguments (%d given)",
                 parameter_count);
    return -1;
  }

  // 1-DNALoader::DNALoader(void)
  DNALoader *return_value = new DNALoader();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (PyErr_Occurred()) {
    delete return_value;
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      // TypeError raised; continue to next overload type.
    } else {
      return -1;
    }
  } else {
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return -1;
    }
#endif
    return DTool_PyInit_Finalize(self, return_value, &Dtool_DNALoader, true, false);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "DNALoader()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_DNALoader(PyObject *self, PyObject *args) {
  return Dtool_Init_DNALoader(self, args, NULL);
}

inline void *Dtool_UpcastInterface_DNALoader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_DNALoader) {
    printf("DNALoader ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  DNALoader *local_this = (DNALoader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_DNALoader) {
    return local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_DNALoader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_DNALoader) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Py Init Code For .. DNAStorage | DNAStorage
//********************************************************************
PyMethodDef Dtool_Methods_DNAStorage[] = {
  { "reset_DNA_groups", (PyCFunction) &Dtool_DNAStorage_reset_DNA_groups_4, METH_NOARGS, (char *) Dtool_DNAStorage_reset_DNA_groups_4_comment},
  { "resetDNAGroups", (PyCFunction) &Dtool_DNAStorage_reset_DNA_groups_4, METH_NOARGS, (char *) Dtool_DNAStorage_reset_DNA_groups_4_comment},
  { "reset_battle_cells", (PyCFunction) &Dtool_DNAStorage_reset_battle_cells_5, METH_NOARGS, (char *) Dtool_DNAStorage_reset_battle_cells_5_comment},
  { "resetBattleCells", (PyCFunction) &Dtool_DNAStorage_reset_battle_cells_5, METH_NOARGS, (char *) Dtool_DNAStorage_reset_battle_cells_5_comment},
  { "store_DNA_vis_group", (PyCFunction) &Dtool_DNAStorage_store_DNA_vis_group_6, METH_O, (char *) Dtool_DNAStorage_store_DNA_vis_group_6_comment},
  { "storeDNAVisGroup", (PyCFunction) &Dtool_DNAStorage_store_DNA_vis_group_6, METH_O, (char *) Dtool_DNAStorage_store_DNA_vis_group_6_comment},
  { "get_num_DNA_vis_groups", (PyCFunction) &Dtool_DNAStorage_get_num_DNA_vis_groups_7, METH_NOARGS, (char *) Dtool_DNAStorage_get_num_DNA_vis_groups_7_comment},
  { "getNumDNAVisGroups", (PyCFunction) &Dtool_DNAStorage_get_num_DNA_vis_groups_7, METH_NOARGS, (char *) Dtool_DNAStorage_get_num_DNA_vis_groups_7_comment},
  { "get_num_DNA_vis_groups_AI", (PyCFunction) &Dtool_DNAStorage_get_num_DNA_vis_groups_AI_8, METH_NOARGS, (char *) Dtool_DNAStorage_get_num_DNA_vis_groups_AI_8_comment},
  { "getNumDNAVisGroupsAI", (PyCFunction) &Dtool_DNAStorage_get_num_DNA_vis_groups_AI_8, METH_NOARGS, (char *) Dtool_DNAStorage_get_num_DNA_vis_groups_AI_8_comment},
  { "get_num_visibles_in_DNA_vis_group", (PyCFunction) &Dtool_DNAStorage_get_num_visibles_in_DNA_vis_group_9, METH_O, (char *) Dtool_DNAStorage_get_num_visibles_in_DNA_vis_group_9_comment},
  { "getNumVisiblesInDNAVisGroup", (PyCFunction) &Dtool_DNAStorage_get_num_visibles_in_DNA_vis_group_9, METH_O, (char *) Dtool_DNAStorage_get_num_visibles_in_DNA_vis_group_9_comment},
  { "get_visible_name", (PyCFunction) &Dtool_DNAStorage_get_visible_name_10, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_visible_name_10_comment},
  { "getVisibleName", (PyCFunction) &Dtool_DNAStorage_get_visible_name_10, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_visible_name_10_comment},
  { "get_DNA_vis_group_AI", (PyCFunction) &Dtool_DNAStorage_get_DNA_vis_group_AI_11, METH_O, (char *) Dtool_DNAStorage_get_DNA_vis_group_AI_11_comment},
  { "getDNAVisGroupAI", (PyCFunction) &Dtool_DNAStorage_get_DNA_vis_group_AI_11, METH_O, (char *) Dtool_DNAStorage_get_DNA_vis_group_AI_11_comment},
  { "get_DNA_vis_group_name", (PyCFunction) &Dtool_DNAStorage_get_DNA_vis_group_name_12, METH_O, (char *) Dtool_DNAStorage_get_DNA_vis_group_name_12_comment},
  { "getDNAVisGroupName", (PyCFunction) &Dtool_DNAStorage_get_DNA_vis_group_name_12, METH_O, (char *) Dtool_DNAStorage_get_DNA_vis_group_name_12_comment},
  { "reset_DNA_vis_groups", (PyCFunction) &Dtool_DNAStorage_reset_DNA_vis_groups_13, METH_NOARGS, (char *) Dtool_DNAStorage_reset_DNA_vis_groups_13_comment},
  { "resetDNAVisGroups", (PyCFunction) &Dtool_DNAStorage_reset_DNA_vis_groups_13, METH_NOARGS, (char *) Dtool_DNAStorage_reset_DNA_vis_groups_13_comment},
  { "reset_DNA_vis_groups_AI", (PyCFunction) &Dtool_DNAStorage_reset_DNA_vis_groups_AI_14, METH_NOARGS, (char *) Dtool_DNAStorage_reset_DNA_vis_groups_AI_14_comment},
  { "resetDNAVisGroupsAI", (PyCFunction) &Dtool_DNAStorage_reset_DNA_vis_groups_AI_14, METH_NOARGS, (char *) Dtool_DNAStorage_reset_DNA_vis_groups_AI_14_comment},
  { "store_texture", (PyCFunction) &Dtool_DNAStorage_store_texture_15, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_texture_15_comment},
  { "storeTexture", (PyCFunction) &Dtool_DNAStorage_store_texture_15, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_texture_15_comment},
  { "find_texture", (PyCFunction) &Dtool_DNAStorage_find_texture_16, METH_O, (char *) Dtool_DNAStorage_find_texture_16_comment},
  { "findTexture", (PyCFunction) &Dtool_DNAStorage_find_texture_16, METH_O, (char *) Dtool_DNAStorage_find_texture_16_comment},
  { "reset_textures", (PyCFunction) &Dtool_DNAStorage_reset_textures_17, METH_NOARGS, (char *) Dtool_DNAStorage_reset_textures_17_comment},
  { "resetTextures", (PyCFunction) &Dtool_DNAStorage_reset_textures_17, METH_NOARGS, (char *) Dtool_DNAStorage_reset_textures_17_comment},
  { "store_font", (PyCFunction) &Dtool_DNAStorage_store_font_18, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_font_18_comment},
  { "storeFont", (PyCFunction) &Dtool_DNAStorage_store_font_18, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_font_18_comment},
  { "find_font", (PyCFunction) &Dtool_DNAStorage_find_font_19, METH_O, (char *) Dtool_DNAStorage_find_font_19_comment},
  { "findFont", (PyCFunction) &Dtool_DNAStorage_find_font_19, METH_O, (char *) Dtool_DNAStorage_find_font_19_comment},
  { "reset_fonts", (PyCFunction) &Dtool_DNAStorage_reset_fonts_20, METH_NOARGS, (char *) Dtool_DNAStorage_reset_fonts_20_comment},
  { "resetFonts", (PyCFunction) &Dtool_DNAStorage_reset_fonts_20, METH_NOARGS, (char *) Dtool_DNAStorage_reset_fonts_20_comment},
  { "store_catalog_code", (PyCFunction) &Dtool_DNAStorage_store_catalog_code_21, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_catalog_code_21_comment},
  { "storeCatalogCode", (PyCFunction) &Dtool_DNAStorage_store_catalog_code_21, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_catalog_code_21_comment},
  { "get_num_catalog_codes", (PyCFunction) &Dtool_DNAStorage_get_num_catalog_codes_22, METH_O, (char *) Dtool_DNAStorage_get_num_catalog_codes_22_comment},
  { "getNumCatalogCodes", (PyCFunction) &Dtool_DNAStorage_get_num_catalog_codes_22, METH_O, (char *) Dtool_DNAStorage_get_num_catalog_codes_22_comment},
  { "get_catalog_code", (PyCFunction) &Dtool_DNAStorage_get_catalog_code_23, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_catalog_code_23_comment},
  { "getCatalogCode", (PyCFunction) &Dtool_DNAStorage_get_catalog_code_23, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_catalog_code_23_comment},
  { "find_node", (PyCFunction) &Dtool_DNAStorage_find_node_24, METH_O, (char *) Dtool_DNAStorage_find_node_24_comment},
  { "findNode", (PyCFunction) &Dtool_DNAStorage_find_node_24, METH_O, (char *) Dtool_DNAStorage_find_node_24_comment},
  { "store_node", (PyCFunction) &Dtool_DNAStorage_store_node_25, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_node_25_comment},
  { "storeNode", (PyCFunction) &Dtool_DNAStorage_store_node_25, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_node_25_comment},
  { "store_hood_node", (PyCFunction) &Dtool_DNAStorage_store_hood_node_26, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_hood_node_26_comment},
  { "storeHoodNode", (PyCFunction) &Dtool_DNAStorage_store_hood_node_26, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_hood_node_26_comment},
  { "store_place_node", (PyCFunction) &Dtool_DNAStorage_store_place_node_27, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_place_node_27_comment},
  { "storePlaceNode", (PyCFunction) &Dtool_DNAStorage_store_place_node_27, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_place_node_27_comment},
  { "reset_nodes", (PyCFunction) &Dtool_DNAStorage_reset_nodes_28, METH_NOARGS, (char *) Dtool_DNAStorage_reset_nodes_28_comment},
  { "resetNodes", (PyCFunction) &Dtool_DNAStorage_reset_nodes_28, METH_NOARGS, (char *) Dtool_DNAStorage_reset_nodes_28_comment},
  { "reset_hood_nodes", (PyCFunction) &Dtool_DNAStorage_reset_hood_nodes_29, METH_NOARGS, (char *) Dtool_DNAStorage_reset_hood_nodes_29_comment},
  { "resetHoodNodes", (PyCFunction) &Dtool_DNAStorage_reset_hood_nodes_29, METH_NOARGS, (char *) Dtool_DNAStorage_reset_hood_nodes_29_comment},
  { "reset_place_nodes", (PyCFunction) &Dtool_DNAStorage_reset_place_nodes_30, METH_NOARGS, (char *) Dtool_DNAStorage_reset_place_nodes_30_comment},
  { "resetPlaceNodes", (PyCFunction) &Dtool_DNAStorage_reset_place_nodes_30, METH_NOARGS, (char *) Dtool_DNAStorage_reset_place_nodes_30_comment},
  { "reset_hood", (PyCFunction) &Dtool_DNAStorage_reset_hood_31, METH_NOARGS, (char *) Dtool_DNAStorage_reset_hood_31_comment},
  { "resetHood", (PyCFunction) &Dtool_DNAStorage_reset_hood_31, METH_NOARGS, (char *) Dtool_DNAStorage_reset_hood_31_comment},
  { "store_block_door", (PyCFunction) &Dtool_DNAStorage_store_block_door_32, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_door_32_comment},
  { "storeBlockDoor", (PyCFunction) &Dtool_DNAStorage_store_block_door_32, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_door_32_comment},
  { "store_block_zone", (PyCFunction) &Dtool_DNAStorage_store_block_zone_33, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_zone_33_comment},
  { "storeBlockZone", (PyCFunction) &Dtool_DNAStorage_store_block_zone_33, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_zone_33_comment},
  { "store_block_number", (PyCFunction) &Dtool_DNAStorage_store_block_number_34, METH_O, (char *) Dtool_DNAStorage_store_block_number_34_comment},
  { "storeBlockNumber", (PyCFunction) &Dtool_DNAStorage_store_block_number_34, METH_O, (char *) Dtool_DNAStorage_store_block_number_34_comment},
  { "store_block_title", (PyCFunction) &Dtool_DNAStorage_store_block_title_35, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_title_35_comment},
  { "storeBlockTitle", (PyCFunction) &Dtool_DNAStorage_store_block_title_35, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_title_35_comment},
  { "store_block_article", (PyCFunction) &Dtool_DNAStorage_store_block_article_36, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_article_36_comment},
  { "storeBlockArticle", (PyCFunction) &Dtool_DNAStorage_store_block_article_36, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_article_36_comment},
  { "store_block_building_type", (PyCFunction) &Dtool_DNAStorage_store_block_building_type_37, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_building_type_37_comment},
  { "storeBlockBuildingType", (PyCFunction) &Dtool_DNAStorage_store_block_building_type_37, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_building_type_37_comment},
  { "store_block", (PyCFunction) &Dtool_DNAStorage_store_block_38, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_38_comment},
  { "storeBlock", (PyCFunction) &Dtool_DNAStorage_store_block_38, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_block_38_comment},
  { "get_num_block_numbers", (PyCFunction) &Dtool_DNAStorage_get_num_block_numbers_39, METH_NOARGS, (char *) Dtool_DNAStorage_get_num_block_numbers_39_comment},
  { "getNumBlockNumbers", (PyCFunction) &Dtool_DNAStorage_get_num_block_numbers_39, METH_NOARGS, (char *) Dtool_DNAStorage_get_num_block_numbers_39_comment},
  { "get_block", (PyCFunction) &Dtool_DNAStorage_get_block_40, METH_O, (char *) Dtool_DNAStorage_get_block_40_comment},
  { "getBlock", (PyCFunction) &Dtool_DNAStorage_get_block_40, METH_O, (char *) Dtool_DNAStorage_get_block_40_comment},
  { "get_block_building_type", (PyCFunction) &Dtool_DNAStorage_get_block_building_type_41, METH_O, (char *) Dtool_DNAStorage_get_block_building_type_41_comment},
  { "getBlockBuildingType", (PyCFunction) &Dtool_DNAStorage_get_block_building_type_41, METH_O, (char *) Dtool_DNAStorage_get_block_building_type_41_comment},
  { "get_title_from_block_number", (PyCFunction) &Dtool_DNAStorage_get_title_from_block_number_42, METH_O, (char *) Dtool_DNAStorage_get_title_from_block_number_42_comment},
  { "getTitleFromBlockNumber", (PyCFunction) &Dtool_DNAStorage_get_title_from_block_number_42, METH_O, (char *) Dtool_DNAStorage_get_title_from_block_number_42_comment},
  { "get_door_pos_hpr_from_block_number", (PyCFunction) &Dtool_DNAStorage_get_door_pos_hpr_from_block_number_43, METH_O, (char *) Dtool_DNAStorage_get_door_pos_hpr_from_block_number_43_comment},
  { "getDoorPosHprFromBlockNumber", (PyCFunction) &Dtool_DNAStorage_get_door_pos_hpr_from_block_number_43, METH_O, (char *) Dtool_DNAStorage_get_door_pos_hpr_from_block_number_43_comment},
  { "get_block_number_at", (PyCFunction) &Dtool_DNAStorage_get_block_number_at_44, METH_O, (char *) Dtool_DNAStorage_get_block_number_at_44_comment},
  { "getBlockNumberAt", (PyCFunction) &Dtool_DNAStorage_get_block_number_at_44, METH_O, (char *) Dtool_DNAStorage_get_block_number_at_44_comment},
  { "get_zone_from_block_number", (PyCFunction) &Dtool_DNAStorage_get_zone_from_block_number_45, METH_O, (char *) Dtool_DNAStorage_get_zone_from_block_number_45_comment},
  { "getZoneFromBlockNumber", (PyCFunction) &Dtool_DNAStorage_get_zone_from_block_number_45, METH_O, (char *) Dtool_DNAStorage_get_zone_from_block_number_45_comment},
  { "reset_block_numbers", (PyCFunction) &Dtool_DNAStorage_reset_block_numbers_46, METH_NOARGS, (char *) Dtool_DNAStorage_reset_block_numbers_46_comment},
  { "resetBlockNumbers", (PyCFunction) &Dtool_DNAStorage_reset_block_numbers_46, METH_NOARGS, (char *) Dtool_DNAStorage_reset_block_numbers_46_comment},
  { "reset_block_zones", (PyCFunction) &Dtool_DNAStorage_reset_block_zones_47, METH_NOARGS, (char *) Dtool_DNAStorage_reset_block_zones_47_comment},
  { "resetBlockZones", (PyCFunction) &Dtool_DNAStorage_reset_block_zones_47, METH_NOARGS, (char *) Dtool_DNAStorage_reset_block_zones_47_comment},
  { "allow_suit_origin", (PyCFunction) &Dtool_DNAStorage_allow_suit_origin_48, METH_O, (char *) Dtool_DNAStorage_allow_suit_origin_48_comment},
  { "allowSuitOrigin", (PyCFunction) &Dtool_DNAStorage_allow_suit_origin_48, METH_O, (char *) Dtool_DNAStorage_allow_suit_origin_48_comment},
  { "store_suit_edge", (PyCFunction) &Dtool_DNAStorage_store_suit_edge_49, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_suit_edge_49_comment},
  { "storeSuitEdge", (PyCFunction) &Dtool_DNAStorage_store_suit_edge_49, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_store_suit_edge_49_comment},
  { "get_suit_edge", (PyCFunction) &Dtool_DNAStorage_get_suit_edge_50, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_suit_edge_50_comment},
  { "getSuitEdge", (PyCFunction) &Dtool_DNAStorage_get_suit_edge_50, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_suit_edge_50_comment},
  { "store_suit_point", (PyCFunction) &Dtool_DNAStorage_store_suit_point_51, METH_O, (char *) Dtool_DNAStorage_store_suit_point_51_comment},
  { "storeSuitPoint", (PyCFunction) &Dtool_DNAStorage_store_suit_point_51, METH_O, (char *) Dtool_DNAStorage_store_suit_point_51_comment},
  { "get_suit_point_at_index", (PyCFunction) &Dtool_DNAStorage_get_suit_point_at_index_52, METH_O, (char *) Dtool_DNAStorage_get_suit_point_at_index_52_comment},
  { "getSuitPointAtIndex", (PyCFunction) &Dtool_DNAStorage_get_suit_point_at_index_52, METH_O, (char *) Dtool_DNAStorage_get_suit_point_at_index_52_comment},
  { "get_suit_point_with_index", (PyCFunction) &Dtool_DNAStorage_get_suit_point_with_index_53, METH_O, (char *) Dtool_DNAStorage_get_suit_point_with_index_53_comment},
  { "getSuitPointWithIndex", (PyCFunction) &Dtool_DNAStorage_get_suit_point_with_index_53, METH_O, (char *) Dtool_DNAStorage_get_suit_point_with_index_53_comment},
  { "get_num_suit_points", (PyCFunction) &Dtool_DNAStorage_get_num_suit_points_54, METH_NOARGS, (char *) Dtool_DNAStorage_get_num_suit_points_54_comment},
  { "getNumSuitPoints", (PyCFunction) &Dtool_DNAStorage_get_num_suit_points_54, METH_NOARGS, (char *) Dtool_DNAStorage_get_num_suit_points_54_comment},
  { "reset_suit_points", (PyCFunction) &Dtool_DNAStorage_reset_suit_points_55, METH_NOARGS, (char *) Dtool_DNAStorage_reset_suit_points_55_comment},
  { "resetSuitPoints", (PyCFunction) &Dtool_DNAStorage_reset_suit_points_55, METH_NOARGS, (char *) Dtool_DNAStorage_reset_suit_points_55_comment},
  { "get_suit_path", (PyCFunction) &Dtool_DNAStorage_get_suit_path_56, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_suit_path_56_comment},
  { "getSuitPath", (PyCFunction) &Dtool_DNAStorage_get_suit_path_56, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_suit_path_56_comment},
  { "get_suit_edge_travel_time", (PyCFunction) &Dtool_DNAStorage_get_suit_edge_travel_time_57, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_suit_edge_travel_time_57_comment},
  { "getSuitEdgeTravelTime", (PyCFunction) &Dtool_DNAStorage_get_suit_edge_travel_time_57, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_suit_edge_travel_time_57_comment},
  { "get_suit_edge_zone", (PyCFunction) &Dtool_DNAStorage_get_suit_edge_zone_58, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_suit_edge_zone_58_comment},
  { "getSuitEdgeZone", (PyCFunction) &Dtool_DNAStorage_get_suit_edge_zone_58, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNAStorage_get_suit_edge_zone_58_comment},
  { "get_adjacent_points", (PyCFunction) &Dtool_DNAStorage_get_adjacent_points_59, METH_O, (char *) Dtool_DNAStorage_get_adjacent_points_59_comment},
  { "getAdjacentPoints", (PyCFunction) &Dtool_DNAStorage_get_adjacent_points_59, METH_O, (char *) Dtool_DNAStorage_get_adjacent_points_59_comment},
  { "discover_continuity", (PyCFunction) &Dtool_DNAStorage_discover_continuity_60, METH_NOARGS, (char *) Dtool_DNAStorage_discover_continuity_60_comment},
  { "discoverContinuity", (PyCFunction) &Dtool_DNAStorage_discover_continuity_60, METH_NOARGS, (char *) Dtool_DNAStorage_discover_continuity_60_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNAStorage(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DTOOL_SUPER_BASE._Dtool_ClassInit(NULL);
    Dtool_DNAStorage.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DTOOL_SUPER_BASE.As_PyTypeObject());
    Dtool_DNAStorage.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNAStorage.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNAStorage.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNAStorage.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAStorage)");
      printf("Error in PyType_Ready(DNAStorage)");
      return;
    }
    Py_INCREF(&Dtool_DNAStorage.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNAStorage, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNAStorage.As_PyTypeObject());
    PyModule_AddObject(module, "DNAStorage", (PyObject *)&Dtool_DNAStorage.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. DNALoader | DNALoader
//********************************************************************
PyMethodDef Dtool_Methods_DNALoader[] = {
  { "load_DNA_file", (PyCFunction) &Dtool_DNALoader_load_DNA_file_64, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNALoader_load_DNA_file_64_comment},
  { "loadDNAFile", (PyCFunction) &Dtool_DNALoader_load_DNA_file_64, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNALoader_load_DNA_file_64_comment},
  { "load_DNA_file_AI", (PyCFunction) &Dtool_DNALoader_load_DNA_file_AI_65, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNALoader_load_DNA_file_AI_65_comment},
  { "loadDNAFileAI", (PyCFunction) &Dtool_DNALoader_load_DNA_file_AI_65, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_DNALoader_load_DNA_file_AI_65_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_DNALoader(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DTOOL_SUPER_BASE._Dtool_ClassInit(NULL);
    Dtool_DNALoader.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DTOOL_SUPER_BASE.As_PyTypeObject());
    Dtool_DNALoader.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_DNALoader.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_DNALoader.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_DNALoader.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNALoader)");
      printf("Error in PyType_Ready(DNALoader)");
      return;
    }
    Py_INCREF(&Dtool_DNALoader.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_DNALoader, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_DNALoader.As_PyTypeObject());
    PyModule_AddObject(module, "DNALoader", (PyObject *)&Dtool_DNALoader.As_PyTypeObject());
  }
}


//********************************************************************
//*** Module Object Linker ..
//********************************************************************
static void BuildInstants(PyObject * module) {
  // Module init upcall for DNAStorage
  Dtool_PyModuleClassInit_DNAStorage(module);
  // Module init upcall for DNALoader
  Dtool_PyModuleClassInit_DNALoader(module);
//********************************************************************
//*** Module Init Upcall ..  Externally Defined Class
//********************************************************************
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

EXPORT_THIS struct LibraryDef base_moddef = {python_simple_funcs, BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1425837827,  /* file_identifier */
  "base",  /* library_name */
  "wFFL",  /* library_hash_name */
  "libpandadna",  /* module_name */
  "base.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  159  /* next_index */
};

Configure(_in_configure_base);
ConfigureFn(_in_configure_base) {
  interrogate_request_module(&_in_module_def);
}

